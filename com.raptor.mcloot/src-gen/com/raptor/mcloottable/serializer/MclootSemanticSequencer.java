/*
 * generated by Xtext 2.21.0
 */
package com.raptor.mcloottable.serializer;

import com.google.inject.Inject;
import com.raptor.mcloottable.mcloot.AdvancementCriteria;
import com.raptor.mcloottable.mcloot.AdvancementPredicate;
import com.raptor.mcloottable.mcloot.AlternativeLootCondition;
import com.raptor.mcloottable.mcloot.AppendNBTOperation;
import com.raptor.mcloottable.mcloot.ApplyBonusLootFunction;
import com.raptor.mcloottable.mcloot.AttributeModifier;
import com.raptor.mcloottable.mcloot.BinomialCount;
import com.raptor.mcloottable.mcloot.BlockPredicate;
import com.raptor.mcloottable.mcloot.BlockStatePropertiesLootCondition;
import com.raptor.mcloottable.mcloot.BlockStateProperty;
import com.raptor.mcloottable.mcloot.BlockStatePropertyPredicate;
import com.raptor.mcloottable.mcloot.CopyNBTLootFunction;
import com.raptor.mcloottable.mcloot.CopyNameLootFunction;
import com.raptor.mcloottable.mcloot.CopyStateLootFunction;
import com.raptor.mcloottable.mcloot.DamageSourcePropertiesLootCondition;
import com.raptor.mcloottable.mcloot.EffectPredicate;
import com.raptor.mcloottable.mcloot.EnchantRandomlyLootFunction;
import com.raptor.mcloottable.mcloot.EnchantWithLevelsLootFunction;
import com.raptor.mcloottable.mcloot.EnchantmentLevel;
import com.raptor.mcloottable.mcloot.EntityFlags;
import com.raptor.mcloottable.mcloot.EntityPredicate;
import com.raptor.mcloottable.mcloot.EntityPropertiesLootCondition;
import com.raptor.mcloottable.mcloot.EntityScore;
import com.raptor.mcloottable.mcloot.EntityScoresLootCondition;
import com.raptor.mcloottable.mcloot.EquipmentPredicate;
import com.raptor.mcloottable.mcloot.ExactCount;
import com.raptor.mcloottable.mcloot.ExactDoubleRange;
import com.raptor.mcloottable.mcloot.ExactLongRange;
import com.raptor.mcloottable.mcloot.ExplorationMapLootFunction;
import com.raptor.mcloottable.mcloot.ExplosionDecayLootFunction;
import com.raptor.mcloottable.mcloot.FillPlayerHeadLootFunction;
import com.raptor.mcloottable.mcloot.FishingHookPredicate;
import com.raptor.mcloottable.mcloot.FluidPredicate;
import com.raptor.mcloottable.mcloot.FurnaceSmeltLootFunction;
import com.raptor.mcloottable.mcloot.InvertedLootCondition;
import com.raptor.mcloottable.mcloot.ItemPredicate;
import com.raptor.mcloottable.mcloot.KilledByPlayerLootCondition;
import com.raptor.mcloottable.mcloot.LimitCountLootFunction;
import com.raptor.mcloottable.mcloot.LocationCheckLootCondition;
import com.raptor.mcloottable.mcloot.LocationPredicate;
import com.raptor.mcloottable.mcloot.LootEntry;
import com.raptor.mcloottable.mcloot.LootFunction;
import com.raptor.mcloottable.mcloot.LootFunctionWithConditions;
import com.raptor.mcloottable.mcloot.LootPool;
import com.raptor.mcloottable.mcloot.LootTable;
import com.raptor.mcloottable.mcloot.LootingEnchantLootFunction;
import com.raptor.mcloottable.mcloot.MCJsonArray;
import com.raptor.mcloottable.mcloot.MCJsonBoolean;
import com.raptor.mcloottable.mcloot.MCJsonEntry;
import com.raptor.mcloottable.mcloot.MCJsonFloatingPoint;
import com.raptor.mcloottable.mcloot.MCJsonIntegral;
import com.raptor.mcloottable.mcloot.MCJsonNull;
import com.raptor.mcloottable.mcloot.MCJsonObject;
import com.raptor.mcloottable.mcloot.MCJsonString;
import com.raptor.mcloottable.mcloot.MatchToolLootCondition;
import com.raptor.mcloottable.mcloot.MclootPackage;
import com.raptor.mcloottable.mcloot.MergeNBTOperation;
import com.raptor.mcloottable.mcloot.NamespacedStatisticPredicate;
import com.raptor.mcloottable.mcloot.NormalDoubleRange;
import com.raptor.mcloottable.mcloot.NormalLongRange;
import com.raptor.mcloottable.mcloot.PlayerPredicate;
import com.raptor.mcloottable.mcloot.RandomChanceLootCondition;
import com.raptor.mcloottable.mcloot.RecipePredicate;
import com.raptor.mcloottable.mcloot.ReferenceLootCondition;
import com.raptor.mcloottable.mcloot.ReplaceNBTOperation;
import com.raptor.mcloottable.mcloot.SetAttributesLootFunction;
import com.raptor.mcloottable.mcloot.SetContentsLootFunction;
import com.raptor.mcloottable.mcloot.SetCountLootFunction;
import com.raptor.mcloottable.mcloot.SetDamageLootFunction;
import com.raptor.mcloottable.mcloot.SetLoreLootFunction;
import com.raptor.mcloottable.mcloot.SetNBTLootFunction;
import com.raptor.mcloottable.mcloot.SetNameLootFunction;
import com.raptor.mcloottable.mcloot.SetStewEffectLootFunction;
import com.raptor.mcloottable.mcloot.SingleStatisticPredicate;
import com.raptor.mcloottable.mcloot.StewEffect;
import com.raptor.mcloottable.mcloot.SurvivesExplosionLootCondition;
import com.raptor.mcloottable.mcloot.TableBonusLootCondition;
import com.raptor.mcloottable.mcloot.TimeCheckLootCondition;
import com.raptor.mcloottable.mcloot.ToolEnchantmentLootCondition;
import com.raptor.mcloottable.mcloot.UniformCount;
import com.raptor.mcloottable.mcloot.UnnamespacedStatisticPredicate;
import com.raptor.mcloottable.mcloot.WeatherCheckLootCondition;
import com.raptor.mcloottable.services.MclootGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MclootSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MclootGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MclootPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MclootPackage.ADVANCEMENT_CRITERIA:
				sequence_AdvancementCriteria(context, (AdvancementCriteria) semanticObject); 
				return; 
			case MclootPackage.ADVANCEMENT_PREDICATE:
				sequence_AdvancementPredicate(context, (AdvancementPredicate) semanticObject); 
				return; 
			case MclootPackage.ALTERNATIVE_LOOT_CONDITION:
				sequence_LootCondition1(context, (AlternativeLootCondition) semanticObject); 
				return; 
			case MclootPackage.APPEND_NBT_OPERATION:
				sequence_AppendNBTOperation(context, (AppendNBTOperation) semanticObject); 
				return; 
			case MclootPackage.APPLY_BONUS_LOOT_FUNCTION:
				sequence_ApplyBonusLootFunction(context, (ApplyBonusLootFunction) semanticObject); 
				return; 
			case MclootPackage.ATTRIBUTE_MODIFIER:
				sequence_AttributeModifier(context, (AttributeModifier) semanticObject); 
				return; 
			case MclootPackage.BINOMIAL_COUNT:
				sequence_BinomialCount(context, (BinomialCount) semanticObject); 
				return; 
			case MclootPackage.BLOCK_PREDICATE:
				if (rule == grammarAccess.getBlockPredicateRule()) {
					sequence_BlockName_BlockValues(context, (BlockPredicate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockPredicate1Rule()) {
					sequence_BlockName_BlockValues(context, (BlockPredicate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockPredicate2Rule()) {
					sequence_BlockValues(context, (BlockPredicate) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.BLOCK_STATE_PROPERTIES_LOOT_CONDITION:
				sequence_BlockStatePropertiesLootCondition(context, (BlockStatePropertiesLootCondition) semanticObject); 
				return; 
			case MclootPackage.BLOCK_STATE_PROPERTY:
				sequence_BlockStateProperty(context, (BlockStateProperty) semanticObject); 
				return; 
			case MclootPackage.BLOCK_STATE_PROPERTY_PREDICATE:
				sequence_BlockStatePropertyPredicate(context, (BlockStatePropertyPredicate) semanticObject); 
				return; 
			case MclootPackage.COPY_NBT_LOOT_FUNCTION:
				sequence_CopyNBTLootFunction(context, (CopyNBTLootFunction) semanticObject); 
				return; 
			case MclootPackage.COPY_NAME_LOOT_FUNCTION:
				sequence_CopyNameLootFunction(context, (CopyNameLootFunction) semanticObject); 
				return; 
			case MclootPackage.COPY_STATE_LOOT_FUNCTION:
				sequence_CopyStateLootFunction(context, (CopyStateLootFunction) semanticObject); 
				return; 
			case MclootPackage.DAMAGE_SOURCE_PROPERTIES_LOOT_CONDITION:
				sequence_DamageSourcePropertiesLootCondition_DamageSourcePropertiesLootCondition_1_DamageSourcePropertiesLootCondition_10_DamageSourcePropertiesLootCondition_2_DamageSourcePropertiesLootCondition_3_DamageSourcePropertiesLootCondition_4_DamageSourcePropertiesLootCondition_5_DamageSourcePropertiesLootCondition_6_DamageSourcePropertiesLootCondition_7_DamageSourcePropertiesLootCondition_8_DamageSourcePropertiesLootCondition_9(context, (DamageSourcePropertiesLootCondition) semanticObject); 
				return; 
			case MclootPackage.EFFECT_PREDICATE:
				sequence_EffectPredicate(context, (EffectPredicate) semanticObject); 
				return; 
			case MclootPackage.ENCHANT_RANDOMLY_LOOT_FUNCTION:
				sequence_EnchantRandomlyLootFunction(context, (EnchantRandomlyLootFunction) semanticObject); 
				return; 
			case MclootPackage.ENCHANT_WITH_LEVELS_LOOT_FUNCTION:
				sequence_EnchantWithLevelsLootFunction(context, (EnchantWithLevelsLootFunction) semanticObject); 
				return; 
			case MclootPackage.ENCHANTMENT_LEVEL:
				sequence_EnchantmentLevel(context, (EnchantmentLevel) semanticObject); 
				return; 
			case MclootPackage.ENTITY_FLAGS:
				if (rule == grammarAccess.getEntityFlags_1Rule()) {
					sequence_EntityFlags_1(context, (EntityFlags) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityFlagsRule()) {
					sequence_EntityFlags_1_EntityFlags_2_EntityFlags_3_EntityFlags_4_EntityFlags_5(context, (EntityFlags) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityFlags_2Rule()) {
					sequence_EntityFlags_2(context, (EntityFlags) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityFlags_3Rule()) {
					sequence_EntityFlags_3(context, (EntityFlags) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityFlags_4Rule()) {
					sequence_EntityFlags_4(context, (EntityFlags) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityFlags_5Rule()) {
					sequence_EntityFlags_5(context, (EntityFlags) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.ENTITY_PREDICATE:
				sequence_EntityPredicate(context, (EntityPredicate) semanticObject); 
				return; 
			case MclootPackage.ENTITY_PROPERTIES_LOOT_CONDITION:
				sequence_EntityPropertiesLootCondition(context, (EntityPropertiesLootCondition) semanticObject); 
				return; 
			case MclootPackage.ENTITY_SCORE:
				sequence_EntityScore(context, (EntityScore) semanticObject); 
				return; 
			case MclootPackage.ENTITY_SCORES_LOOT_CONDITION:
				sequence_EntityScoresLootCondition(context, (EntityScoresLootCondition) semanticObject); 
				return; 
			case MclootPackage.EQUIPMENT_PREDICATE:
				sequence_EquipmentPredicate(context, (EquipmentPredicate) semanticObject); 
				return; 
			case MclootPackage.EXACT_COUNT:
				sequence_ExactCount(context, (ExactCount) semanticObject); 
				return; 
			case MclootPackage.EXACT_DOUBLE_RANGE:
				if (rule == grammarAccess.getDoubleRangeRule()
						|| rule == grammarAccess.getExactDoubleRangeRule()) {
					sequence_ExactDoubleRange(context, (ExactDoubleRange) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPercentageRangeRule()
						|| rule == grammarAccess.getExactPercentageRangeRule()) {
					sequence_ExactPercentageRange(context, (ExactDoubleRange) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.EXACT_LONG_RANGE:
				if (rule == grammarAccess.getLongRangeRule()
						|| rule == grammarAccess.getExactLongRangeRule()) {
					sequence_ExactLongRange(context, (ExactLongRange) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getULongRangeRule()
						|| rule == grammarAccess.getExactULongRangeRule()) {
					sequence_ExactULongRange(context, (ExactLongRange) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.EXPLORATION_MAP_LOOT_FUNCTION:
				sequence_ExplorationMapLootFunction(context, (ExplorationMapLootFunction) semanticObject); 
				return; 
			case MclootPackage.EXPLOSION_DECAY_LOOT_FUNCTION:
				sequence_ExplosionDecayLootFunction(context, (ExplosionDecayLootFunction) semanticObject); 
				return; 
			case MclootPackage.FILL_PLAYER_HEAD_LOOT_FUNCTION:
				sequence_FillPlayerHeadLootFunction(context, (FillPlayerHeadLootFunction) semanticObject); 
				return; 
			case MclootPackage.FISHING_HOOK_PREDICATE:
				sequence_FishingHookPredicate(context, (FishingHookPredicate) semanticObject); 
				return; 
			case MclootPackage.FLUID_PREDICATE:
				if (rule == grammarAccess.getFluidPredicateRule()) {
					sequence_FluidName_FluidValues(context, (FluidPredicate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFluidPredicate1Rule()) {
					sequence_FluidName_FluidValues(context, (FluidPredicate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFluidPredicate2Rule()) {
					sequence_FluidValues(context, (FluidPredicate) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.FURNACE_SMELT_LOOT_FUNCTION:
				sequence_FurnaceSmeltLootFunction(context, (FurnaceSmeltLootFunction) semanticObject); 
				return; 
			case MclootPackage.INVERTED_LOOT_CONDITION:
				sequence_LootCondition2(context, (InvertedLootCondition) semanticObject); 
				return; 
			case MclootPackage.ITEM_PREDICATE:
				if (rule == grammarAccess.getItemPredicateRule()) {
					sequence_ItemName_ItemValues(context, (ItemPredicate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemPredicate1Rule()) {
					sequence_ItemName_ItemValues(context, (ItemPredicate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemPredicate2Rule()) {
					sequence_ItemValues(context, (ItemPredicate) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.KILLED_BY_PLAYER_LOOT_CONDITION:
				sequence_KilledByPlayerLootCondition(context, (KilledByPlayerLootCondition) semanticObject); 
				return; 
			case MclootPackage.LIMIT_COUNT_LOOT_FUNCTION:
				sequence_LimitCountLootFunction(context, (LimitCountLootFunction) semanticObject); 
				return; 
			case MclootPackage.LOCATION_CHECK_LOOT_CONDITION:
				sequence_LocationCheckLootCondition(context, (LocationCheckLootCondition) semanticObject); 
				return; 
			case MclootPackage.LOCATION_PREDICATE:
				sequence_LocationPredicate(context, (LocationPredicate) semanticObject); 
				return; 
			case MclootPackage.LOOT_ENTRY:
				sequence_LootEntry_LootEntryRest_LootEntryWeight(context, (LootEntry) semanticObject); 
				return; 
			case MclootPackage.LOOT_FUNCTION:
				sequence_XXX1(context, (LootFunction) semanticObject); 
				return; 
			case MclootPackage.LOOT_FUNCTION_WITH_CONDITIONS:
				sequence_LootFunction(context, (LootFunctionWithConditions) semanticObject); 
				return; 
			case MclootPackage.LOOT_POOL:
				sequence_LootPool(context, (LootPool) semanticObject); 
				return; 
			case MclootPackage.LOOT_TABLE:
				sequence_LootTable(context, (LootTable) semanticObject); 
				return; 
			case MclootPackage.LOOTING_ENCHANT_LOOT_FUNCTION:
				sequence_LootingEnchantLootFunction(context, (LootingEnchantLootFunction) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_ARRAY:
				sequence_MCJsonArray(context, (MCJsonArray) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_BOOLEAN:
				sequence_MCJsonBoolean(context, (MCJsonBoolean) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_ENTRY:
				sequence_MCJsonEntry(context, (MCJsonEntry) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_FLOATING_POINT:
				sequence_MCJsonFloatingPoint(context, (MCJsonFloatingPoint) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_INTEGRAL:
				sequence_MCJsonIntegral(context, (MCJsonIntegral) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_NULL:
				sequence_MCJsonNull(context, (MCJsonNull) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_OBJECT:
				sequence_MCJsonObject(context, (MCJsonObject) semanticObject); 
				return; 
			case MclootPackage.MC_JSON_STRING:
				sequence_MCJsonString(context, (MCJsonString) semanticObject); 
				return; 
			case MclootPackage.MATCH_TOOL_LOOT_CONDITION:
				if (rule == grammarAccess.getNamedLootCondition2Rule()
						|| rule == grammarAccess.getMatchToolLootCondition1Rule()) {
					sequence_MatchToolLootCondition1(context, (MatchToolLootCondition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLootConditionRule()
						|| rule == grammarAccess.getLootCondition1Rule()
						|| action == grammarAccess.getLootCondition1Access().getAlternativeLootConditionAlternativesAction_1_0_0()
						|| rule == grammarAccess.getLootCondition2Rule()
						|| rule == grammarAccess.getLootCondition3Rule()
						|| rule == grammarAccess.getNamedLootConditionRule()
						|| rule == grammarAccess.getMatchToolLootConditionRule()) {
					sequence_MatchToolLootCondition(context, (MatchToolLootCondition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLootCondition4Rule()) {
					sequence_MatchToolLootCondition_MatchToolLootCondition1(context, (MatchToolLootCondition) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.MERGE_NBT_OPERATION:
				sequence_MergeNBTOperation(context, (MergeNBTOperation) semanticObject); 
				return; 
			case MclootPackage.NAMESPACED_STATISTIC_PREDICATE:
				sequence_NamespacedStatisticPredicate(context, (NamespacedStatisticPredicate) semanticObject); 
				return; 
			case MclootPackage.NORMAL_DOUBLE_RANGE:
				if (rule == grammarAccess.getDoubleRangeRule()
						|| rule == grammarAccess.getNormalDoubleRangeRule()) {
					sequence_NormalDoubleRange(context, (NormalDoubleRange) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPercentageRangeRule()
						|| rule == grammarAccess.getNormalPercentageRangeRule()) {
					sequence_NormalPercentageRange(context, (NormalDoubleRange) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.NORMAL_LONG_RANGE:
				if (rule == grammarAccess.getLongRangeRule()
						|| rule == grammarAccess.getNormalLongRangeRule()) {
					sequence_NormalLongRange(context, (NormalLongRange) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getULongRangeRule()
						|| rule == grammarAccess.getNormalULongRangeRule()) {
					sequence_NormalULongRange(context, (NormalLongRange) semanticObject); 
					return; 
				}
				else break;
			case MclootPackage.PLAYER_PREDICATE:
				sequence_PlayerPredicate(context, (PlayerPredicate) semanticObject); 
				return; 
			case MclootPackage.RANDOM_CHANCE_LOOT_CONDITION:
				sequence_RandomChanceLootCondition(context, (RandomChanceLootCondition) semanticObject); 
				return; 
			case MclootPackage.RECIPE_PREDICATE:
				sequence_RecipePredicate(context, (RecipePredicate) semanticObject); 
				return; 
			case MclootPackage.REFERENCE_LOOT_CONDITION:
				sequence_ReferenceLootCondition(context, (ReferenceLootCondition) semanticObject); 
				return; 
			case MclootPackage.REPLACE_NBT_OPERATION:
				sequence_ReplaceNBTOperation(context, (ReplaceNBTOperation) semanticObject); 
				return; 
			case MclootPackage.SET_ATTRIBUTES_LOOT_FUNCTION:
				sequence_SetAttributesLootFunction(context, (SetAttributesLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_CONTENTS_LOOT_FUNCTION:
				sequence_SetContentsLootFunction(context, (SetContentsLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_COUNT_LOOT_FUNCTION:
				sequence_SetCountLootFunction(context, (SetCountLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_DAMAGE_LOOT_FUNCTION:
				sequence_SetDamageLootFunction(context, (SetDamageLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_LORE_LOOT_FUNCTION:
				sequence_SetLoreLootFunction(context, (SetLoreLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_NBT_LOOT_FUNCTION:
				sequence_SetNBTLootFunction(context, (SetNBTLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_NAME_LOOT_FUNCTION:
				sequence_SetNameLootFunction(context, (SetNameLootFunction) semanticObject); 
				return; 
			case MclootPackage.SET_STEW_EFFECT_LOOT_FUNCTION:
				sequence_SetStewEffectLootFunction(context, (SetStewEffectLootFunction) semanticObject); 
				return; 
			case MclootPackage.SINGLE_STATISTIC_PREDICATE:
				sequence_SingleStatisticPredicate(context, (SingleStatisticPredicate) semanticObject); 
				return; 
			case MclootPackage.STEW_EFFECT:
				sequence_StewEffect(context, (StewEffect) semanticObject); 
				return; 
			case MclootPackage.SURVIVES_EXPLOSION_LOOT_CONDITION:
				sequence_SurvivesExplosionLootCondition(context, (SurvivesExplosionLootCondition) semanticObject); 
				return; 
			case MclootPackage.TABLE_BONUS_LOOT_CONDITION:
				sequence_TableBonusLootCondition(context, (TableBonusLootCondition) semanticObject); 
				return; 
			case MclootPackage.TIME_CHECK_LOOT_CONDITION:
				sequence_TimeCheckLootCondition(context, (TimeCheckLootCondition) semanticObject); 
				return; 
			case MclootPackage.TOOL_ENCHANTMENT_LOOT_CONDITION:
				sequence_ToolEnchantmentLootCondition(context, (ToolEnchantmentLootCondition) semanticObject); 
				return; 
			case MclootPackage.UNIFORM_COUNT:
				sequence_UniformCount(context, (UniformCount) semanticObject); 
				return; 
			case MclootPackage.UNNAMESPACED_STATISTIC_PREDICATE:
				sequence_UnnamespacedStatisticPredicate(context, (UnnamespacedStatisticPredicate) semanticObject); 
				return; 
			case MclootPackage.WEATHER_CHECK_LOOT_CONDITION:
				sequence_WeatherCheckLootCondition(context, (WeatherCheckLootCondition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdvancementCriteria returns AdvancementCriteria
	 *
	 * Constraint:
	 *     (criteriaNames+=NamespacedID criteriaNames+=NamespacedID* didNotGet?='false'?)
	 */
	protected void sequence_AdvancementCriteria(ISerializationContext context, AdvancementCriteria semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdvancementPredicate returns AdvancementPredicate
	 *
	 * Constraint:
	 *     (name=NamespacedLocation (didNotGet?='false' | criteria+=AdvancementCriteria+)?)
	 */
	protected void sequence_AdvancementPredicate(ISerializationContext context, AdvancementPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NBTOperation returns AppendNBTOperation
	 *     AppendNBTOperation returns AppendNBTOperation
	 *
	 * Constraint:
	 *     (id='append' source=NBTPath target=NBTPath)
	 */
	protected void sequence_AppendNBTOperation(ISerializationContext context, AppendNBTOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__SOURCE));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAppendNBTOperationAccess().getIdAppendKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getAppendNBTOperationAccess().getSourceNBTPathParserRuleCall_1_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getAppendNBTOperationAccess().getTargetNBTPathParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns ApplyBonusLootFunction
	 *     LootFunction0 returns ApplyBonusLootFunction
	 *     ApplyBonusLootFunction returns ApplyBonusLootFunction
	 *
	 * Constraint:
	 *     (
	 *         id='apply_bonus' 
	 *         (
	 *             (
	 *                 enchantment=EnchantmentID 
	 *                 (
	 *                     formula=EnumBonusFormula? 
	 *                     (extraDefined?='extra' extra=LONG)? 
	 *                     (probabilityDefined?='probability' (probability=PERCENTAGE | probability=NUMBER))? 
	 *                     (bonusMultiplierDefined?='bonusMultiplier' bonusMultiplier=NUMBER)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 formula=EnumBonusFormula 
	 *                 (
	 *                     enchantment=EnchantmentID? 
	 *                     (probabilityDefined?='probability' (probability=PERCENTAGE | probability=NUMBER))? 
	 *                     (extraDefined?='extra' extra=LONG)? 
	 *                     (bonusMultiplierDefined?='bonusMultiplier' bonusMultiplier=NUMBER)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 enchantment=EnchantmentID 
	 *                 (
	 *                     (
	 *                         formula=EnumBonusFormula 
	 *                         (
	 *                             ((extraDefined?='extra' extra=LONG) | (probabilityDefined?='probability' (probability=PERCENTAGE | probability=NUMBER)))+ | 
	 *                             (bonusMultiplierDefined?='bonusMultiplier' bonusMultiplier=NUMBER)
	 *                         )?
	 *                     ) | 
	 *                     (
	 *                         formula=EnumBonusFormula? 
	 *                         (extraDefined?='extra' extra=LONG)? 
	 *                         (probabilityDefined?='probability' (probability=PERCENTAGE | probability=NUMBER))? 
	 *                         (bonusMultiplierDefined?='bonusMultiplier' bonusMultiplier=NUMBER)?
	 *                     )+
	 *                 )
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_ApplyBonusLootFunction(ISerializationContext context, ApplyBonusLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeModifier returns AttributeModifier
	 *
	 * Constraint:
	 *     (
	 *         id=AttributeModifierType 
	 *         (
	 *             (operation=EnumAttributeModifierOperation | amount=DoubleRange | attributeName=Key | uuid=UUID)? 
	 *             (slotDefined?='slot' ((singleSlot?='=' slots+=EnumEquipmentSlot) | slots+=EnumEquipmentSlot+)?)?
	 *         )+
	 *     )
	 */
	protected void sequence_AttributeModifier(ISerializationContext context, AttributeModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Count returns BinomialCount
	 *     SpecialCount returns BinomialCount
	 *     BinomialCount returns BinomialCount
	 *
	 * Constraint:
	 *     ((n=ULONG p=PERCENTAGE) | (p=PERCENTAGE n=ULONG) | (n=ULONG p=PERCENTAGE))
	 */
	protected void sequence_BinomialCount(ISerializationContext context, BinomialCount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockPredicate returns BlockPredicate
	 *
	 * Constraint:
	 *     ((tag=NamespacedLocation | block=NamespacedID)? (nbt=STRING? (stateDefined?='state' properties+=BlockStatePropertyPredicate*)?)+)
	 */
	protected void sequence_BlockName_BlockValues(ISerializationContext context, BlockPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     BlockPredicate1 returns BlockPredicate
	//
	// Constraint:
	//     ((tag=NamespacedLocation | block=NamespacedID) (nbt=STRING? (stateDefined?='state' properties+=BlockStatePropertyPredicate*)?)+)
	//
	// protected void sequence_BlockName_BlockValues(ISerializationContext context, BlockPredicate semanticObject) { }
	
	/**
	 * Contexts:
	 *     LootCondition returns BlockStatePropertiesLootCondition
	 *     LootCondition1 returns BlockStatePropertiesLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns BlockStatePropertiesLootCondition
	 *     LootCondition2 returns BlockStatePropertiesLootCondition
	 *     LootCondition3 returns BlockStatePropertiesLootCondition
	 *     NamedLootCondition returns BlockStatePropertiesLootCondition
	 *     LootCondition4 returns BlockStatePropertiesLootCondition
	 *     BlockStatePropertiesLootCondition returns BlockStatePropertiesLootCondition
	 *
	 * Constraint:
	 *     (id='block' inverted?='!='? block=NamespacedID (properties+=BlockStateProperty properties+=BlockStateProperty*)?)
	 */
	protected void sequence_BlockStatePropertiesLootCondition(ISerializationContext context, BlockStatePropertiesLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatePropertyPredicate returns BlockStatePropertyPredicate
	 *
	 * Constraint:
	 *     (name=Key (value=BlockstateValue | valueRange=NormalLongRange))
	 */
	protected void sequence_BlockStatePropertyPredicate(ISerializationContext context, BlockStatePropertyPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStateProperty returns BlockStateProperty
	 *
	 * Constraint:
	 *     (name=BlockstateID (value=Key | value=STRING))
	 */
	protected void sequence_BlockStateProperty(ISerializationContext context, BlockStateProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockPredicate2 returns BlockPredicate
	 *
	 * Constraint:
	 *     (nbt=STRING? (stateDefined?='state' properties+=BlockStatePropertyPredicate*)?)+
	 */
	protected void sequence_BlockValues(ISerializationContext context, BlockPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns CopyNBTLootFunction
	 *     LootFunction0 returns CopyNBTLootFunction
	 *     CopyNBTLootFunction returns CopyNBTLootFunction
	 *
	 * Constraint:
	 *     (id='copy_nbt' source=EnumNBTSource ops+=NBTOperation*)
	 */
	protected void sequence_CopyNBTLootFunction(ISerializationContext context, CopyNBTLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns CopyNameLootFunction
	 *     LootFunction0 returns CopyNameLootFunction
	 *     CopyNameLootFunction returns CopyNameLootFunction
	 *
	 * Constraint:
	 *     (id='copy_name' source=EnumNBTSource?)
	 */
	protected void sequence_CopyNameLootFunction(ISerializationContext context, CopyNameLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns CopyStateLootFunction
	 *     LootFunction0 returns CopyStateLootFunction
	 *     CopyStateLootFunction returns CopyStateLootFunction
	 *
	 * Constraint:
	 *     (id='copy_state' block=NamespacedID (properties+=BlockstateID properties+=BlockstateID*)?)
	 */
	protected void sequence_CopyStateLootFunction(ISerializationContext context, CopyStateLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns DamageSourcePropertiesLootCondition
	 *     LootCondition1 returns DamageSourcePropertiesLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns DamageSourcePropertiesLootCondition
	 *     LootCondition2 returns DamageSourcePropertiesLootCondition
	 *     LootCondition3 returns DamageSourcePropertiesLootCondition
	 *     NamedLootCondition returns DamageSourcePropertiesLootCondition
	 *     LootCondition4 returns DamageSourcePropertiesLootCondition
	 *     NamedLootCondition2 returns DamageSourcePropertiesLootCondition
	 *     DamageSourcePropertiesLootCondition returns DamageSourcePropertiesLootCondition
	 *
	 * Constraint:
	 *     (
	 *         id='damage_source' 
	 *         (
	 *             (
	 *                 (
	 *                     bypassesArmorDefined?='!' | 
	 *                     (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                     bypassesArmor?='bypasses_armor'
	 *                 ) 
	 *                 fire?='is_fire'? 
	 *                 (
	 *                     (
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     fire?='is_fire'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 (
	 *                     bypassesInvulnerabilityDefined?='!' | 
	 *                     (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                     bypassesInvulnerability?='bypasses_invulnerability'
	 *                 ) 
	 *                 bypassesMagic?='bypasses_magic'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         fire?='is_fire' | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     bypassesMagic?='bypasses_magic'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 (
	 *                     bypassesMagicDefined?='!' | 
	 *                     (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                     bypassesMagic?='bypasses_magic'
	 *                 ) 
	 *                 explosion?='is_explosion'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         fire?='is_fire' | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     explosion?='is_explosion'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 directEntity=EntityPredicate 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         explosionDefined?='!' | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         fire?='is_fire' | 
	 *                         magicDefined?='!' | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?)? 
	 *                     (magicDefined?='is_magic' (magic?='false' | magic?='true')?)? 
	 *                     (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?)? 
	 *                     (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?)? 
	 *                     (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?)? 
	 *                     (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?)? 
	 *                     (fireDefined?='is_fire' (fire?='false' | fire?='true')?)? 
	 *                     (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 (explosionDefined?='!' | (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | explosion?='is_explosion') 
	 *                 bypassesInvulnerability?='bypasses_invulnerability'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         fire?='is_fire' | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     bypassesInvulnerability?='bypasses_invulnerability'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 (fireDefined?='!' | (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | fire?='is_fire') 
	 *                 lightning?='is_lightning'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         explosion?='is_explosion' | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     lightning?='is_lightning'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 (magicDefined?='!' | (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | magic?='is_magic') 
	 *                 bypassesInvulnerability?='bypasses_invulnerability'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         fire?='is_fire' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     bypassesInvulnerability?='bypasses_invulnerability'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 (projectileDefined?='!' | (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | projectile?='is_projectile') 
	 *                 magic?='is_magic'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         fire?='is_fire' | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         lightningDefined?='!' | 
	 *                         (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | 
	 *                         lightning?='is_lightning' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     magic?='is_magic'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 (lightningDefined?='!' | (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?) | lightning?='is_lightning') 
	 *                 fire?='is_fire'? 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?) | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?) | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?) | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?) | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         (fireDefined?='is_fire' (fire?='false' | fire?='true')?) | 
	 *                         magicDefined?='!' | 
	 *                         (magicDefined?='is_magic' (magic?='false' | magic?='true')?) | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?) | 
	 *                         projectile?='is_projectile' | 
	 *                         sourceEntity=EntityPredicate
	 *                     )? 
	 *                     fire?='is_fire'?
	 *                 )*
	 *             ) | 
	 *             (
	 *                 sourceEntity=EntityPredicate 
	 *                 (
	 *                     (
	 *                         bypassesArmorDefined?='!' | 
	 *                         bypassesArmor?='bypasses_armor' | 
	 *                         bypassesInvulnerabilityDefined?='!' | 
	 *                         bypassesInvulnerability?='bypasses_invulnerability' | 
	 *                         bypassesMagicDefined?='!' | 
	 *                         bypassesMagic?='bypasses_magic' | 
	 *                         directEntity=EntityPredicate | 
	 *                         explosionDefined?='!' | 
	 *                         explosion?='is_explosion' | 
	 *                         fireDefined?='!' | 
	 *                         fire?='is_fire' | 
	 *                         magicDefined?='!' | 
	 *                         magic?='is_magic' | 
	 *                         projectileDefined?='!' | 
	 *                         projectile?='is_projectile' | 
	 *                         lightningDefined?='!' | 
	 *                         lightning?='is_lightning'
	 *                     )? 
	 *                     (bypassesInvulnerabilityDefined?='bypasses_invulnerability' (bypassesInvulnerability?='false' | bypassesInvulnerability?='true')?)? 
	 *                     (fireDefined?='is_fire' (fire?='false' | fire?='true')?)? 
	 *                     (bypassesArmorDefined?='bypasses_armor' (bypassesArmor?='false' | bypassesArmor?='true')?)? 
	 *                     (bypassesMagicDefined?='bypasses_magic' (bypassesMagic?='false' | bypassesMagic?='true')?)? 
	 *                     (projectileDefined?='is_projectile' (projectile?='false' | projectile?='true')?)? 
	 *                     (explosionDefined?='is_explosion' (explosion?='false' | explosion?='true')?)? 
	 *                     (magicDefined?='is_magic' (magic?='false' | magic?='true')?)? 
	 *                     (lightningDefined?='is_lightning' (lightning?='false' | lightning?='true')?)?
	 *                 )+
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_DamageSourcePropertiesLootCondition_DamageSourcePropertiesLootCondition_1_DamageSourcePropertiesLootCondition_10_DamageSourcePropertiesLootCondition_2_DamageSourcePropertiesLootCondition_3_DamageSourcePropertiesLootCondition_4_DamageSourcePropertiesLootCondition_5_DamageSourcePropertiesLootCondition_6_DamageSourcePropertiesLootCondition_7_DamageSourcePropertiesLootCondition_8_DamageSourcePropertiesLootCondition_9(ISerializationContext context, DamageSourcePropertiesLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectPredicate returns EffectPredicate
	 *
	 * Constraint:
	 *     (id=EffectID (amplifier=ULongRange | duration=ULongRange)*)
	 */
	protected void sequence_EffectPredicate(ISerializationContext context, EffectPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns EnchantRandomlyLootFunction
	 *     LootFunction0 returns EnchantRandomlyLootFunction
	 *     EnchantRandomlyLootFunction returns EnchantRandomlyLootFunction
	 *
	 * Constraint:
	 *     (id='enchant_randomly' (enchantments+=EnchantmentID enchantments+=EnchantmentID*)?)
	 */
	protected void sequence_EnchantRandomlyLootFunction(ISerializationContext context, EnchantRandomlyLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns EnchantWithLevelsLootFunction
	 *     LootFunction0 returns EnchantWithLevelsLootFunction
	 *     EnchantWithLevelsLootFunction returns EnchantWithLevelsLootFunction
	 *
	 * Constraint:
	 *     (
	 *         id='enchant_with_levels' 
	 *         ((treasureDefined?='treasure' treasure=BOOLEAN levels=ULongRange) | (levels=ULongRange (treasureDefined?='treasure' treasure=BOOLEAN)?))
	 *     )
	 */
	protected void sequence_EnchantWithLevelsLootFunction(ISerializationContext context, EnchantWithLevelsLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnchantmentLevel returns EnchantmentLevel
	 *
	 * Constraint:
	 *     (enchantment=EnchantmentID levels=ULongRange)
	 */
	protected void sequence_EnchantmentLevel(ISerializationContext context, EnchantmentLevel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.ENCHANTMENT_LEVEL__ENCHANTMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.ENCHANTMENT_LEVEL__ENCHANTMENT));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.ENCHANTMENT_LEVEL__LEVELS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.ENCHANTMENT_LEVEL__LEVELS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnchantmentLevelAccess().getEnchantmentEnchantmentIDParserRuleCall_0_0(), semanticObject.getEnchantment());
		feeder.accept(grammarAccess.getEnchantmentLevelAccess().getLevelsULongRangeParserRuleCall_2_0(), semanticObject.getLevels());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityFlags_1 returns EntityFlags
	 *
	 * Constraint:
	 *     (
	 *         (onFireDefined?='!' | (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | onFire?='is_on_fire') 
	 *         sneakingDefined?='!'? 
	 *         (
	 *             (
	 *                 (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                 sneaking?='is_sneaking' | 
	 *                 sprintingDefined?='!' | 
	 *                 (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                 sprinting?='is_sprinting' | 
	 *                 swimmingDefined?='!' | 
	 *                 (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                 swimming?='is_swimming' | 
	 *                 babyDefined?='!' | 
	 *                 (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                 baby?='is_baby'
	 *             )? 
	 *             sneakingDefined?='!'?
	 *         )*
	 *     )
	 */
	protected void sequence_EntityFlags_1(ISerializationContext context, EntityFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityFlags returns EntityFlags
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (onFireDefined?='!' | (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | onFire?='is_on_fire') 
	 *             sneaking?='is_sneaking'? 
	 *             (
	 *                 (
	 *                     sneakingDefined?='!' | 
	 *                     (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                     sprintingDefined?='!' | 
	 *                     (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                     sprinting?='is_sprinting' | 
	 *                     swimmingDefined?='!' | 
	 *                     (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                     swimming?='is_swimming' | 
	 *                     babyDefined?='!' | 
	 *                     (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                     baby?='is_baby'
	 *                 )? 
	 *                 sneaking?='is_sneaking'?
	 *             )*
	 *         ) | 
	 *         (
	 *             (sneakingDefined?='!' | (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | sneaking?='is_sneaking') 
	 *             babyDefined?='!'? 
	 *             (
	 *                 (
	 *                     onFireDefined?='!' | 
	 *                     (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                     onFire?='is_on_fire' | 
	 *                     sprintingDefined?='!' | 
	 *                     (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                     sprinting?='is_sprinting' | 
	 *                     swimmingDefined?='!' | 
	 *                     (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                     swimming?='is_swimming' | 
	 *                     (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                     baby?='is_baby'
	 *                 )? 
	 *                 babyDefined?='!'?
	 *             )*
	 *         ) | 
	 *         (
	 *             (sprintingDefined?='!' | (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | sprinting?='is_sprinting') 
	 *             babyDefined?='!'? 
	 *             (
	 *                 (
	 *                     onFireDefined?='!' | 
	 *                     (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                     onFire?='is_on_fire' | 
	 *                     sneakingDefined?='!' | 
	 *                     (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                     sneaking?='is_sneaking' | 
	 *                     swimmingDefined?='!' | 
	 *                     (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                     swimming?='is_swimming' | 
	 *                     (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                     baby?='is_baby'
	 *                 )? 
	 *                 babyDefined?='!'?
	 *             )*
	 *         ) | 
	 *         (
	 *             (swimmingDefined?='!' | (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | swimming?='is_swimming') 
	 *             sneaking?='is_sneaking'? 
	 *             (
	 *                 (
	 *                     onFireDefined?='!' | 
	 *                     (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                     onFire?='is_on_fire' | 
	 *                     sneakingDefined?='!' | 
	 *                     (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                     sprintingDefined?='!' | 
	 *                     (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                     sprinting?='is_sprinting' | 
	 *                     babyDefined?='!' | 
	 *                     (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                     baby?='is_baby'
	 *                 )? 
	 *                 sneaking?='is_sneaking'?
	 *             )*
	 *         ) | 
	 *         (
	 *             (babyDefined?='!' | (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | baby?='is_baby') 
	 *             sprintingDefined?='!'? 
	 *             (
	 *                 (
	 *                     onFireDefined?='!' | 
	 *                     (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                     onFire?='is_on_fire' | 
	 *                     sneakingDefined?='!' | 
	 *                     (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                     sneaking?='is_sneaking' | 
	 *                     (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                     sprinting?='is_sprinting' | 
	 *                     swimmingDefined?='!' | 
	 *                     (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                     swimming?='is_swimming'
	 *                 )? 
	 *                 sprintingDefined?='!'?
	 *             )*
	 *         )
	 *     )
	 */
	protected void sequence_EntityFlags_1_EntityFlags_2_EntityFlags_3_EntityFlags_4_EntityFlags_5(ISerializationContext context, EntityFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityFlags_2 returns EntityFlags
	 *
	 * Constraint:
	 *     (
	 *         (sneakingDefined?='!' | (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | sneaking?='is_sneaking') 
	 *         onFireDefined?='!'? 
	 *         (
	 *             (
	 *                 (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                 onFire?='is_on_fire' | 
	 *                 sprintingDefined?='!' | 
	 *                 (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                 sprinting?='is_sprinting' | 
	 *                 swimmingDefined?='!' | 
	 *                 (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                 swimming?='is_swimming' | 
	 *                 babyDefined?='!' | 
	 *                 (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                 baby?='is_baby'
	 *             )? 
	 *             onFireDefined?='!'?
	 *         )*
	 *     )
	 */
	protected void sequence_EntityFlags_2(ISerializationContext context, EntityFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityFlags_3 returns EntityFlags
	 *
	 * Constraint:
	 *     (
	 *         (sprintingDefined?='!' | (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | sprinting?='is_sprinting') 
	 *         onFireDefined?='!'? 
	 *         (
	 *             (
	 *                 (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                 onFire?='is_on_fire' | 
	 *                 sneakingDefined?='!' | 
	 *                 (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                 sneaking?='is_sneaking' | 
	 *                 swimmingDefined?='!' | 
	 *                 (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                 swimming?='is_swimming' | 
	 *                 babyDefined?='!' | 
	 *                 (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                 baby?='is_baby'
	 *             )? 
	 *             onFireDefined?='!'?
	 *         )*
	 *     )
	 */
	protected void sequence_EntityFlags_3(ISerializationContext context, EntityFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityFlags_4 returns EntityFlags
	 *
	 * Constraint:
	 *     (
	 *         (swimmingDefined?='!' | (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | swimming?='is_swimming') 
	 *         onFireDefined?='!'? 
	 *         (
	 *             (
	 *                 (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                 onFire?='is_on_fire' | 
	 *                 sneakingDefined?='!' | 
	 *                 (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                 sneaking?='is_sneaking' | 
	 *                 sprintingDefined?='!' | 
	 *                 (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                 sprinting?='is_sprinting' | 
	 *                 babyDefined?='!' | 
	 *                 (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | 
	 *                 baby?='is_baby'
	 *             )? 
	 *             onFireDefined?='!'?
	 *         )*
	 *     )
	 */
	protected void sequence_EntityFlags_4(ISerializationContext context, EntityFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityFlags_5 returns EntityFlags
	 *
	 * Constraint:
	 *     (
	 *         (babyDefined?='!' | (babyDefined?='is_baby' (baby?='false' | baby?='true')?) | baby?='is_baby') 
	 *         onFireDefined?='!'? 
	 *         (
	 *             (
	 *                 (onFireDefined?='is_on_fire' (onFire?='false' | onFire?='true')?) | 
	 *                 onFire?='is_on_fire' | 
	 *                 sneakingDefined?='!' | 
	 *                 (sneakingDefined?='is_sneaking' (sneaking?='false' | sneaking?='true')?) | 
	 *                 sneaking?='is_sneaking' | 
	 *                 sprintingDefined?='!' | 
	 *                 (sprintingDefined?='is_sprinting' (sprinting?='false' | sprinting?='true')?) | 
	 *                 sprinting?='is_sprinting' | 
	 *                 swimmingDefined?='!' | 
	 *                 (swimmingDefined?='is_swimming' (swimming?='false' | swimming?='true')?) | 
	 *                 swimming?='is_swimming'
	 *             )? 
	 *             onFireDefined?='!'?
	 *         )*
	 *     )
	 */
	protected void sequence_EntityFlags_5(ISerializationContext context, EntityFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityPredicate returns EntityPredicate
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             absoluteDistance=DoubleRange | 
	 *             horizontalDistance=DoubleRange | 
	 *             xDistance=DoubleRange | 
	 *             yDistance=DoubleRange | 
	 *             zDistance=DoubleRange | 
	 *             equipment+=EquipmentPredicate | 
	 *             defaultEquipment=ItemPredicate | 
	 *             flags=EntityFlags | 
	 *             nbt=STRING | 
	 *             player=PlayerPredicate | 
	 *             team=Identifier | 
	 *             team=STRING | 
	 *             type=EntityID | 
	 *             location=LocationPredicate | 
	 *             fishingHook=FishingHookPredicate
	 *         )? 
	 *         (effectsDefined?='effects' effects+=EffectPredicate*)?
	 *     )+
	 */
	protected void sequence_EntityPredicate(ISerializationContext context, EntityPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns EntityPropertiesLootCondition
	 *     LootCondition1 returns EntityPropertiesLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns EntityPropertiesLootCondition
	 *     LootCondition2 returns EntityPropertiesLootCondition
	 *     LootCondition3 returns EntityPropertiesLootCondition
	 *     NamedLootCondition returns EntityPropertiesLootCondition
	 *     LootCondition4 returns EntityPropertiesLootCondition
	 *     NamedLootCondition2 returns EntityPropertiesLootCondition
	 *     EntityPropertiesLootCondition returns EntityPropertiesLootCondition
	 *
	 * Constraint:
	 *     (id='entity' entity=EnumEntitySource predicate=EntityPredicate)
	 */
	protected void sequence_EntityPropertiesLootCondition(ISerializationContext context, EntityPropertiesLootCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.ENTITY_PROPERTIES_LOOT_CONDITION__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.ENTITY_PROPERTIES_LOOT_CONDITION__ENTITY));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.ENTITY_PROPERTIES_LOOT_CONDITION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.ENTITY_PROPERTIES_LOOT_CONDITION__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityPropertiesLootConditionAccess().getIdEntityKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getEntityPropertiesLootConditionAccess().getEntityEnumEntitySourceEnumRuleCall_2_0(), semanticObject.getEntity());
		feeder.accept(grammarAccess.getEntityPropertiesLootConditionAccess().getPredicateEntityPredicateParserRuleCall_4_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityScore returns EntityScore
	 *
	 * Constraint:
	 *     ((objective=Key | objective=STRING) score=LongRange)
	 */
	protected void sequence_EntityScore(ISerializationContext context, EntityScore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns EntityScoresLootCondition
	 *     LootCondition1 returns EntityScoresLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns EntityScoresLootCondition
	 *     LootCondition2 returns EntityScoresLootCondition
	 *     LootCondition3 returns EntityScoresLootCondition
	 *     NamedLootCondition returns EntityScoresLootCondition
	 *     LootCondition4 returns EntityScoresLootCondition
	 *     NamedLootCondition2 returns EntityScoresLootCondition
	 *     EntityScoresLootCondition returns EntityScoresLootCondition
	 *
	 * Constraint:
	 *     (id='entity_scores' entity=EnumEntitySource scores+=EntityScore*)
	 */
	protected void sequence_EntityScoresLootCondition(ISerializationContext context, EntityScoresLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EquipmentPredicate returns EquipmentPredicate
	 *
	 * Constraint:
	 *     (slots+=EnumEquipmentSlot slots+=EnumEquipmentSlot* (predicate=ItemPredicate1 | predicate=ItemPredicate2))
	 */
	protected void sequence_EquipmentPredicate(ISerializationContext context, EquipmentPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Count returns ExactCount
	 *     ExactCount returns ExactCount
	 *
	 * Constraint:
	 *     amount=ULONG
	 */
	protected void sequence_ExactCount(ISerializationContext context, ExactCount semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.EXACT_COUNT__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.EXACT_COUNT__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactCountAccess().getAmountULONGTerminalRuleCall_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DoubleRange returns ExactDoubleRange
	 *     ExactDoubleRange returns ExactDoubleRange
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_ExactDoubleRange(ISerializationContext context, ExactDoubleRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactDoubleRangeAccess().getValueNUMBERParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LongRange returns ExactLongRange
	 *     ExactLongRange returns ExactLongRange
	 *
	 * Constraint:
	 *     value=LONG
	 */
	protected void sequence_ExactLongRange(ISerializationContext context, ExactLongRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.EXACT_LONG_RANGE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.EXACT_LONG_RANGE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactLongRangeAccess().getValueLONGParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PercentageRange returns ExactDoubleRange
	 *     ExactPercentageRange returns ExactDoubleRange
	 *
	 * Constraint:
	 *     value=PERCENTAGE
	 */
	protected void sequence_ExactPercentageRange(ISerializationContext context, ExactDoubleRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactPercentageRangeAccess().getValuePERCENTAGETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ULongRange returns ExactLongRange
	 *     ExactULongRange returns ExactLongRange
	 *
	 * Constraint:
	 *     value=ULONG
	 */
	protected void sequence_ExactULongRange(ISerializationContext context, ExactLongRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.EXACT_LONG_RANGE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.EXACT_LONG_RANGE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactULongRangeAccess().getValueULONGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns ExplorationMapLootFunction
	 *     LootFunction0 returns ExplorationMapLootFunction
	 *     ExplorationMapLootFunction returns ExplorationMapLootFunction
	 *
	 * Constraint:
	 *     (
	 *         id='exploration_map' 
	 *         (
	 *             (
	 *                 destination=Feature 
	 *                 (
	 *                     decoration=Identifier? 
	 *                     (searchRadiusDefined?='search_radius' searchRadius=ULONG)? 
	 *                     (skipExistingChunksDefined?='skip_existing_chunks' skipExistingChunks=BOOLEAN)? 
	 *                     (zoomDefined?='zoom' zoom=ULONG)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 decoration=Identifier 
	 *                 (
	 *                     destination=Feature? 
	 *                     (zoomDefined?='zoom' zoom=ULONG)? 
	 *                     (skipExistingChunksDefined?='skip_existing_chunks' skipExistingChunks=BOOLEAN)? 
	 *                     (searchRadiusDefined?='search_radius' searchRadius=ULONG)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 zoomDefined?='zoom' 
	 *                 zoom=ULONG 
	 *                 (
	 *                     (destination=Feature | decoration=Identifier)? 
	 *                     (skipExistingChunksDefined?='skip_existing_chunks' skipExistingChunks=BOOLEAN)? 
	 *                     (searchRadiusDefined?='search_radius' searchRadius=ULONG)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 searchRadiusDefined?='search_radius' 
	 *                 searchRadius=ULONG 
	 *                 (
	 *                     (destination=Feature | decoration=Identifier)? 
	 *                     (zoomDefined?='zoom' zoom=ULONG)? 
	 *                     (skipExistingChunksDefined?='skip_existing_chunks' skipExistingChunks=BOOLEAN)?
	 *                 )+
	 *             ) | 
	 *             (
	 *                 skipExistingChunksDefined?='skip_existing_chunks' 
	 *                 skipExistingChunks=BOOLEAN 
	 *                 ((destination=Feature | decoration=Identifier)? (zoomDefined?='zoom' zoom=ULONG)? (searchRadiusDefined?='search_radius' searchRadius=ULONG)?)+
	 *             ) | 
	 *             (
	 *                 destination=Feature 
	 *                 (
	 *                     (
	 *                         decoration=Identifier? 
	 *                         (zoomDefined?='zoom' zoom=ULONG)? 
	 *                         (skipExistingChunksDefined?='skip_existing_chunks' skipExistingChunks=BOOLEAN)? 
	 *                         (searchRadiusDefined?='search_radius' searchRadius=ULONG)?
	 *                     )+ | 
	 *                     (
	 *                         decoration=Identifier 
	 *                         (
	 *                             (zoomDefined?='zoom' zoom=ULONG) | 
	 *                             (searchRadiusDefined?='search_radius' searchRadius=ULONG) | 
	 *                             (skipExistingChunksDefined?='skip_existing_chunks' skipExistingChunks=BOOLEAN)
	 *                         )*
	 *                     )
	 *                 )
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_ExplorationMapLootFunction(ISerializationContext context, ExplorationMapLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns ExplosionDecayLootFunction
	 *     LootFunction0 returns ExplosionDecayLootFunction
	 *     ExplosionDecayLootFunction returns ExplosionDecayLootFunction
	 *
	 * Constraint:
	 *     id='explosion_decay'
	 */
	protected void sequence_ExplosionDecayLootFunction(ISerializationContext context, ExplosionDecayLootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExplosionDecayLootFunctionAccess().getIdExplosion_decayKeyword_0_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns FillPlayerHeadLootFunction
	 *     LootFunction0 returns FillPlayerHeadLootFunction
	 *     FillPlayerHeadLootFunction returns FillPlayerHeadLootFunction
	 *
	 * Constraint:
	 *     (id='fill_player_head' entity=EnumEntitySource)
	 */
	protected void sequence_FillPlayerHeadLootFunction(ISerializationContext context, FillPlayerHeadLootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.FILL_PLAYER_HEAD_LOOT_FUNCTION__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.FILL_PLAYER_HEAD_LOOT_FUNCTION__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFillPlayerHeadLootFunctionAccess().getIdFill_player_headKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getFillPlayerHeadLootFunctionAccess().getEntityEnumEntitySourceEnumRuleCall_2_0(), semanticObject.getEntity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FishingHookPredicate returns FishingHookPredicate
	 *
	 * Constraint:
	 *     (inOpenWaterDefined?='in_open_water' inOpenWater=BOOLEAN)?
	 */
	protected void sequence_FishingHookPredicate(ISerializationContext context, FishingHookPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FluidPredicate returns FluidPredicate
	 *
	 * Constraint:
	 *     ((tag=NamespacedLocation | fluid=NamespacedID)? (stateDefined?='state' properties+=BlockStatePropertyPredicate*)?)
	 */
	protected void sequence_FluidName_FluidValues(ISerializationContext context, FluidPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     FluidPredicate1 returns FluidPredicate
	//
	// Constraint:
	//     ((tag=NamespacedLocation | fluid=NamespacedID) (stateDefined?='state' properties+=BlockStatePropertyPredicate*)?)
	//
	// protected void sequence_FluidName_FluidValues(ISerializationContext context, FluidPredicate semanticObject) { }
	
	/**
	 * Contexts:
	 *     FluidPredicate2 returns FluidPredicate
	 *
	 * Constraint:
	 *     (stateDefined?='state' properties+=BlockStatePropertyPredicate*)?
	 */
	protected void sequence_FluidValues(ISerializationContext context, FluidPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns FurnaceSmeltLootFunction
	 *     LootFunction0 returns FurnaceSmeltLootFunction
	 *     FurnaceSmeltLootFunction returns FurnaceSmeltLootFunction
	 *
	 * Constraint:
	 *     id='furnace_smelt'
	 */
	protected void sequence_FurnaceSmeltLootFunction(ISerializationContext context, FurnaceSmeltLootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFurnaceSmeltLootFunctionAccess().getIdFurnace_smeltKeyword_0_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ItemPredicate returns ItemPredicate
	 *
	 * Constraint:
	 *     (
	 *         (tag=NamespacedLocation | item=ItemID)? 
	 *         (
	 *             (countDefined?='count' count=ULongRange) | 
	 *             (durabilityDefined?='durability' durability=ULongRange) | 
	 *             (enchantmentsDefined?='enchantments' enchantments+=EnchantmentLevel*) | 
	 *             (storedEnchantmentsDefined?='stored_enchantments' storedEnchantments+=EnchantmentLevel*) | 
	 *             (nbtDefined?='nbt' nbt=STRING) | 
	 *             (potionDefined?='potion' potion=PotionID)
	 *         )*
	 *     )
	 */
	protected void sequence_ItemName_ItemValues(ISerializationContext context, ItemPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ItemPredicate1 returns ItemPredicate
	//
	// Constraint:
	//     (
	//         (tag=NamespacedLocation | item=ItemID) 
	//         (
	//             (countDefined?='count' count=ULongRange) | 
	//             (durabilityDefined?='durability' durability=ULongRange) | 
	//             (enchantmentsDefined?='enchantments' enchantments+=EnchantmentLevel*) | 
	//             (storedEnchantmentsDefined?='stored_enchantments' storedEnchantments+=EnchantmentLevel*) | 
	//             (nbtDefined?='nbt' nbt=STRING) | 
	//             (potionDefined?='potion' potion=PotionID)
	//         )*
	//     )
	//
	// protected void sequence_ItemName_ItemValues(ISerializationContext context, ItemPredicate semanticObject) { }
	
	/**
	 * Contexts:
	 *     ItemPredicate2 returns ItemPredicate
	 *
	 * Constraint:
	 *     (
	 *         (countDefined?='count' count=ULongRange) | 
	 *         (durabilityDefined?='durability' durability=ULongRange) | 
	 *         (enchantmentsDefined?='enchantments' enchantments+=EnchantmentLevel*) | 
	 *         (storedEnchantmentsDefined?='stored_enchantments' storedEnchantments+=EnchantmentLevel*) | 
	 *         (nbtDefined?='nbt' nbt=STRING) | 
	 *         (potionDefined?='potion' potion=PotionID)
	 *     )*
	 */
	protected void sequence_ItemValues(ISerializationContext context, ItemPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns KilledByPlayerLootCondition
	 *     LootCondition1 returns KilledByPlayerLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns KilledByPlayerLootCondition
	 *     LootCondition2 returns KilledByPlayerLootCondition
	 *     LootCondition3 returns KilledByPlayerLootCondition
	 *     NamedLootCondition returns KilledByPlayerLootCondition
	 *     LootCondition4 returns KilledByPlayerLootCondition
	 *     NamedLootCondition2 returns KilledByPlayerLootCondition
	 *     KilledByPlayerLootCondition returns KilledByPlayerLootCondition
	 *
	 * Constraint:
	 *     id='killed_by_player'
	 */
	protected void sequence_KilledByPlayerLootCondition(ISerializationContext context, KilledByPlayerLootCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKilledByPlayerLootConditionAccess().getIdKilled_by_playerKeyword_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns LimitCountLootFunction
	 *     LootFunction0 returns LimitCountLootFunction
	 *     LimitCountLootFunction returns LimitCountLootFunction
	 *
	 * Constraint:
	 *     (id='limit' limit=ULongRange)
	 */
	protected void sequence_LimitCountLootFunction(ISerializationContext context, LimitCountLootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LIMIT_COUNT_LOOT_FUNCTION__LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LIMIT_COUNT_LOOT_FUNCTION__LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLimitCountLootFunctionAccess().getIdLimitKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getLimitCountLootFunctionAccess().getLimitULongRangeParserRuleCall_2_0(), semanticObject.getLimit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns LocationCheckLootCondition
	 *     LootCondition1 returns LocationCheckLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns LocationCheckLootCondition
	 *     LootCondition2 returns LocationCheckLootCondition
	 *     LootCondition3 returns LocationCheckLootCondition
	 *     NamedLootCondition returns LocationCheckLootCondition
	 *     LootCondition4 returns LocationCheckLootCondition
	 *     NamedLootCondition2 returns LocationCheckLootCondition
	 *     LocationCheckLootCondition returns LocationCheckLootCondition
	 *
	 * Constraint:
	 *     (
	 *         id='location' 
	 *         ((undefinedOffsetX?='~' | offsetX=LONG) (undefinedOffsetY?='~' | offsetY=LONG) (undefinedOffsetZ?='~' | offsetZ=LONG))? 
	 *         predicate=LocationPredicate
	 *     )
	 */
	protected void sequence_LocationCheckLootCondition(ISerializationContext context, LocationCheckLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationPredicate returns LocationPredicate
	 *
	 * Constraint:
	 *     (
	 *         biome=BiomeID | 
	 *         block=BlockPredicate2 | 
	 *         block=BlockPredicate1 | 
	 *         dimension=DimensionID | 
	 *         feature=Feature | 
	 *         fluid=FluidPredicate2 | 
	 *         fluid=FluidPredicate1 | 
	 *         light=ULongRange | 
	 *         xPos=DoubleRange | 
	 *         yPos=DoubleRange | 
	 *         zPos=DoubleRange
	 *     )*
	 */
	protected void sequence_LocationPredicate(ISerializationContext context, LocationPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns AlternativeLootCondition
	 *     LootCondition1 returns AlternativeLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns AlternativeLootCondition
	 *     LootCondition2 returns AlternativeLootCondition
	 *     LootCondition3 returns AlternativeLootCondition
	 *     LootCondition4 returns AlternativeLootCondition
	 *
	 * Constraint:
	 *     (alternatives+=LootCondition1_AlternativeLootCondition_1_0_0 alternatives+=LootCondition2+)
	 */
	protected void sequence_LootCondition1(ISerializationContext context, AlternativeLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns InvertedLootCondition
	 *     LootCondition1 returns InvertedLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns InvertedLootCondition
	 *     LootCondition2 returns InvertedLootCondition
	 *     LootCondition3 returns InvertedLootCondition
	 *     LootCondition4 returns InvertedLootCondition
	 *
	 * Constraint:
	 *     (term=LootCondition4 | term=LootCondition3)
	 */
	protected void sequence_LootCondition2(ISerializationContext context, InvertedLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootEntry returns LootEntry
	 *
	 * Constraint:
	 *     (
	 *         (conditionsDefined?='if' conditions+=LootCondition conditions+=LootCondition*)? 
	 *         (
	 *             (
	 *                 (
	 *                     (
	 *                         (
	 *                             (type='tag' name=NamespacedLocation) | 
	 *                             (type='item' name=NamespacedID) | 
	 *                             (type='loot_table' name=NamespacedLocation) | 
	 *                             (type='dynamic' (name='contents' | name='self'))
	 *                         ) 
	 *                         (weightDefined?='*' weight=ULONG)?
	 *                     ) | 
	 *                     ((type='group' | type='alternatives' | type='sequence') name=Identifier? (weightDefined?='*' weight=ULONG)?)
	 *                 ) 
	 *                 (entryName=Identifier | entryName=STRING)? 
	 *                 (
	 *                     ((qualityDefined?='quality' quality=LONG) | (expandDefined?='expand' expand=BOOLEAN) | (functionsDefined?='functions' functions+=LootFunction*))+ | 
	 *                     ((qualityDefined?='quality' quality=LONG) | (functionsDefined?='functions' functions+=LootFunction*))+
	 *                 )?
	 *             ) | 
	 *             (
	 *                 (
	 *                     (type='tag' name=NamespacedLocation) | 
	 *                     (type='item' name=NamespacedID) | 
	 *                     (type='loot_table' name=NamespacedLocation) | 
	 *                     (type='dynamic' (name='contents' | name='self'))
	 *                 ) 
	 *                 (weightDefined?='*' weight=ULONG)? 
	 *                 (
	 *                     (childrenDefined?='children' children+=LootEntry*) | 
	 *                     (qualityDefined?='quality' quality=LONG) | 
	 *                     (functionsDefined?='functions' functions+=LootFunction*)
	 *                 )+
	 *             ) | 
	 *             ((type='group' | type='alternatives' | type='sequence') name=Identifier?) | 
	 *             (
	 *                 (type='group' | type='alternatives' | type='sequence') 
	 *                 name=Identifier? 
	 *                 (weightDefined?='*' weight=ULONG)? 
	 *                 (
	 *                     (childrenDefined?='children' children+=LootEntry*) | 
	 *                     (qualityDefined?='quality' quality=LONG) | 
	 *                     (functionsDefined?='functions' functions+=LootFunction*)
	 *                 )+
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_LootEntry_LootEntryRest_LootEntryWeight(ISerializationContext context, LootEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns LootFunctionWithConditions
	 *
	 * Constraint:
	 *     (conditionsDefined?='if' conditions+=LootCondition conditions+=LootCondition* function=LootFunction0)
	 */
	protected void sequence_LootFunction(ISerializationContext context, LootFunctionWithConditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootPool returns LootPool
	 *
	 * Constraint:
	 *     (
	 *         (conditionsDefined?='if' conditions+=LootCondition conditions+=LootCondition*)? 
	 *         name=Identifier 
	 *         (
	 *             (rollsDefined?='rolls' rolls=ULongRange) | 
	 *             (entriesDefined?='entries' entries+=LootEntry*) | 
	 *             (bonusRollsDefined?='bonus_rolls' bonusRolls=DoubleRange) | 
	 *             (functionsDefined?='functions' functions+=LootFunction*)
	 *         )*
	 *     )
	 */
	protected void sequence_LootPool(ISerializationContext context, LootPool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootTable returns LootTable
	 *
	 * Constraint:
	 *     ((typeDefined?='type' type=EnumLootTableType)? (poolsDefined?='pools' pools+=LootPool*)?)
	 */
	protected void sequence_LootTable(ISerializationContext context, LootTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns LootingEnchantLootFunction
	 *     LootFunction0 returns LootingEnchantLootFunction
	 *     LootingEnchantLootFunction returns LootingEnchantLootFunction
	 *
	 * Constraint:
	 *     (id='looting_enchant' ((limitDefined?='limit' limit=ULONG count=ULongRange) | (count=ULongRange (limitDefined?='limit' limit=ULONG)?)))
	 */
	protected void sequence_LootingEnchantLootFunction(ISerializationContext context, LootingEnchantLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonArray
	 *     MCJsonValue returns MCJsonArray
	 *     MCJsonArray returns MCJsonArray
	 *
	 * Constraint:
	 *     (elements+=MCJsonValue elements+=MCJsonValue*)?
	 */
	protected void sequence_MCJsonArray(ISerializationContext context, MCJsonArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonBoolean
	 *     MCJsonValue returns MCJsonBoolean
	 *     MCJsonBoolean returns MCJsonBoolean
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_MCJsonBoolean(ISerializationContext context, MCJsonBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonEntry returns MCJsonEntry
	 *
	 * Constraint:
	 *     (name=STRING value=MCJsonValue)
	 */
	protected void sequence_MCJsonEntry(ISerializationContext context, MCJsonEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.MC_JSON_ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.MC_JSON_ENTRY__NAME));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.MC_JSON_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.MC_JSON_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonEntryAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMCJsonEntryAccess().getValueMCJsonValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonFloatingPoint
	 *     MCJsonValue returns MCJsonFloatingPoint
	 *     MCJsonNumber returns MCJsonFloatingPoint
	 *     MCJsonFloatingPoint returns MCJsonFloatingPoint
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_MCJsonFloatingPoint(ISerializationContext context, MCJsonFloatingPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.MC_JSON_FLOATING_POINT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.MC_JSON_FLOATING_POINT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonFloatingPointAccess().getValueDOUBLETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonIntegral
	 *     MCJsonValue returns MCJsonIntegral
	 *     MCJsonNumber returns MCJsonIntegral
	 *     MCJsonIntegral returns MCJsonIntegral
	 *
	 * Constraint:
	 *     value=LONG
	 */
	protected void sequence_MCJsonIntegral(ISerializationContext context, MCJsonIntegral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.MC_JSON_INTEGRAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.MC_JSON_INTEGRAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonIntegralAccess().getValueLONGParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonNull
	 *     MCJsonValue returns MCJsonNull
	 *     MCJsonNull returns MCJsonNull
	 *
	 * Constraint:
	 *     {MCJsonNull}
	 */
	protected void sequence_MCJsonNull(ISerializationContext context, MCJsonNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonObject
	 *     MCJsonValue returns MCJsonObject
	 *     MCJsonObject returns MCJsonObject
	 *
	 * Constraint:
	 *     (entries+=MCJsonEntry entries+=MCJsonEntry*)?
	 */
	protected void sequence_MCJsonObject(ISerializationContext context, MCJsonObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextComponent returns MCJsonString
	 *     MCJsonValue returns MCJsonString
	 *     MCJsonString returns MCJsonString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_MCJsonString(ISerializationContext context, MCJsonString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.MC_JSON_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.MC_JSON_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedLootCondition2 returns MatchToolLootCondition
	 *     MatchToolLootCondition1 returns MatchToolLootCondition
	 *
	 * Constraint:
	 *     (id='tool' predicate=ItemPredicate2)
	 */
	protected void sequence_MatchToolLootCondition1(ISerializationContext context, MatchToolLootCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.MATCH_TOOL_LOOT_CONDITION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.MATCH_TOOL_LOOT_CONDITION__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatchToolLootCondition1Access().getIdToolKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getMatchToolLootCondition1Access().getPredicateItemPredicate2ParserRuleCall_1_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns MatchToolLootCondition
	 *     LootCondition1 returns MatchToolLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns MatchToolLootCondition
	 *     LootCondition2 returns MatchToolLootCondition
	 *     LootCondition3 returns MatchToolLootCondition
	 *     NamedLootCondition returns MatchToolLootCondition
	 *     MatchToolLootCondition returns MatchToolLootCondition
	 *
	 * Constraint:
	 *     (id='tool' ((inverted?='!='? predicate=ItemPredicate1) | predicate=ItemPredicate2))
	 */
	protected void sequence_MatchToolLootCondition(ISerializationContext context, MatchToolLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition4 returns MatchToolLootCondition
	 *
	 * Constraint:
	 *     ((id='tool' ((inverted?='!='? predicate=ItemPredicate1) | predicate=ItemPredicate2)) | (id='tool' predicate=ItemPredicate2))
	 */
	protected void sequence_MatchToolLootCondition_MatchToolLootCondition1(ISerializationContext context, MatchToolLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NBTOperation returns MergeNBTOperation
	 *     MergeNBTOperation returns MergeNBTOperation
	 *
	 * Constraint:
	 *     (id='merge' source=NBTPath target=NBTPath)
	 */
	protected void sequence_MergeNBTOperation(ISerializationContext context, MergeNBTOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__SOURCE));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMergeNBTOperationAccess().getIdMergeKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getMergeNBTOperationAccess().getSourceNBTPathParserRuleCall_1_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getMergeNBTOperationAccess().getTargetNBTPathParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatisticPredicate returns NamespacedStatisticPredicate
	 *     NamespacedStatisticPredicate returns NamespacedStatisticPredicate
	 *
	 * Constraint:
	 *     (type=NamespacedID stats+=UnnamespacedStatisticPredicate*)
	 */
	protected void sequence_NamespacedStatisticPredicate(ISerializationContext context, NamespacedStatisticPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DoubleRange returns NormalDoubleRange
	 *     NormalDoubleRange returns NormalDoubleRange
	 *
	 * Constraint:
	 *     (((min=NUMBER | min=NUMBER_RANGE_START) max=NUMBER?) | max=NUMBER)
	 */
	protected void sequence_NormalDoubleRange(ISerializationContext context, NormalDoubleRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LongRange returns NormalLongRange
	 *     NormalLongRange returns NormalLongRange
	 *
	 * Constraint:
	 *     (((min=LONG | min=ULONG_RANGE_START | min=SLONG_RANGE_START) max=LONG?) | max=LONG)
	 */
	protected void sequence_NormalLongRange(ISerializationContext context, NormalLongRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PercentageRange returns NormalDoubleRange
	 *     NormalPercentageRange returns NormalDoubleRange
	 *
	 * Constraint:
	 *     ((min=PERCENTAGE max=PERCENTAGE?) | max=PERCENTAGE)
	 */
	protected void sequence_NormalPercentageRange(ISerializationContext context, NormalDoubleRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ULongRange returns NormalLongRange
	 *     NormalULongRange returns NormalLongRange
	 *
	 * Constraint:
	 *     (((min=ULONG | min=ULONG_RANGE_START) max=ULONG?) | max=ULONG)
	 */
	protected void sequence_NormalULongRange(ISerializationContext context, NormalLongRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlayerPredicate returns PlayerPredicate
	 *
	 * Constraint:
	 *     (
	 *         (advancementsDefined?='advancements' advancements+=AdvancementPredicate*) | 
	 *         (gamemodeDefined?='gamemode' gamemode=EnumGamemode) | 
	 *         (recipesDefined?='recipes' recipes+=RecipePredicate*) | 
	 *         (statsDefined?='stats' stats+=StatisticPredicate*)
	 *     )*
	 */
	protected void sequence_PlayerPredicate(ISerializationContext context, PlayerPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns RandomChanceLootCondition
	 *     LootCondition1 returns RandomChanceLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns RandomChanceLootCondition
	 *     LootCondition2 returns RandomChanceLootCondition
	 *     LootCondition3 returns RandomChanceLootCondition
	 *     NamedLootCondition returns RandomChanceLootCondition
	 *     LootCondition4 returns RandomChanceLootCondition
	 *     NamedLootCondition2 returns RandomChanceLootCondition
	 *     RandomChanceLootCondition returns RandomChanceLootCondition
	 *
	 * Constraint:
	 *     (id='random_chance' chance=PERCENTAGE (lootingMultiplierDefined?='*' lootingMultiplier=NUMBER)?)
	 */
	protected void sequence_RandomChanceLootCondition(ISerializationContext context, RandomChanceLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecipePredicate returns RecipePredicate
	 *
	 * Constraint:
	 *     (recipe=NamespacedLocation didNotGet?='false'?)
	 */
	protected void sequence_RecipePredicate(ISerializationContext context, RecipePredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns ReferenceLootCondition
	 *     LootCondition1 returns ReferenceLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns ReferenceLootCondition
	 *     LootCondition2 returns ReferenceLootCondition
	 *     LootCondition3 returns ReferenceLootCondition
	 *     NamedLootCondition returns ReferenceLootCondition
	 *     LootCondition4 returns ReferenceLootCondition
	 *     NamedLootCondition2 returns ReferenceLootCondition
	 *     ReferenceLootCondition returns ReferenceLootCondition
	 *
	 * Constraint:
	 *     (id='ref' ref=NamespacedLocation)
	 */
	protected void sequence_ReferenceLootCondition(ISerializationContext context, ReferenceLootCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.REFERENCE_LOOT_CONDITION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.REFERENCE_LOOT_CONDITION__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceLootConditionAccess().getIdRefKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getReferenceLootConditionAccess().getRefNamespacedLocationParserRuleCall_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NBTOperation returns ReplaceNBTOperation
	 *     ReplaceNBTOperation returns ReplaceNBTOperation
	 *
	 * Constraint:
	 *     (id='replace' target=NBTPath source=NBTPath)
	 */
	protected void sequence_ReplaceNBTOperation(ISerializationContext context, ReplaceNBTOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__TARGET));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NBT_OPERATION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NBT_OPERATION__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReplaceNBTOperationAccess().getIdReplaceKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getReplaceNBTOperationAccess().getTargetNBTPathParserRuleCall_1_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getReplaceNBTOperationAccess().getSourceNBTPathParserRuleCall_3_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetAttributesLootFunction
	 *     LootFunction0 returns SetAttributesLootFunction
	 *     SetAttributesLootFunction returns SetAttributesLootFunction
	 *
	 * Constraint:
	 *     (id='set_attributes' modifiers+=AttributeModifier*)
	 */
	protected void sequence_SetAttributesLootFunction(ISerializationContext context, SetAttributesLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetContentsLootFunction
	 *     LootFunction0 returns SetContentsLootFunction
	 *     SetContentsLootFunction returns SetContentsLootFunction
	 *
	 * Constraint:
	 *     (id='set_contents' entries+=LootEntry*)
	 */
	protected void sequence_SetContentsLootFunction(ISerializationContext context, SetContentsLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetCountLootFunction
	 *     LootFunction0 returns SetCountLootFunction
	 *     SetCountLootFunction returns SetCountLootFunction
	 *
	 * Constraint:
	 *     (id='set_count' count=Count)
	 */
	protected void sequence_SetCountLootFunction(ISerializationContext context, SetCountLootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.SET_COUNT_LOOT_FUNCTION__COUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.SET_COUNT_LOOT_FUNCTION__COUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetCountLootFunctionAccess().getIdSet_countKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getSetCountLootFunctionAccess().getCountCountParserRuleCall_2_0(), semanticObject.getCount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetDamageLootFunction
	 *     LootFunction0 returns SetDamageLootFunction
	 *     SetDamageLootFunction returns SetDamageLootFunction
	 *
	 * Constraint:
	 *     (id='set_damage' (damage=PercentageRange | damage=DoubleRange))
	 */
	protected void sequence_SetDamageLootFunction(ISerializationContext context, SetDamageLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetLoreLootFunction
	 *     LootFunction0 returns SetLoreLootFunction
	 *     SetLoreLootFunction returns SetLoreLootFunction
	 *
	 * Constraint:
	 *     (
	 *         id='set_lore' 
	 *         ((replaceDefined?='replace' replace=BOOLEAN entity=EnumEntitySource?) | (entity=EnumEntitySource (replaceDefined?='replace' replace=BOOLEAN)?))? 
	 *         (lore+=TextComponent lore+=TextComponent*)?
	 *     )
	 */
	protected void sequence_SetLoreLootFunction(ISerializationContext context, SetLoreLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetNBTLootFunction
	 *     LootFunction0 returns SetNBTLootFunction
	 *     SetNBTLootFunction returns SetNBTLootFunction
	 *
	 * Constraint:
	 *     (id='set_nbt' tag=STRING)
	 */
	protected void sequence_SetNBTLootFunction(ISerializationContext context, SetNBTLootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.SET_NBT_LOOT_FUNCTION__TAG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.SET_NBT_LOOT_FUNCTION__TAG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetNBTLootFunctionAccess().getIdSet_nbtKeyword_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getSetNBTLootFunctionAccess().getTagSTRINGTerminalRuleCall_2_0(), semanticObject.getTag());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetNameLootFunction
	 *     LootFunction0 returns SetNameLootFunction
	 *     SetNameLootFunction returns SetNameLootFunction
	 *
	 * Constraint:
	 *     (id='set_name' ((entity=EnumEntitySource itemName=TextComponent) | (itemName=TextComponent entity=EnumEntitySource?)))
	 */
	protected void sequence_SetNameLootFunction(ISerializationContext context, SetNameLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootFunction returns SetStewEffectLootFunction
	 *     LootFunction0 returns SetStewEffectLootFunction
	 *     SetStewEffectLootFunction returns SetStewEffectLootFunction
	 *
	 * Constraint:
	 *     (id='set_stew_effect' (effects+=StewEffect effects+=StewEffect*)?)
	 */
	protected void sequence_SetStewEffectLootFunction(ISerializationContext context, SetStewEffectLootFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatisticPredicate returns SingleStatisticPredicate
	 *     SingleStatisticPredicate returns SingleStatisticPredicate
	 *
	 * Constraint:
	 *     (type=NamespacedID stat=NamespacedID value=LongRange)
	 */
	protected void sequence_SingleStatisticPredicate(ISerializationContext context, SingleStatisticPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.STATISTIC_PREDICATE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.STATISTIC_PREDICATE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.SINGLE_STATISTIC_PREDICATE__STAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.SINGLE_STATISTIC_PREDICATE__STAT));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.SINGLE_STATISTIC_PREDICATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.SINGLE_STATISTIC_PREDICATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleStatisticPredicateAccess().getTypeNamespacedIDParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getSingleStatisticPredicateAccess().getStatNamespacedIDParserRuleCall_1_0(), semanticObject.getStat());
		feeder.accept(grammarAccess.getSingleStatisticPredicateAccess().getValueLongRangeParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StewEffect returns StewEffect
	 *
	 * Constraint:
	 *     (type=EffectID duration=ULONG)
	 */
	protected void sequence_StewEffect(ISerializationContext context, StewEffect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.STEW_EFFECT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.STEW_EFFECT__TYPE));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.STEW_EFFECT__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.STEW_EFFECT__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStewEffectAccess().getTypeEffectIDParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getStewEffectAccess().getDurationULONGTerminalRuleCall_2_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns SurvivesExplosionLootCondition
	 *     LootCondition1 returns SurvivesExplosionLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns SurvivesExplosionLootCondition
	 *     LootCondition2 returns SurvivesExplosionLootCondition
	 *     LootCondition3 returns SurvivesExplosionLootCondition
	 *     NamedLootCondition returns SurvivesExplosionLootCondition
	 *     LootCondition4 returns SurvivesExplosionLootCondition
	 *     NamedLootCondition2 returns SurvivesExplosionLootCondition
	 *     SurvivesExplosionLootCondition returns SurvivesExplosionLootCondition
	 *
	 * Constraint:
	 *     id='survives_explosion'
	 */
	protected void sequence_SurvivesExplosionLootCondition(ISerializationContext context, SurvivesExplosionLootCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.NAMED_LOOT_CONDITION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSurvivesExplosionLootConditionAccess().getIdSurvives_explosionKeyword_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns TableBonusLootCondition
	 *     LootCondition1 returns TableBonusLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns TableBonusLootCondition
	 *     LootCondition2 returns TableBonusLootCondition
	 *     LootCondition3 returns TableBonusLootCondition
	 *     NamedLootCondition returns TableBonusLootCondition
	 *     LootCondition4 returns TableBonusLootCondition
	 *     NamedLootCondition2 returns TableBonusLootCondition
	 *     TableBonusLootCondition returns TableBonusLootCondition
	 *
	 * Constraint:
	 *     (id='table_bonus' enchantment=EnchantmentID chances+=PERCENTAGE+)
	 */
	protected void sequence_TableBonusLootCondition(ISerializationContext context, TableBonusLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns TimeCheckLootCondition
	 *     LootCondition1 returns TimeCheckLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns TimeCheckLootCondition
	 *     LootCondition2 returns TimeCheckLootCondition
	 *     LootCondition3 returns TimeCheckLootCondition
	 *     NamedLootCondition returns TimeCheckLootCondition
	 *     LootCondition4 returns TimeCheckLootCondition
	 *     TimeCheckLootCondition returns TimeCheckLootCondition
	 *
	 * Constraint:
	 *     (id='time' (periodDefined?='%' period=ULONG?)? inverted?='!='? value=ULongRange)
	 */
	protected void sequence_TimeCheckLootCondition(ISerializationContext context, TimeCheckLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns ToolEnchantmentLootCondition
	 *     LootCondition1 returns ToolEnchantmentLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns ToolEnchantmentLootCondition
	 *     LootCondition2 returns ToolEnchantmentLootCondition
	 *     LootCondition3 returns ToolEnchantmentLootCondition
	 *     NamedLootCondition returns ToolEnchantmentLootCondition
	 *     LootCondition4 returns ToolEnchantmentLootCondition
	 *     NamedLootCondition2 returns ToolEnchantmentLootCondition
	 *     ToolEnchantmentLootCondition returns ToolEnchantmentLootCondition
	 *
	 * Constraint:
	 *     (id='enchantments' enchantments+=EnchantmentLevel*)
	 */
	protected void sequence_ToolEnchantmentLootCondition(ISerializationContext context, ToolEnchantmentLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Count returns UniformCount
	 *     SpecialCount returns UniformCount
	 *     UniformCount returns UniformCount
	 *
	 * Constraint:
	 *     (
	 *         (min=LONG max=ULONG) | 
	 *         (max=ULONG min=LONG) | 
	 *         ((min=LONG | min=ULONG_RANGE_START | min=SLONG_RANGE_START) max=ULONG) | 
	 *         (min=LONG max=ULONG) | 
	 *         (max=LONG min=ULONG) | 
	 *         ((min=ULONG | min=ULONG_RANGE_START | min=SLONG_RANGE_START) max=ULONG)
	 *     )
	 */
	protected void sequence_UniformCount(ISerializationContext context, UniformCount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnnamespacedStatisticPredicate returns UnnamespacedStatisticPredicate
	 *
	 * Constraint:
	 *     (stat=NamespacedID value=LongRange)
	 */
	protected void sequence_UnnamespacedStatisticPredicate(ISerializationContext context, UnnamespacedStatisticPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.UNNAMESPACED_STATISTIC_PREDICATE__STAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.UNNAMESPACED_STATISTIC_PREDICATE__STAT));
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.UNNAMESPACED_STATISTIC_PREDICATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.UNNAMESPACED_STATISTIC_PREDICATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnnamespacedStatisticPredicateAccess().getStatNamespacedIDParserRuleCall_0_0(), semanticObject.getStat());
		feeder.accept(grammarAccess.getUnnamespacedStatisticPredicateAccess().getValueLongRangeParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LootCondition returns WeatherCheckLootCondition
	 *     LootCondition1 returns WeatherCheckLootCondition
	 *     LootCondition1.AlternativeLootCondition_1_0_0 returns WeatherCheckLootCondition
	 *     LootCondition2 returns WeatherCheckLootCondition
	 *     LootCondition3 returns WeatherCheckLootCondition
	 *     NamedLootCondition returns WeatherCheckLootCondition
	 *     LootCondition4 returns WeatherCheckLootCondition
	 *     WeatherCheckLootCondition returns WeatherCheckLootCondition
	 *
	 * Constraint:
	 *     (id='weather' inverted?='!='? ((raining?='raining' thundering?='thundering'?) | (thundering?='thundering' raining?='raining'?)))
	 */
	protected void sequence_WeatherCheckLootCondition(ISerializationContext context, WeatherCheckLootCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XXX1 returns LootFunction
	 *
	 * Constraint:
	 *     id='false'
	 */
	protected void sequence_XXX1(ISerializationContext context, LootFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclootPackage.Literals.LOOT_FUNCTION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXXX1Access().getIdFalseKeyword_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
}
