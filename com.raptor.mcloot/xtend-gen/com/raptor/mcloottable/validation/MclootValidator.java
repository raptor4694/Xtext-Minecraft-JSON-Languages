/**
 * generated by Xtext 2.21.0
 */
package com.raptor.mcloottable.validation;

import com.google.common.base.Objects;
import com.raptor.mcloottable.mcloot.ApplyBonusLootFunction;
import com.raptor.mcloottable.mcloot.AttributeModifier;
import com.raptor.mcloottable.mcloot.BinomialCount;
import com.raptor.mcloottable.mcloot.BlockStatePropertiesLootCondition;
import com.raptor.mcloottable.mcloot.BlockStateProperty;
import com.raptor.mcloottable.mcloot.CopyStateLootFunction;
import com.raptor.mcloottable.mcloot.DoubleRange;
import com.raptor.mcloottable.mcloot.EffectPredicate;
import com.raptor.mcloottable.mcloot.EnchantRandomlyLootFunction;
import com.raptor.mcloottable.mcloot.EnchantWithLevelsLootFunction;
import com.raptor.mcloottable.mcloot.EnchantmentLevel;
import com.raptor.mcloottable.mcloot.EntityPredicate;
import com.raptor.mcloottable.mcloot.EntityScore;
import com.raptor.mcloottable.mcloot.EntityScoresLootCondition;
import com.raptor.mcloottable.mcloot.EnumBonusFormula;
import com.raptor.mcloottable.mcloot.EnumEquipmentSlot;
import com.raptor.mcloottable.mcloot.EnumLootTableType;
import com.raptor.mcloottable.mcloot.EquipmentPredicate;
import com.raptor.mcloottable.mcloot.ExactDoubleRange;
import com.raptor.mcloottable.mcloot.ExactLongRange;
import com.raptor.mcloottable.mcloot.ExplorationMapLootFunction;
import com.raptor.mcloottable.mcloot.FillPlayerHeadLootFunction;
import com.raptor.mcloottable.mcloot.LongRange;
import com.raptor.mcloottable.mcloot.LootEntry;
import com.raptor.mcloottable.mcloot.LootPool;
import com.raptor.mcloottable.mcloot.LootTable;
import com.raptor.mcloottable.mcloot.MCJsonEntry;
import com.raptor.mcloottable.mcloot.MCJsonObject;
import com.raptor.mcloottable.mcloot.MclootPackage;
import com.raptor.mcloottable.mcloot.NormalDoubleRange;
import com.raptor.mcloottable.mcloot.NormalLongRange;
import com.raptor.mcloottable.mcloot.RandomChanceLootCondition;
import com.raptor.mcloottable.mcloot.SetAttributesLootFunction;
import com.raptor.mcloottable.mcloot.SetContentsLootFunction;
import com.raptor.mcloottable.mcloot.SetDamageLootFunction;
import com.raptor.mcloottable.mcloot.SetStewEffectLootFunction;
import com.raptor.mcloottable.mcloot.StewEffect;
import com.raptor.mcloottable.mcloot.TableBonusLootCondition;
import com.raptor.mcloottable.mcloot.ToolEnchantmentLootCondition;
import com.raptor.mcloottable.mcloot.UniformCount;
import com.raptor.mcloottable.util.MclootUtils;
import com.raptor.mcloottable.util.MinecraftData;
import com.raptor.mcloottable.util.Property;
import com.raptor.mcloottable.validation.AbstractMclootValidator;
import com.raptor.mcloottable.validation.SeenInfo;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MclootValidator extends AbstractMclootValidator {
  @Check
  public void checkNoDuplicates(final MCJsonObject it) {
    int _size = it.getEntries().size();
    boolean _lessEqualsThan = (_size <= 1);
    if (_lessEqualsThan) {
      return;
    }
    final HashMap<String, SeenInfo<MCJsonEntry>> seenEntries = MclootValidator.<String, MCJsonEntry>newSeenMap(it.getEntries().size());
    EList<MCJsonEntry> _entries = it.getEntries();
    for (final MCJsonEntry entry : _entries) {
      {
        final SeenInfo<MCJsonEntry> info = seenEntries.get(entry.getName());
        if ((info == null)) {
          seenEntries.put(entry.getName(), MclootValidator.<MCJsonEntry>seen(entry));
        } else {
          if ((!info.errored)) {
            info.errored = true;
            this.error("Duplicate entry", 
              info.value, 
              MclootPackage.Literals.MC_JSON_ENTRY__NAME);
          }
          this.error("Duplicate entry", entry, 
            MclootPackage.Literals.MC_JSON_ENTRY__NAME);
        }
      }
    }
  }
  
  @Check
  public void checkLootTable(final LootTable it) {
    boolean _isPoolsDefined = it.isPoolsDefined();
    if (_isPoolsDefined) {
      if ((it.isTypeDefined() && Objects.equal(it.getType(), EnumLootTableType.EMPTY))) {
        this.error("Type \'empty\' cannot specify any pools", 
          MclootPackage.Literals.LOOT_TABLE__POOLS_DEFINED);
      } else {
        boolean _isEmpty = it.getPools().isEmpty();
        if (_isEmpty) {
          this.error("No pools given", 
            MclootPackage.Literals.LOOT_TABLE__POOLS_DEFINED);
        }
      }
    } else {
      if ((it.isTypeDefined() && (!Objects.equal(it.getType(), EnumLootTableType.EMPTY)))) {
        this.error("No pools given", 
          MclootPackage.Literals.LOOT_TABLE__TYPE_DEFINED);
      }
    }
    boolean _isEmpty_1 = it.getPools().isEmpty();
    boolean _not = (!_isEmpty_1);
    if (_not) {
      final Function1<LootPool, String> _function = (LootPool it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Duplicate loot pool \"");
        String _name = it_1.getName();
        _builder.append(_name);
        _builder.append("\"");
        return _builder.toString();
      };
      this.<LootPool>checkUnique(it.getPools(), MclootPackage.Literals.LOOT_POOL__NAME, _function);
    }
  }
  
  @Check
  public void checkLootPool(final LootPool it) {
    boolean _isEmpty = it.getEntries().isEmpty();
    if (_isEmpty) {
      EAttribute _xifexpression = null;
      boolean _isEntriesDefined = it.isEntriesDefined();
      if (_isEntriesDefined) {
        _xifexpression = MclootPackage.Literals.LOOT_POOL__ENTRIES_DEFINED;
      } else {
        _xifexpression = MclootPackage.Literals.LOOT_POOL__NAME;
      }
      this.error("No entries given", _xifexpression);
    } else {
      final Function1<LootEntry, String> _function = (LootEntry it_1) -> {
        String _elvis = null;
        String _entryName = it_1.getEntryName();
        if (_entryName != null) {
          _elvis = _entryName;
        } else {
          String _name = it_1.getName();
          _elvis = _name;
        }
        return _elvis;
      };
      final Function1<LootEntry, EStructuralFeature> _function_1 = (LootEntry it_1) -> {
        EAttribute _xifexpression_1 = null;
        String _entryName = it_1.getEntryName();
        boolean _tripleEquals = (_entryName == null);
        if (_tripleEquals) {
          _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__NAME;
        } else {
          _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__ENTRY_NAME;
        }
        return _xifexpression_1;
      };
      final Function1<LootEntry, String> _function_2 = (LootEntry it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Duplicate loot entry \"");
        String _elvis = null;
        String _entryName = it_1.getEntryName();
        if (_entryName != null) {
          _elvis = _entryName;
        } else {
          String _name = it_1.getName();
          _elvis = _name;
        }
        _builder.append(_elvis);
        _builder.append("\"");
        return _builder.toString();
      };
      this.<LootEntry, String>checkUnique(true, it.getEntries(), _function, _function_1, _function_2);
    }
    boolean _isRollsDefined = it.isRollsDefined();
    if (_isRollsDefined) {
      this.checkULongRange(it.getRolls());
    }
    if ((it.isFunctionsDefined() && it.getFunctions().isEmpty())) {
      this.warning("No functions given", 
        MclootPackage.Literals.LOOT_POOL__FUNCTIONS_DEFINED);
    }
  }
  
  @Check
  public void checkLootEntry(final LootEntry it) {
    String _type = it.getType();
    if (_type != null) {
      switch (_type) {
        case "tag":
          final Procedure1<String> _function = (String name) -> {
            boolean _isVanillaItemTag = MinecraftData.isVanillaItemTag(name);
            boolean _not = (!_isVanillaItemTag);
            if (_not) {
              this.warning("Unknown vanilla item tag", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
            String _name = it.getName();
            boolean _tripleEquals = (name == _name);
            if (_tripleEquals) {
              this.info("Namespace defaulting to \'minecraft\'", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
          };
          MclootUtils.ifMinecraftKey(it.getName(), _function);
          break;
        case "item":
          final Procedure1<String> _function_1 = (String name) -> {
            boolean _isVanillaItem = MinecraftData.isVanillaItem(name);
            boolean _not = (!_isVanillaItem);
            if (_not) {
              this.warning("Unknown vanilla item name", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
            String _name = it.getName();
            boolean _tripleEquals = (name == _name);
            if (_tripleEquals) {
              this.info("Namespace defaulting to \'minecraft\'", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
          };
          MclootUtils.ifMinecraftKey(it.getName(), _function_1);
          break;
        case "loot_table":
          final Procedure1<String> _function_2 = (String name) -> {
            boolean _isVanillaLootTable = MinecraftData.isVanillaLootTable(name);
            boolean _not = (!_isVanillaLootTable);
            if (_not) {
              this.warning("Unknown vanilla loot table", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
            String _name = it.getName();
            boolean _tripleEquals = (name == _name);
            if (_tripleEquals) {
              this.info("Namespace defaulting to \'minecraft\'", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
          };
          MclootUtils.ifMinecraftKey(it.getName(), _function_2);
          break;
        case "group":
        case "alternatives":
        case "sequence":
          boolean _isEmpty = it.getChildren().isEmpty();
          if (_isEmpty) {
            EAttribute _xifexpression = null;
            boolean _isChildrenDefined = it.isChildrenDefined();
            if (_isChildrenDefined) {
              _xifexpression = MclootPackage.Literals.LOOT_ENTRY__CHILDREN_DEFINED;
            } else {
              EAttribute _xifexpression_1 = null;
              String _entryName = it.getEntryName();
              boolean _tripleNotEquals = (_entryName != null);
              if (_tripleNotEquals) {
                _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__ENTRY_NAME;
              } else {
                _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__TYPE;
              }
              _xifexpression = _xifexpression_1;
            }
            this.error("No children given", _xifexpression);
          }
          break;
      }
    }
    if ((it.isFunctionsDefined() && it.getFunctions().isEmpty())) {
      this.warning("No functions given", 
        MclootPackage.Literals.LOOT_ENTRY__FUNCTIONS_DEFINED);
    }
    if ((it.isWeightDefined() && (it.getWeight() <= 0))) {
      this.error("Weight must be at least 1", 
        MclootPackage.Literals.LOOT_ENTRY__WEIGHT);
    }
  }
  
  @Check
  public void checkLootFunction(final ApplyBonusLootFunction it) {
    final Procedure1<String> _function = (String enchantment) -> {
      boolean _isVanillaEnchantment = MinecraftData.isVanillaEnchantment(enchantment);
      boolean _not = (!_isVanillaEnchantment);
      if (_not) {
        this.warning("Unknown vanilla enchantment", 
          MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__ENCHANTMENT);
      }
    };
    MclootUtils.ifMinecraftKey(it.getEnchantment(), _function);
    EnumBonusFormula _formula = it.getFormula();
    if (_formula != null) {
      switch (_formula) {
        case BINOMIAL_WITH_BONUS_COUNT:
          boolean _isBonusMultiplierDefined = it.isBonusMultiplierDefined();
          if (_isBonusMultiplierDefined) {
            this.error("\'bonusMultiplier\' parameter only allowed when formula is \'uniform_bonus_count\'", 
              MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__BONUS_MULTIPLIER_DEFINED);
          }
          boolean _isExtraDefined = it.isExtraDefined();
          boolean _not = (!_isExtraDefined);
          if (_not) {
            this.error("Missing \'extra\' parameter for formula \'binomial_with_bonus_count\'", 
              MclootPackage.Literals.LOOT_FUNCTION__ID);
          }
          boolean _isProbabilityDefined = it.isProbabilityDefined();
          boolean _not_1 = (!_isProbabilityDefined);
          if (_not_1) {
            this.error("Missing \'probability\' parameter for formula \'binomial_with_bonus_count\'", 
              MclootPackage.Literals.LOOT_FUNCTION__ID);
          } else {
            this.checkPercentage(it, MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__PROBABILITY);
          }
          break;
        case ORE_DROPS:
          boolean _isBonusMultiplierDefined_1 = it.isBonusMultiplierDefined();
          if (_isBonusMultiplierDefined_1) {
            this.error("\'bonusMultiplier\' parameter only allowed when formula is \'uniform_bonus_count\'", 
              MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__BONUS_MULTIPLIER_DEFINED);
          }
          boolean _isExtraDefined_1 = it.isExtraDefined();
          if (_isExtraDefined_1) {
            this.error("\'extra\' parameter only allowed when formula is \'binomial_with_bonus_count\'", 
              MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__EXTRA_DEFINED);
          }
          boolean _isProbabilityDefined_1 = it.isProbabilityDefined();
          if (_isProbabilityDefined_1) {
            this.error("\'probability\' parameter only allowed when formula is \'binomial_with_bonus_count\'", 
              MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__PROBABILITY_DEFINED);
          }
          break;
        case UNIFORM_BONUS_COUNT:
          boolean _isExtraDefined_2 = it.isExtraDefined();
          if (_isExtraDefined_2) {
            this.error("\'extra\' parameter only allowed when formula is \'binomial_with_bonus_count\'", 
              MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__EXTRA_DEFINED);
          }
          boolean _isProbabilityDefined_2 = it.isProbabilityDefined();
          if (_isProbabilityDefined_2) {
            this.error("\'probability\' parameter only allowed when formula is \'binomial_with_bonus_count\'", 
              MclootPackage.Literals.APPLY_BONUS_LOOT_FUNCTION__PROBABILITY_DEFINED);
          }
          boolean _isBonusMultiplierDefined_2 = it.isBonusMultiplierDefined();
          boolean _not_2 = (!_isBonusMultiplierDefined_2);
          if (_not_2) {
            this.error("Missing \'bonusMultiplier\' parameter for formula \'uniform_bonus_count\'", 
              MclootPackage.Literals.LOOT_FUNCTION__ID);
          }
          break;
        default:
          break;
      }
    }
  }
  
  @Check
  public void checkLootFunction(final CopyStateLootFunction it) {
    final Procedure1<String> _function = (String block) -> {
      final Map<String, ? extends Property> blockStates = MinecraftData.VANILLA_BLOCK_STATES.get(block);
      if ((blockStates == null)) {
        this.warning("Unknown vanilla block name", 
          MclootPackage.Literals.COPY_STATE_LOOT_FUNCTION__BLOCK);
        this.<Object>checkUniqueValues(it, MclootPackage.Literals.COPY_STATE_LOOT_FUNCTION__PROPERTIES, "Duplicate property");
      } else {
        boolean _isEmpty = it.getProperties().isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          final Function2<String, Integer, Object> _function_1 = (String property, Integer i) -> {
            boolean _containsKey = blockStates.containsKey(property);
            boolean _not_1 = (!_containsKey);
            if (_not_1) {
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("Block minecraft:");
              _builder.append(block);
              _builder.append(" does not have a state named ");
              _builder.append(property);
              _builder.append(".");
              this.error(_builder.toString(), 
                MclootPackage.Literals.COPY_STATE_LOOT_FUNCTION__PROPERTIES, (i).intValue());
            }
            return property;
          };
          this.<String>checkUniqueValues(it, MclootPackage.Literals.COPY_STATE_LOOT_FUNCTION__PROPERTIES, _function_1, "Duplicate property");
        }
      }
    };
    final Runnable _function_1 = () -> {
      this.<Object>checkUniqueValues(it, MclootPackage.Literals.COPY_STATE_LOOT_FUNCTION__PROPERTIES, "Duplicate property");
    };
    MclootUtils.ifMinecraftKey(it.getBlock(), _function).otherwise(_function_1);
  }
  
  @Check
  public void checkLootFunction(final EnchantRandomlyLootFunction it) {
    boolean _isEmpty = it.getEnchantments().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      final Function2<String, Integer, Object> _function = (String enchantment, Integer i) -> {
        final Procedure1<String> _function_1 = (String ench) -> {
          boolean _isVanillaEnchantment = MinecraftData.isVanillaEnchantment(ench);
          boolean _not_1 = (!_isVanillaEnchantment);
          if (_not_1) {
            this.warning("Unknown vanilla enchantment name", 
              MclootPackage.Literals.ENCHANT_RANDOMLY_LOOT_FUNCTION__ENCHANTMENTS, (i).intValue());
          }
          if ((enchantment == ench)) {
            this.info("Namespace defaulting to \'minecraft\'", 
              MclootPackage.Literals.ENCHANT_RANDOMLY_LOOT_FUNCTION__ENCHANTMENTS, (i).intValue());
          }
        };
        MclootUtils.ifMinecraftKey(enchantment, _function_1);
        return MclootUtils.addDefaultNamespace(enchantment);
      };
      this.<String>checkUniqueValues(it, MclootPackage.Literals.ENCHANT_RANDOMLY_LOOT_FUNCTION__ENCHANTMENTS, _function, "Duplicate enchantment");
    }
  }
  
  @Check
  public void checkLootFunction(final EnchantWithLevelsLootFunction it) {
    this.checkULongRange(it.getLevels());
  }
  
  @Check
  public void checkLootFunction(final ExplorationMapLootFunction it) {
    EObject _eContainer = it.eContainer();
    if ((_eContainer instanceof LootEntry)) {
      EObject _eContainer_1 = it.eContainer();
      final LootEntry entry = ((LootEntry) _eContainer_1);
      String _type = entry.getType();
      boolean _equals = Objects.equal(_type, "item");
      if (_equals) {
        if (((!Objects.equal(entry.getName(), "minecraft:map")) && (!Objects.equal(entry.getName(), "map")))) {
          this.warning("exploration_map function only works with item \'minecraft:map\'", 
            MclootPackage.Literals.LOOT_FUNCTION__ID);
        }
      }
    }
    boolean _isVanillaStructureFeature = MinecraftData.isVanillaStructureFeature(it.getDestination());
    boolean _not = (!_isVanillaStructureFeature);
    if (_not) {
      this.warning("Unknown vanilla structure feature name", 
        MclootPackage.Literals.EXPLORATION_MAP_LOOT_FUNCTION__DESTINATION);
    }
    boolean _isVanillaMapIcon = MinecraftData.isVanillaMapIcon(it.getDecoration());
    boolean _not_1 = (!_isVanillaMapIcon);
    if (_not_1) {
      this.warning("Unknown vanilla map icon name", 
        MclootPackage.Literals.EXPLORATION_MAP_LOOT_FUNCTION__DECORATION);
    }
  }
  
  @Check
  public void checkLootFunction(final FillPlayerHeadLootFunction it) {
    EObject _eContainer = it.eContainer();
    if ((_eContainer instanceof LootEntry)) {
      EObject _eContainer_1 = it.eContainer();
      final LootEntry entry = ((LootEntry) _eContainer_1);
      String _type = entry.getType();
      boolean _equals = Objects.equal(_type, "item");
      if (_equals) {
        if (((!Objects.equal(entry.getName(), "minecraft:player_head")) && (!Objects.equal(entry.getName(), "player_head")))) {
          this.warning("fill_player_head function only works with item \'minecraft:player_head\'", 
            MclootPackage.Literals.LOOT_FUNCTION__ID);
        }
      }
    }
  }
  
  @Check
  public void checkLootFunction(final SetAttributesLootFunction it) {
    this.<AttributeModifier>checkUnique(it.getModifiers(), MclootPackage.Literals.ATTRIBUTE_MODIFIER__UUID, "Duplicate UUID");
  }
  
  @Check
  public void checkAttributeModifier(final AttributeModifier it) {
    if ((it.isSlotDefined() && (!it.isSingleSlot()))) {
      boolean _isEmpty = it.getSlots().isEmpty();
      if (_isEmpty) {
        this.warning("No slots given", 
          MclootPackage.Literals.ATTRIBUTE_MODIFIER__SLOT_DEFINED);
      } else {
        this.<Object>checkUniqueValues(it, MclootPackage.Literals.ATTRIBUTE_MODIFIER__SLOTS, "Duplicate slot entry");
      }
    }
  }
  
  @Check
  public void checkLootFunction(final SetContentsLootFunction it) {
    boolean _isEmpty = it.getEntries().isEmpty();
    if (_isEmpty) {
      this.error("No entries given", 
        MclootPackage.Literals.LOOT_FUNCTION__ID);
    } else {
      final Function1<LootEntry, String> _function = (LootEntry it_1) -> {
        String _elvis = null;
        String _entryName = it_1.getEntryName();
        if (_entryName != null) {
          _elvis = _entryName;
        } else {
          String _name = it_1.getName();
          _elvis = _name;
        }
        return _elvis;
      };
      final Function1<LootEntry, EStructuralFeature> _function_1 = (LootEntry it_1) -> {
        EAttribute _xifexpression = null;
        String _entryName = it_1.getEntryName();
        boolean _tripleEquals = (_entryName == null);
        if (_tripleEquals) {
          _xifexpression = MclootPackage.Literals.LOOT_ENTRY__NAME;
        } else {
          _xifexpression = MclootPackage.Literals.LOOT_ENTRY__ENTRY_NAME;
        }
        return _xifexpression;
      };
      final Function1<LootEntry, String> _function_2 = (LootEntry it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Duplicate loot entry \"");
        String _elvis = null;
        String _entryName = it_1.getEntryName();
        if (_entryName != null) {
          _elvis = _entryName;
        } else {
          String _name = it_1.getName();
          _elvis = _name;
        }
        _builder.append(_elvis);
        _builder.append("\"");
        return _builder.toString();
      };
      this.<LootEntry, String>checkUnique(true, it.getEntries(), _function, _function_1, _function_2);
    }
  }
  
  @Check
  public void checkUniformCount(final UniformCount it) {
    long _min = it.getMin();
    long _max = it.getMax();
    boolean _greaterThan = (_min > _max);
    if (_greaterThan) {
      this.error("Range start cannot be greater than range end", 
        MclootPackage.Literals.UNIFORM_COUNT__MIN);
      this.error("Range start cannot be greater than range end", 
        MclootPackage.Literals.UNIFORM_COUNT__MAX);
    } else {
      long _min_1 = it.getMin();
      long _max_1 = it.getMax();
      boolean _equals = (_min_1 == _max_1);
      if (_equals) {
        this.warning("Range size == 1, don\'t need range syntax", 
          MclootPackage.Literals.UNIFORM_COUNT__MIN);
        this.warning("Range size == 1, don\'t need range syntax", 
          MclootPackage.Literals.UNIFORM_COUNT__MAX);
      }
    }
  }
  
  @Check
  public void checkBinomialCount(final BinomialCount it) {
    this.checkPercentage(it, MclootPackage.Literals.BINOMIAL_COUNT__P);
  }
  
  @Check
  public void checkLootFunction(final SetDamageLootFunction it) {
    this.checkPercentageRange(it.getDamage());
  }
  
  @Check
  public void checkLootFunction(final SetStewEffectLootFunction it) {
    this.<StewEffect>checkUnique(it.getEffects(), MclootPackage.Literals.STEW_EFFECT__TYPE, "Duplicate effect");
  }
  
  @Check
  public MclootUtils.CallbackResult checkStewEffect(final StewEffect it) {
    final Procedure1<String> _function = (String type) -> {
      boolean _isVanillaMobEffect = MinecraftData.isVanillaMobEffect(type);
      boolean _not = (!_isVanillaMobEffect);
      if (_not) {
        this.warning("Unknown vanilla mob effect type", 
          MclootPackage.Literals.STEW_EFFECT__TYPE);
      }
      String _type = it.getType();
      boolean _tripleEquals = (type == _type);
      if (_tripleEquals) {
        this.info("Namespace defaulting to \'minecraft\'", 
          MclootPackage.Literals.STEW_EFFECT__TYPE);
      }
    };
    return MclootUtils.ifMinecraftKey(it.getType(), _function);
  }
  
  @Check
  public void checkLootCondition(final BlockStatePropertiesLootCondition it) {
    final Procedure1<String> _function = (String block) -> {
      final Map<String, ? extends Property> states = MinecraftData.VANILLA_BLOCK_STATES.get(block);
      if ((states == null)) {
        this.warning("Unknown vanilla block name", 
          MclootPackage.Literals.BLOCK_STATE_PROPERTIES_LOOT_CONDITION__BLOCK);
        boolean _isEmpty = it.getProperties().isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          this.<BlockStateProperty>checkUnique(it.getProperties(), MclootPackage.Literals.BLOCK_STATE_PROPERTY__NAME, "Duplicate property");
        }
      } else {
        boolean _isEmpty_1 = it.getProperties().isEmpty();
        boolean _not_1 = (!_isEmpty_1);
        if (_not_1) {
          final Function1<BlockStateProperty, String> _function_1 = (BlockStateProperty property) -> {
            final Property propObject = states.get(property.getName());
            if ((propObject == null)) {
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("Block minecraft:");
              _builder.append(block);
              _builder.append(" does not have a state named ");
              String _name = property.getName();
              _builder.append(_name);
              _builder.append(".");
              this.error(_builder.toString(), property, 
                MclootPackage.Literals.BLOCK_STATE_PROPERTY__NAME);
            } else {
              boolean _isValid = propObject.isValid(property.getValue());
              boolean _not_2 = (!_isValid);
              if (_not_2) {
                StringConcatenation _builder_1 = new StringConcatenation();
                _builder_1.append("\"");
                String _value = property.getValue();
                _builder_1.append(_value);
                _builder_1.append("\" is not valid for property ");
                String _name_1 = property.getName();
                _builder_1.append(_name_1);
                _builder_1.append(" of minecraft:");
                _builder_1.append(block);
                this.error(_builder_1.toString(), property, 
                  MclootPackage.Literals.BLOCK_STATE_PROPERTY__VALUE);
              }
            }
            return property.getName();
          };
          this.<BlockStateProperty, String>checkUnique(it.getProperties(), _function_1, MclootPackage.Literals.BLOCK_STATE_PROPERTY__NAME, "Duplicate property");
        }
      }
    };
    final Runnable _function_1 = () -> {
      boolean _isEmpty = it.getProperties().isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        this.<BlockStateProperty>checkUnique(it.getProperties(), MclootPackage.Literals.BLOCK_STATE_PROPERTY__NAME, "Duplicate property");
      }
    };
    MclootUtils.ifMinecraftKey(it.getBlock(), _function).otherwise(_function_1);
  }
  
  @Check
  public void checkLootCondition(final EntityScoresLootCondition it) {
    boolean _isEmpty = it.getScores().isEmpty();
    if (_isEmpty) {
      this.warning("No scores given", 
        MclootPackage.Literals.NAMED_LOOT_CONDITION__ID);
    } else {
      this.<EntityScore>checkUnique(it.getScores(), MclootPackage.Literals.ENTITY_SCORE__OBJECTIVE, "Duplicate score objective");
    }
  }
  
  @Check
  public void checkLootCondition(final RandomChanceLootCondition it) {
    this.checkPercentage(it, MclootPackage.Literals.RANDOM_CHANCE_LOOT_CONDITION__CHANCE);
  }
  
  @Check
  public void checkLootCondition(final TableBonusLootCondition it) {
    final Procedure1<String> _function = (String enchantment) -> {
      boolean _isVanillaEnchantment = MinecraftData.isVanillaEnchantment(enchantment);
      boolean _not = (!_isVanillaEnchantment);
      if (_not) {
        this.warning("Unknown vanilla enchantment name", 
          MclootPackage.Literals.TABLE_BONUS_LOOT_CONDITION__ENCHANTMENT);
      }
      String _enchantment = it.getEnchantment();
      boolean _tripleEquals = (enchantment == _enchantment);
      if (_tripleEquals) {
        this.info("Namespace defaulting to \'minecraft\'", 
          MclootPackage.Literals.TABLE_BONUS_LOOT_CONDITION__ENCHANTMENT);
      }
    };
    MclootUtils.ifMinecraftKey(it.getEnchantment(), _function);
    this.checkPercentages(it, MclootPackage.Literals.TABLE_BONUS_LOOT_CONDITION__CHANCES);
  }
  
  @Check
  public void checkLootCondition(final ToolEnchantmentLootCondition it) {
    boolean _isEmpty = it.getEnchantments().isEmpty();
    if (_isEmpty) {
      this.warning("No enchantments defined", 
        MclootPackage.Literals.NAMED_LOOT_CONDITION__ID);
    } else {
      final Function1<EnchantmentLevel, String> _function = (EnchantmentLevel it_1) -> {
        return MclootUtils.addDefaultNamespace(it_1.getEnchantment());
      };
      this.<EnchantmentLevel, String>checkUnique(it.getEnchantments(), _function, MclootPackage.Literals.ENCHANTMENT_LEVEL__ENCHANTMENT, "Duplicate enchantment level entry");
    }
  }
  
  @Check
  public MclootUtils.CallbackResult checkEnchantmentLevel(final EnchantmentLevel it) {
    final Procedure1<String> _function = (String enchantment) -> {
      boolean _isVanillaEnchantment = MinecraftData.isVanillaEnchantment(enchantment);
      boolean _not = (!_isVanillaEnchantment);
      if (_not) {
        this.warning("Unknown vanilla enchantment name", 
          MclootPackage.Literals.ENCHANTMENT_LEVEL__ENCHANTMENT);
      }
      String _enchantment = it.getEnchantment();
      boolean _tripleEquals = (enchantment == _enchantment);
      if (_tripleEquals) {
        this.info("Namespace defaulting to \'minecraft\'", 
          MclootPackage.Literals.ENCHANTMENT_LEVEL__ENCHANTMENT);
      }
    };
    return MclootUtils.ifMinecraftKey(it.getEnchantment(), _function);
  }
  
  @Check
  public MclootUtils.CallbackResult checkEntityPredicate(final EntityPredicate it) {
    MclootUtils.CallbackResult _xblockexpression = null;
    {
      boolean _isEffectsDefined = it.isEffectsDefined();
      if (_isEffectsDefined) {
        boolean _isEmpty = it.getEffects().isEmpty();
        if (_isEmpty) {
          this.warning("No effects given", 
            MclootPackage.Literals.ENTITY_PREDICATE__EFFECTS_DEFINED);
        } else {
          final Function1<EffectPredicate, String> _function = (EffectPredicate it_1) -> {
            return MclootUtils.addDefaultNamespace(it_1.getId());
          };
          this.<EffectPredicate, String>checkUnique(it.getEffects(), _function, MclootPackage.Literals.EFFECT_PREDICATE__ID, "Duplicate effect predicate");
        }
      }
      boolean _isEmpty_1 = it.getEquipment().isEmpty();
      boolean _not = (!_isEmpty_1);
      if (_not) {
        final EnumMap<EnumEquipmentSlot, SeenInfo<Pair<EquipmentPredicate, Integer>>> seen = new EnumMap<EnumEquipmentSlot, SeenInfo<Pair<EquipmentPredicate, Integer>>>(EnumEquipmentSlot.class);
        EList<EquipmentPredicate> _equipment = it.getEquipment();
        for (final EquipmentPredicate predicate : _equipment) {
          {
            final EList<EnumEquipmentSlot> slots = predicate.getSlots();
            for (int i = 0; (i < slots.size()); i++) {
              {
                final EnumEquipmentSlot enumEquipmentSlot = slots.get(i);
                final SeenInfo<Pair<EquipmentPredicate, Integer>> info = seen.get(enumEquipmentSlot);
                if ((info == null)) {
                  Pair<EquipmentPredicate, Integer> _mappedTo = Pair.<EquipmentPredicate, Integer>of(predicate, Integer.valueOf(i));
                  seen.put(enumEquipmentSlot, MclootValidator.<Pair<EquipmentPredicate, Integer>>seen(_mappedTo));
                } else {
                  if ((!info.errored)) {
                    info.errored = true;
                    this.error("Duplicate equipment slot definition", 
                      info.value.getKey(), 
                      MclootPackage.Literals.EQUIPMENT_PREDICATE__SLOTS, (info.value.getValue()).intValue());
                  }
                  this.error("Duplicate equipment slot definition", predicate, 
                    MclootPackage.Literals.EQUIPMENT_PREDICATE__SLOTS, i);
                }
              }
            }
          }
        }
        if (((seen.size() == 6) && (it.getDefaultEquipment() != null))) {
          this.warning("Unused default equipment", 
            MclootPackage.Literals.ENTITY_PREDICATE__DEFAULT_EQUIPMENT);
        }
      }
      MclootUtils.CallbackResult _xifexpression = null;
      String _type = it.getType();
      boolean _tripleNotEquals = (_type != null);
      if (_tripleNotEquals) {
        final Procedure1<String> _function_1 = (String type) -> {
          boolean _isVanillaEntityType = MinecraftData.isVanillaEntityType(type);
          boolean _not_1 = (!_isVanillaEntityType);
          if (_not_1) {
            this.warning("Unknown vanilla entity type", 
              MclootPackage.Literals.ENTITY_PREDICATE__TYPE);
          }
          String _type_1 = it.getType();
          boolean _tripleEquals = (type == _type_1);
          if (_tripleEquals) {
            this.info("Namespace defaulting to \'minecraft\'", 
              MclootPackage.Literals.ENTITY_PREDICATE__TYPE);
          }
        };
        _xifexpression = MclootUtils.ifMinecraftKey(it.getType(), _function_1);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public MclootUtils.CallbackResult checkEffectPredicate(final EffectPredicate it) {
    final Procedure1<String> _function = (String id) -> {
      boolean _isVanillaMobEffect = MinecraftData.isVanillaMobEffect(id);
      boolean _not = (!_isVanillaMobEffect);
      if (_not) {
        this.warning("Unknown vanilla mob effect type", 
          MclootPackage.Literals.EFFECT_PREDICATE__ID);
      }
      String _id = it.getId();
      boolean _tripleEquals = (id == _id);
      if (_tripleEquals) {
        this.info("Namespace defaulting to \'minecraft\'", 
          MclootPackage.Literals.EFFECT_PREDICATE__ID);
      }
    };
    return MclootUtils.ifMinecraftKey(it.getId(), _function);
  }
  
  @Check
  public void checkLongRange(final NormalLongRange it) {
    if ((MclootUtils.isMinDefined(it) && MclootUtils.isMaxDefined(it))) {
      long _min = it.getMin();
      long _max = it.getMax();
      boolean _greaterThan = (_min > _max);
      if (_greaterThan) {
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
      } else {
        long _min_1 = it.getMin();
        long _max_1 = it.getMax();
        boolean _equals = (_min_1 == _max_1);
        if (_equals) {
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
        }
      }
    }
  }
  
  @Check
  public void checkDoubleRange(final NormalDoubleRange it) {
    if ((MclootUtils.isMinDefined(it) && MclootUtils.isMaxDefined(it))) {
      double _min = it.getMin();
      double _max = it.getMax();
      boolean _greaterThan = (_min > _max);
      if (_greaterThan) {
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
      } else {
        double _min_1 = it.getMin();
        double _max_1 = it.getMax();
        boolean _equals = (_min_1 == _max_1);
        if (_equals) {
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
        }
      }
    }
  }
  
  public void checkLongRange(final LongRange range, final Long min_param, final Long max_param) {
    Long _elvis = null;
    if (min_param != null) {
      _elvis = min_param;
    } else {
      _elvis = Long.valueOf(Long.MIN_VALUE);
    }
    final long min = (long) _elvis;
    Long _elvis_1 = null;
    if (max_param != null) {
      _elvis_1 = max_param;
    } else {
      _elvis_1 = Long.valueOf(Long.MAX_VALUE);
    }
    final long max = (long) _elvis_1;
    boolean _matched = false;
    if (range instanceof ExactLongRange) {
      _matched=true;
      long _value = ((ExactLongRange)range).getValue();
      boolean _lessThan = (_value < min);
      if (_lessThan) {
        this.error("Value is too small", range, 
          MclootPackage.Literals.EXACT_LONG_RANGE__VALUE);
      } else {
        long _value_1 = ((ExactLongRange)range).getValue();
        boolean _greaterThan = (_value_1 > max);
        if (_greaterThan) {
          this.error("Value is too large", range, 
            MclootPackage.Literals.EXACT_LONG_RANGE__VALUE);
        }
      }
    }
    if (!_matched) {
      if (range instanceof NormalLongRange) {
        _matched=true;
        boolean _isMinDefined = MclootUtils.isMinDefined(((NormalLongRange)range));
        if (_isMinDefined) {
          long _min = ((NormalLongRange)range).getMin();
          boolean _lessThan = (_min < min);
          if (_lessThan) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
          } else {
            long _min_1 = ((NormalLongRange)range).getMin();
            boolean _greaterThan = (_min_1 > max);
            if (_greaterThan) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
            }
          }
        }
        boolean _isMaxDefined = MclootUtils.isMaxDefined(((NormalLongRange)range));
        if (_isMaxDefined) {
          long _max = ((NormalLongRange)range).getMax();
          boolean _lessThan_1 = (_max < min);
          if (_lessThan_1) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
          } else {
            long _max_1 = ((NormalLongRange)range).getMax();
            boolean _greaterThan_1 = (_max_1 > max);
            if (_greaterThan_1) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
            }
          }
        }
      }
    }
  }
  
  public void checkULongRange(final LongRange range) {
    this.checkLongRange(range, Long.valueOf(0L), null);
  }
  
  public void checkDoubleRange(final DoubleRange range, final Double min_param, final Double max_param) {
    Double _elvis = null;
    if (min_param != null) {
      _elvis = min_param;
    } else {
      _elvis = Double.valueOf(Double.NEGATIVE_INFINITY);
    }
    final double min = (double) _elvis;
    Double _elvis_1 = null;
    if (max_param != null) {
      _elvis_1 = max_param;
    } else {
      _elvis_1 = Double.valueOf(Double.POSITIVE_INFINITY);
    }
    final double max = (double) _elvis_1;
    boolean _matched = false;
    if (range instanceof ExactDoubleRange) {
      _matched=true;
      double _value = ((ExactDoubleRange)range).getValue();
      boolean _lessThan = (_value < min);
      if (_lessThan) {
        this.error("Value is too small", range, 
          MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE);
      } else {
        double _value_1 = ((ExactDoubleRange)range).getValue();
        boolean _greaterThan = (_value_1 > max);
        if (_greaterThan) {
          this.error("Value is too large", range, 
            MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE);
        }
      }
    }
    if (!_matched) {
      if (range instanceof NormalDoubleRange) {
        _matched=true;
        boolean _isMinDefined = MclootUtils.isMinDefined(((NormalDoubleRange)range));
        if (_isMinDefined) {
          double _min = ((NormalDoubleRange)range).getMin();
          boolean _lessThan = (_min < min);
          if (_lessThan) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
          } else {
            double _min_1 = ((NormalDoubleRange)range).getMin();
            boolean _greaterThan = (_min_1 > max);
            if (_greaterThan) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
            }
          }
        }
        boolean _isMaxDefined = MclootUtils.isMaxDefined(((NormalDoubleRange)range));
        if (_isMaxDefined) {
          double _max = ((NormalDoubleRange)range).getMax();
          boolean _lessThan_1 = (_max < min);
          if (_lessThan_1) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
          } else {
            double _max_1 = ((NormalDoubleRange)range).getMax();
            boolean _greaterThan_1 = (_max_1 > max);
            if (_greaterThan_1) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
            }
          }
        }
      }
    }
  }
  
  public void checkPercentageRange(final DoubleRange range) {
    boolean _matched = false;
    if (range instanceof ExactDoubleRange) {
      _matched=true;
      this.checkPercentage(range, MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE);
    }
    if (!_matched) {
      if (range instanceof NormalDoubleRange) {
        _matched=true;
        boolean _isMinDefined = MclootUtils.isMinDefined(((NormalDoubleRange)range));
        if (_isMinDefined) {
          this.checkPercentage(range, MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
        }
        boolean _isMaxDefined = MclootUtils.isMaxDefined(((NormalDoubleRange)range));
        if (_isMaxDefined) {
          this.checkPercentage(range, MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
        }
      }
    }
  }
  
  public void checkPercentage(final EObject object, final EStructuralFeature feature) {
    Object _eGet = object.eGet(feature);
    final double value = (((Double) _eGet)).doubleValue();
    if (((value < 0) || (value > 1))) {
      this.error("Value must be between 0 and 1", object, feature);
    }
  }
  
  public void checkPercentages(final EObject object, final EStructuralFeature feature) {
    Object _eGet = object.eGet(feature);
    final List<Double> values = ((List<Double>) _eGet);
    for (int i = 0; (i < values.size()); i++) {
      {
        final double value = (values.get(i)).doubleValue();
        if (((value < 0) || (value > 1))) {
          this.error("Value must be between 0 and 1", object, feature, i);
        }
      }
    }
  }
  
  protected static boolean isWithin(final double value, final double min, final double max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static boolean isWithin(final float value, final float min, final float max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static boolean isWithin(final long value, final long min, final long max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static boolean isWithin(final int value, final int min, final int max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static <T extends Object> SeenInfo<T> seen(final T value) {
    return new SeenInfo<T>(value);
  }
  
  protected static <K extends Object, T extends Object> HashMap<K, SeenInfo<T>> newSeenMap() {
    return new HashMap<K, SeenInfo<T>>();
  }
  
  protected static <K extends Object, T extends Object> HashMap<K, SeenInfo<T>> newSeenMap(final int capacity) {
    return new HashMap<K, SeenInfo<T>>(capacity);
  }
  
  protected <T extends EObject> void checkUnique(final List<T> items, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T>checkUnique(items, feature, _function);
  }
  
  protected <T extends EObject> void checkUnique(final boolean warning, final List<T> items, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T>checkUnique(warning, items, feature, _function);
  }
  
  protected <T extends EObject> void checkUnique(final List<T> items, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, Object> _function = (T it) -> {
      return it.eGet(feature);
    };
    this.<T, Object>checkUnique(items, _function, feature, errorMessageSupplier);
  }
  
  protected <T extends EObject> void checkUnique(final boolean warning, final List<T> items, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, Object> _function = (T it) -> {
      return it.eGet(feature);
    };
    this.<T, Object>checkUnique(warning, items, _function, feature, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T, K>checkUnique(items, keyMapper, feature, _function);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final boolean warning, final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T, K>checkUnique(warning, items, keyMapper, feature, _function);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, EStructuralFeature> _function = (T it) -> {
      return feature;
    };
    this.<T, K>checkUnique(items, keyMapper, _function, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final boolean warning, final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, EStructuralFeature> _function = (T it) -> {
      return feature;
    };
    this.<T, K>checkUnique(warning, items, keyMapper, _function, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final List<T> items, final Function1<? super T, ? extends K> keyMapper, final Function1<? super T, ? extends EStructuralFeature> featureMapper, final Function1<? super T, ? extends String> errorMessageSupplier) {
    this.<T, K>checkUnique(false, items, keyMapper, featureMapper, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final boolean warning, final List<T> items, final Function1<? super T, ? extends K> keyMapper, final Function1<? super T, ? extends EStructuralFeature> featureMapper, final Function1<? super T, ? extends String> errorMessageSupplier) {
    boolean _isEmpty = items.isEmpty();
    if (_isEmpty) {
      return;
    }
    final HashMap<K, SeenInfo<T>> seen = MclootValidator.<K, T>newSeenMap(items.size());
    for (final T item : items) {
      {
        final K key = keyMapper.apply(item);
        if ((key != null)) {
          final SeenInfo<T> info = seen.get(key);
          if ((info == null)) {
            seen.put(key, MclootValidator.<T>seen(item));
          } else {
            if ((!info.errored)) {
              info.errored = true;
              if (warning) {
                this.warning(errorMessageSupplier.apply(info.value), 
                  info.value, 
                  featureMapper.apply(info.value));
              } else {
                this.error(errorMessageSupplier.apply(info.value), 
                  info.value, 
                  featureMapper.apply(info.value));
              }
            }
            if (warning) {
              this.warning(errorMessageSupplier.apply(item), item, 
                featureMapper.apply(item));
            } else {
              this.error(errorMessageSupplier.apply(item), item, 
                featureMapper.apply(item));
            }
          }
        }
      }
    }
  }
  
  protected <T extends Object> void checkUniqueValues(final EObject object, final EStructuralFeature feature, final String errorMessage) {
    final Function2<Object, Integer, String> _function = (Object $0, Integer $1) -> {
      return errorMessage;
    };
    this.<Object>checkUniqueValues(false, object, feature, _function);
  }
  
  protected <T extends Object> void checkUniqueValues(final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    this.<T>checkUniqueValues(false, object, feature, errorMessageSupplier);
  }
  
  protected <T extends Object> void checkUniqueValues(final boolean warning, final EObject object, final EStructuralFeature feature, final String errorMessage) {
    Object _eGet = object.eGet(feature);
    final Function2<T, Integer, Object> _function = (T $0, Integer $1) -> {
      return $0;
    };
    final Function2<T, Integer, String> _function_1 = (T $0, Integer $1) -> {
      return errorMessage;
    };
    this.<T>checkUniqueValues(warning, ((List<T>) _eGet), object, feature, _function, _function_1);
  }
  
  protected <T extends Object> void checkUniqueValues(final boolean warning, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    Object _eGet = object.eGet(feature);
    final Function2<T, Integer, Object> _function = (T $0, Integer $1) -> {
      return $0;
    };
    this.<T>checkUniqueValues(warning, ((List<T>) _eGet), object, feature, _function, errorMessageSupplier);
  }
  
  protected <T extends Object> void checkUniqueValues(final List<T> items, final EObject object, final EStructuralFeature feature, final String errorMessage) {
    final Function2<T, Integer, Object> _function = (T $0, Integer $1) -> {
      return $0;
    };
    final Function2<T, Integer, String> _function_1 = (T $0, Integer $1) -> {
      return errorMessage;
    };
    this.<T>checkUniqueValues(false, items, object, feature, _function, _function_1);
  }
  
  protected <T extends Object> void checkUniqueValues(final List<T> items, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    final Function2<T, Integer, Object> _function = (T $0, Integer $1) -> {
      return $0;
    };
    this.<T>checkUniqueValues(false, items, object, feature, _function, errorMessageSupplier);
  }
  
  protected <T extends Object> void checkUniqueValues(final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final String errorMessage) {
    final Function2<T, Integer, String> _function = (T $0, Integer $1) -> {
      return errorMessage;
    };
    this.<T>checkUniqueValues(false, object, feature, keyMapper, _function);
  }
  
  protected <T extends Object> void checkUniqueValues(final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    this.<T>checkUniqueValues(false, object, feature, keyMapper, errorMessageSupplier);
  }
  
  protected <T extends Object> void checkUniqueValues(final boolean warning, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final String errorMessage) {
    Object _eGet = object.eGet(feature);
    final Function2<T, Integer, String> _function = (T $0, Integer $1) -> {
      return errorMessage;
    };
    this.<T>checkUniqueValues(warning, ((List<T>) _eGet), object, feature, keyMapper, _function);
  }
  
  protected <T extends Object> void checkUniqueValues(final boolean warning, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    Object _eGet = object.eGet(feature);
    this.<T>checkUniqueValues(warning, ((List<T>) _eGet), object, feature, keyMapper, errorMessageSupplier);
  }
  
  protected <T extends Object> void checkUniqueValues(final List<T> items, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final String errorMessage) {
    final Function2<T, Integer, String> _function = (T $0, Integer $1) -> {
      return errorMessage;
    };
    this.<T>checkUniqueValues(false, items, object, feature, keyMapper, _function);
  }
  
  protected <T extends Object> void checkUniqueValues(final List<T> items, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    this.<T>checkUniqueValues(false, items, object, feature, keyMapper, errorMessageSupplier);
  }
  
  protected <T extends Object> void checkUniqueValues(final boolean warning, final List<T> items, final EObject object, final EStructuralFeature feature, final Function2<? super T, ? super Integer, ?> keyMapper, final Function2<? super T, ? super Integer, ? extends String> errorMessageSupplier) {
    boolean _isEmpty = items.isEmpty();
    if (_isEmpty) {
      return;
    }
    final HashMap<Object, SeenInfo<Integer>> seen = MclootValidator.<Object, Integer>newSeenMap(items.size());
    for (int i = 0; (i < items.size()); i++) {
      {
        final T item = items.get(i);
        final Object key = keyMapper.apply(item, Integer.valueOf(i));
        final SeenInfo<Integer> info = seen.get(key);
        if ((info == null)) {
          seen.put(key, MclootValidator.<Integer>seen(Integer.valueOf(i)));
        } else {
          if ((!info.errored)) {
            info.errored = true;
            if (warning) {
              this.warning(errorMessageSupplier.apply(items.get((info.value).intValue()), info.value), object, feature, (info.value).intValue());
            } else {
              this.error(errorMessageSupplier.apply(items.get((info.value).intValue()), info.value), object, feature, (info.value).intValue());
            }
          }
          if (warning) {
            this.warning(errorMessageSupplier.apply(item, Integer.valueOf(i)), object, feature, i);
          }
        }
      }
    }
  }
}
