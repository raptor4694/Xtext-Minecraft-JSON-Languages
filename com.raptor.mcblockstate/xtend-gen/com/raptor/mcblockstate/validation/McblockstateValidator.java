/**
 * generated by Xtext 2.21.0
 */
package com.raptor.mcblockstate.validation;

import com.raptor.mcblockstate.generator.McblockstateGenerator;
import com.raptor.mcblockstate.mcblockstate.BaseCaseCondition;
import com.raptor.mcblockstate.mcblockstate.BlockstatePropertyPredicate;
import com.raptor.mcblockstate.mcblockstate.MCJsonEntry;
import com.raptor.mcblockstate.mcblockstate.MCJsonObject;
import com.raptor.mcblockstate.mcblockstate.McblockstatePackage;
import com.raptor.mcblockstate.mcblockstate.Model;
import com.raptor.mcblockstate.mcblockstate.ModelList;
import com.raptor.mcblockstate.mcblockstate.NormalBlockstatePropertyPredicate;
import com.raptor.mcblockstate.mcblockstate.Variant;
import com.raptor.mcblockstate.mcblockstate.VariantsBlockstate;
import com.raptor.mcblockstate.validation.AbstractMcblockstateValidator;
import com.raptor.mcblockstate.validation.SeenInfo;
import java.util.HashMap;
import java.util.function.Predicate;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class McblockstateValidator extends AbstractMcblockstateValidator {
  @Check
  public void checkNoDuplicates(final MCJsonObject it) {
    final HashMap<String, SeenInfo<MCJsonEntry>> seenEntries = McblockstateValidator.<MCJsonEntry>newSeenMap();
    EList<MCJsonEntry> _entries = it.getEntries();
    for (final MCJsonEntry entry : _entries) {
      {
        final SeenInfo<MCJsonEntry> info = seenEntries.get(entry.getName());
        if ((info == null)) {
          seenEntries.put(entry.getName(), McblockstateValidator.<MCJsonEntry>seen(entry));
        } else {
          if ((!info.errored)) {
            info.errored = true;
            this.error("Duplicate entry", 
              info.value, 
              McblockstatePackage.Literals.MC_JSON_ENTRY__NAME);
          }
          this.error("Duplicate entry", entry, 
            McblockstatePackage.Literals.MC_JSON_ENTRY__NAME);
        }
      }
    }
  }
  
  @Check
  public void checkNoDuplicates(final VariantsBlockstate it) {
    final HashMap<String, SeenInfo<Variant>> seenVariants = McblockstateValidator.<Variant>newSeenMap();
    EList<Variant> _variants = it.getVariants();
    for (final Variant variant : _variants) {
      {
        final String key = McblockstateGenerator.getPropertyString(variant);
        final SeenInfo<Variant> info = seenVariants.get(key);
        if ((info == null)) {
          seenVariants.put(key, McblockstateValidator.<Variant>seen(variant));
        } else {
          if ((!info.errored)) {
            info.errored = true;
            this.error("Duplicate variant", 
              info.value, 
              McblockstatePackage.Literals.VARIANT__PROPERTIES);
          }
          this.error("Duplicate variant", variant, 
            McblockstatePackage.Literals.VARIANT__PROPERTIES);
        }
      }
    }
  }
  
  @Check
  public void checkModel(final Model it) {
    if ((it.isWeightDefined() && (it.getWeight() <= 0))) {
      this.error("Weight must be > 0", 
        McblockstatePackage.Literals.MODEL__WEIGHT);
    }
    long _x = it.getX();
    long _modulo = (_x % 90);
    boolean _notEquals = (_modulo != 0);
    if (_notEquals) {
      this.error("x must be in increments of 90 degrees", 
        McblockstatePackage.Literals.MODEL__X);
    }
    long _y = it.getY();
    long _modulo_1 = (_y % 90);
    boolean _notEquals_1 = (_modulo_1 != 0);
    if (_notEquals_1) {
      this.error("y must be in increments of 90 degrees", 
        McblockstatePackage.Literals.MODEL__Y);
    }
  }
  
  @Check
  public void checkModelList(final ModelList it) {
    final Predicate<Model> _function = (Model it_1) -> {
      return it_1.isWeightDefined();
    };
    boolean _anyMatch = it.getModels().stream().anyMatch(_function);
    if (_anyMatch) {
      int _size = it.getModels().size();
      boolean _equals = (_size == 1);
      if (_equals) {
        this.warning("Weight is not necessary", 
          it.getModels().get(0), 
          McblockstatePackage.Literals.MODEL__WEIGHT);
      } else {
        for (int i = 0; (i < it.getModels().size()); i++) {
          {
            final Model model = it.getModels().get(i);
            boolean _isWeightDefined = model.isWeightDefined();
            boolean _not = (!_isWeightDefined);
            if (_not) {
              this.warning("Model does not define a weight", 
                McblockstatePackage.Literals.MODEL_LIST__MODELS, i);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkNoDuplicates(final NormalBlockstatePropertyPredicate it) {
    final HashMap<String, SeenInfo<Integer>> seenValues = McblockstateValidator.<Integer>newSeenMap();
    for (int i = 0; (i < it.getValues().size()); i++) {
      {
        final String value = it.getValues().get(i);
        final SeenInfo<Integer> info = seenValues.get(value);
        if ((info == null)) {
          seenValues.put(value, McblockstateValidator.<Integer>seen(Integer.valueOf(i)));
        } else {
          if ((!info.errored)) {
            info.errored = true;
            this.error("Duplicate value", 
              McblockstatePackage.Literals.NORMAL_BLOCKSTATE_PROPERTY_PREDICATE__VALUES, (info.value).intValue());
          }
          this.error("Duplicate value", 
            McblockstatePackage.Literals.NORMAL_BLOCKSTATE_PROPERTY_PREDICATE__VALUES, i);
        }
      }
    }
  }
  
  @Check
  public void checkNoDuplicates(final BaseCaseCondition it) {
    final HashMap<String, SeenInfo<BlockstatePropertyPredicate>> seenProperties = McblockstateValidator.<BlockstatePropertyPredicate>newSeenMap();
    EList<BlockstatePropertyPredicate> _properties = it.getProperties();
    for (final BlockstatePropertyPredicate property : _properties) {
      {
        final SeenInfo<BlockstatePropertyPredicate> info = seenProperties.get(property.getName());
        if ((info == null)) {
          seenProperties.put(property.getName(), McblockstateValidator.<BlockstatePropertyPredicate>seen(property));
        } else {
          if ((!info.errored)) {
            info.errored = true;
            this.error("Duplicate property", 
              info.value, 
              McblockstatePackage.Literals.BLOCKSTATE_PROPERTY_PREDICATE__NAME);
          }
          this.error("Duplicate property", property, 
            McblockstatePackage.Literals.BLOCKSTATE_PROPERTY_PREDICATE__NAME);
        }
      }
    }
  }
  
  private static <T extends Object> SeenInfo<T> seen(final T value) {
    return new SeenInfo<T>(value);
  }
  
  private static <T extends Object> HashMap<String, SeenInfo<T>> newSeenMap() {
    return new HashMap<String, SeenInfo<T>>();
  }
  
  private static <T extends Object> HashMap<String, SeenInfo<T>> newSeenMap(final int capacity) {
    return new HashMap<String, SeenInfo<T>>(capacity);
  }
}
