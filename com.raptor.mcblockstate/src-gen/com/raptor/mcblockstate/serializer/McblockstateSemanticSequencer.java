/*
 * generated by Xtext 2.21.0
 */
package com.raptor.mcblockstate.serializer;

import com.google.inject.Inject;
import com.raptor.mcblockstate.mcblockstate.BaseCaseCondition;
import com.raptor.mcblockstate.mcblockstate.BlockstateProperty;
import com.raptor.mcblockstate.mcblockstate.BooleanBlockstatePropertyPredicate;
import com.raptor.mcblockstate.mcblockstate.Case;
import com.raptor.mcblockstate.mcblockstate.CustomBlockstate;
import com.raptor.mcblockstate.mcblockstate.MCJsonArray;
import com.raptor.mcblockstate.mcblockstate.MCJsonBoolean;
import com.raptor.mcblockstate.mcblockstate.MCJsonEntry;
import com.raptor.mcblockstate.mcblockstate.MCJsonFloatingPoint;
import com.raptor.mcblockstate.mcblockstate.MCJsonIntegral;
import com.raptor.mcblockstate.mcblockstate.MCJsonNull;
import com.raptor.mcblockstate.mcblockstate.MCJsonObject;
import com.raptor.mcblockstate.mcblockstate.MCJsonString;
import com.raptor.mcblockstate.mcblockstate.McblockstatePackage;
import com.raptor.mcblockstate.mcblockstate.Model;
import com.raptor.mcblockstate.mcblockstate.ModelList;
import com.raptor.mcblockstate.mcblockstate.MultipartBlockstate;
import com.raptor.mcblockstate.mcblockstate.NormalBlockstatePropertyPredicate;
import com.raptor.mcblockstate.mcblockstate.OrCaseCondition;
import com.raptor.mcblockstate.mcblockstate.Variant;
import com.raptor.mcblockstate.mcblockstate.VariantsBlockstate;
import com.raptor.mcblockstate.services.McblockstateGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class McblockstateSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private McblockstateGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == McblockstatePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case McblockstatePackage.BASE_CASE_CONDITION:
				sequence_BaseCaseCondition(context, (BaseCaseCondition) semanticObject); 
				return; 
			case McblockstatePackage.BLOCKSTATE_PROPERTY:
				sequence_BlockstateProperty(context, (BlockstateProperty) semanticObject); 
				return; 
			case McblockstatePackage.BOOLEAN_BLOCKSTATE_PROPERTY_PREDICATE:
				sequence_BlockstatePropertyPredicate(context, (BooleanBlockstatePropertyPredicate) semanticObject); 
				return; 
			case McblockstatePackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case McblockstatePackage.CUSTOM_BLOCKSTATE:
				sequence_CustomBlockstate(context, (CustomBlockstate) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_ARRAY:
				sequence_MCJsonArray(context, (MCJsonArray) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_BOOLEAN:
				sequence_MCJsonBoolean(context, (MCJsonBoolean) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_ENTRY:
				sequence_MCJsonEntry(context, (MCJsonEntry) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_FLOATING_POINT:
				sequence_MCJsonFloatingPoint(context, (MCJsonFloatingPoint) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_INTEGRAL:
				sequence_MCJsonIntegral(context, (MCJsonIntegral) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_NULL:
				sequence_MCJsonNull(context, (MCJsonNull) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_OBJECT:
				sequence_MCJsonObject(context, (MCJsonObject) semanticObject); 
				return; 
			case McblockstatePackage.MC_JSON_STRING:
				sequence_MCJsonString(context, (MCJsonString) semanticObject); 
				return; 
			case McblockstatePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case McblockstatePackage.MODEL_LIST:
				sequence_ModelList(context, (ModelList) semanticObject); 
				return; 
			case McblockstatePackage.MULTIPART_BLOCKSTATE:
				sequence_MultipartBlockstate(context, (MultipartBlockstate) semanticObject); 
				return; 
			case McblockstatePackage.NORMAL_BLOCKSTATE_PROPERTY_PREDICATE:
				sequence_BlockstatePropertyPredicate(context, (NormalBlockstatePropertyPredicate) semanticObject); 
				return; 
			case McblockstatePackage.OR_CASE_CONDITION:
				sequence_CaseCondition(context, (OrCaseCondition) semanticObject); 
				return; 
			case McblockstatePackage.VARIANT:
				sequence_Variant(context, (Variant) semanticObject); 
				return; 
			case McblockstatePackage.VARIANTS_BLOCKSTATE:
				sequence_VariantsBlockstate(context, (VariantsBlockstate) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CaseCondition returns BaseCaseCondition
	 *     CaseCondition.OrCaseCondition_1_0_1 returns BaseCaseCondition
	 *     BaseCaseCondition returns BaseCaseCondition
	 *
	 * Constraint:
	 *     (properties+=BlockstatePropertyPredicate properties+=BlockstatePropertyPredicate*)
	 */
	protected void sequence_BaseCaseCondition(ISerializationContext context, BaseCaseCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockstatePropertyPredicate returns BooleanBlockstatePropertyPredicate
	 *
	 * Constraint:
	 *     (inverted?='!'? name=BlockstatePropertyValue)
	 */
	protected void sequence_BlockstatePropertyPredicate(ISerializationContext context, BooleanBlockstatePropertyPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockstatePropertyPredicate returns NormalBlockstatePropertyPredicate
	 *
	 * Constraint:
	 *     (name=BlockstatePropertyValue (values+=BlockstatePropertyValue | (values+=BlockstatePropertyValue values+=BlockstatePropertyValue*))?)
	 */
	protected void sequence_BlockstatePropertyPredicate(ISerializationContext context, NormalBlockstatePropertyPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockstateProperty returns BlockstateProperty
	 *
	 * Constraint:
	 *     (name=BlockstatePropertyValue value=BlockstatePropertyValue)
	 */
	protected void sequence_BlockstateProperty(ISerializationContext context, BlockstateProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.BLOCKSTATE_PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.BLOCKSTATE_PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.BLOCKSTATE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.BLOCKSTATE_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlockstatePropertyAccess().getNameBlockstatePropertyValueParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBlockstatePropertyAccess().getValueBlockstatePropertyValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseCondition returns OrCaseCondition
	 *     CaseCondition.OrCaseCondition_1_0_1 returns OrCaseCondition
	 *     BaseCaseCondition returns OrCaseCondition
	 *
	 * Constraint:
	 *     (options+=CaseCondition_OrCaseCondition_1_0_1 options+=BaseCaseCondition options+=BaseCaseCondition*)
	 */
	protected void sequence_CaseCondition(ISerializationContext context, OrCaseCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (condition=CaseCondition? models=ModelList)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Blockstate returns CustomBlockstate
	 *     CustomBlockstate returns CustomBlockstate
	 *
	 * Constraint:
	 *     json=MCJsonObject
	 */
	protected void sequence_CustomBlockstate(ISerializationContext context, CustomBlockstate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.CUSTOM_BLOCKSTATE__JSON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.CUSTOM_BLOCKSTATE__JSON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCustomBlockstateAccess().getJsonMCJsonObjectParserRuleCall_0(), semanticObject.getJson());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonArray
	 *     MCJsonArray returns MCJsonArray
	 *
	 * Constraint:
	 *     (elements+=MCJsonValue elements+=MCJsonValue*)?
	 */
	protected void sequence_MCJsonArray(ISerializationContext context, MCJsonArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonBoolean
	 *     MCJsonBoolean returns MCJsonBoolean
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_MCJsonBoolean(ISerializationContext context, MCJsonBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonEntry returns MCJsonEntry
	 *
	 * Constraint:
	 *     (name=STRING value=MCJsonValue)
	 */
	protected void sequence_MCJsonEntry(ISerializationContext context, MCJsonEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.MC_JSON_ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.MC_JSON_ENTRY__NAME));
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.MC_JSON_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.MC_JSON_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonEntryAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMCJsonEntryAccess().getValueMCJsonValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonFloatingPoint
	 *     MCJsonNumber returns MCJsonFloatingPoint
	 *     MCJsonFloatingPoint returns MCJsonFloatingPoint
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_MCJsonFloatingPoint(ISerializationContext context, MCJsonFloatingPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.MC_JSON_FLOATING_POINT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.MC_JSON_FLOATING_POINT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonFloatingPointAccess().getValueDOUBLETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonIntegral
	 *     MCJsonNumber returns MCJsonIntegral
	 *     MCJsonIntegral returns MCJsonIntegral
	 *
	 * Constraint:
	 *     value=LONG
	 */
	protected void sequence_MCJsonIntegral(ISerializationContext context, MCJsonIntegral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.MC_JSON_INTEGRAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.MC_JSON_INTEGRAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonIntegralAccess().getValueLONGParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonNull
	 *     MCJsonNull returns MCJsonNull
	 *
	 * Constraint:
	 *     {MCJsonNull}
	 */
	protected void sequence_MCJsonNull(ISerializationContext context, MCJsonNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonObject
	 *     MCJsonObject returns MCJsonObject
	 *
	 * Constraint:
	 *     (entries+=MCJsonEntry entries+=MCJsonEntry*)?
	 */
	protected void sequence_MCJsonObject(ISerializationContext context, MCJsonObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MCJsonValue returns MCJsonString
	 *     MCJsonString returns MCJsonString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_MCJsonString(ISerializationContext context, MCJsonString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, McblockstatePackage.Literals.MC_JSON_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McblockstatePackage.Literals.MC_JSON_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMCJsonStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelList returns ModelList
	 *
	 * Constraint:
	 *     (models+=Model+ | models+=Model)?
	 */
	protected void sequence_ModelList(ISerializationContext context, ModelList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         location=NamespacedLocation 
	 *         (weightDefined?='*' weight=ULONG)? 
	 *         ((xDefined?='x' x=LONG) | (yDefined?='y' y=LONG) | (uvlockDefined?='uvlock' uvlock?='true'?))*
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Blockstate returns MultipartBlockstate
	 *     MultipartBlockstate returns MultipartBlockstate
	 *
	 * Constraint:
	 *     cases+=Case+
	 */
	protected void sequence_MultipartBlockstate(ISerializationContext context, MultipartBlockstate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variant returns Variant
	 *
	 * Constraint:
	 *     ((properties+=BlockstateProperty properties+=BlockstateProperty*)? models=ModelList)
	 */
	protected void sequence_Variant(ISerializationContext context, Variant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Blockstate returns VariantsBlockstate
	 *     VariantsBlockstate returns VariantsBlockstate
	 *
	 * Constraint:
	 *     variants+=Variant*
	 */
	protected void sequence_VariantsBlockstate(ISerializationContext context, VariantsBlockstate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
