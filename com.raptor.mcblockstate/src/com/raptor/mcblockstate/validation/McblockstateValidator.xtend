/*
 * generated by Xtext 2.21.0
 */
package com.raptor.mcblockstate.validation

import org.eclipse.xtext.validation.Check
import com.raptor.mcblockstate.mcblockstate.*

import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor
import org.eclipse.xtend.lib.annotations.ToString
import java.util.HashMap

import static com.raptor.mcblockstate.mcblockstate.McblockstatePackage.Literals.*
import static extension com.raptor.mcblockstate.utils.McblockstateUtils.*
import static extension com.raptor.mcblockstate.generator.McblockstateGenerator.*

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class McblockstateValidator extends AbstractMcblockstateValidator { //	public static final String INVALID_NAME = "invalidName";
	//
	// @Check
	// public void checkGreetingStartsWithCapital(Greeting greeting) {
	// if (!Character.isUpperCase(greeting.getName().charAt(0))) {
	// warning("Name should start with a capital",
	// McblockstatePackage.Literals.GREETING__NAME,
	// INVALID_NAME);
	// }
	// }
	
	@Check
	def checkNoDuplicates(MCJsonObject it) {
		val seenEntries = <MCJsonEntry>newSeenMap()
		for (entry : entries) {
			val info = seenEntries.get(entry.name)
			if (info === null) {
				seenEntries.put(entry.name, seen(entry))
			} else {
				if (!info.errored) {
					info.errored = true
					error("Duplicate entry",
						info.value,
						MC_JSON_ENTRY__NAME
					)
				}
				error("Duplicate entry",
					entry,
					MC_JSON_ENTRY__NAME
				)
			}
		}
	}
	
	@Check
	def checkNoDuplicates(VariantsBlockstate it) {
		val seenVariants = <Variant>newSeenMap()
		for (variant : variants) {
			val key = variant.propertyString
			val info = seenVariants.get(key)
			if (info === null) {
				seenVariants.put(key, seen(variant))
			} else {
				if (!info.errored) {
					info.errored = true
					error("Duplicate variant",
						info.value,
						VARIANT__PROPERTIES
					)
				}
				error("Duplicate variant",
					variant,
					VARIANT__PROPERTIES
				)
			}
		}
	}
	
	@Check
	def checkModel(Model it) {
		if (weightDefined && weight <= 0) {
			error("Weight must be > 0",
				MODEL__WEIGHT
			)
		}
		if (x % 90 != 0) {
			error("x must be in increments of 90 degrees",
				MODEL__X
			)
		}
		if (y % 90 != 0) {
			error("y must be in increments of 90 degrees",
				MODEL__Y
			)
		}
	}
	
	@Check
	def checkModelList(ModelList it) {
		if (models.stream.anyMatch[weightDefined]) {
			if (models.size == 1) {
				warning("Weight is not necessary",
					models.get(0),
					MODEL__WEIGHT
				)
			} else {
				for (var i = 0; i < models.size; i++) {
					val model = models.get(i)
					if (!model.weightDefined) {
						warning("Model does not define a weight",
							MODEL_LIST__MODELS, i
						)
					}
				}
			}
		}
	}
	
	@Check
	def checkNoDuplicates(NormalBlockstatePropertyPredicate it) {
		val seenValues = <Integer>newSeenMap()
		for (var i = 0; i < values.size; i++) {
			val value = values.get(i)
			val info = seenValues.get(value)
			if (info === null) {
				seenValues.put(value, seen(i))
			} else {
				if (!info.errored) {
					info.errored = true
					error("Duplicate value",
						NORMAL_BLOCKSTATE_PROPERTY_PREDICATE__VALUES, info.value
					)
				}
				error("Duplicate value",
					NORMAL_BLOCKSTATE_PROPERTY_PREDICATE__VALUES, i
				)
			}
		}
	}
	
	@Check
	def checkNoDuplicates(BaseCaseCondition it) {
		val seenProperties = <BlockstatePropertyPredicate>newSeenMap()
		for (property : properties) {
			val info = seenProperties.get(property.name)
			if (info === null) {
				seenProperties.put(property.name, seen(property))
			} else {
				if (!info.errored) {
					info.errored = true
					error("Duplicate property",
						info.value,
						BLOCKSTATE_PROPERTY_PREDICATE__NAME
					)
				}
				error("Duplicate property",
					property,
					BLOCKSTATE_PROPERTY_PREDICATE__NAME
				)
			}
		}
	}
	
	
	def private static <T> seen(T value) { new SeenInfo(value) }
	
	def private static <T> newSeenMap() { new HashMap<String,SeenInfo<T>> }
	def private static <T> newSeenMap(int capacity) { new HashMap<String,SeenInfo<T>>(capacity) }
	
}

@FinalFieldsConstructor
@ToString
class SeenInfo<T> {
	public final T value	
	public boolean errored = false
}