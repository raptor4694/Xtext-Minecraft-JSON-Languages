/*
 * generated by Xtext 2.19.0
 */
package com.raptor.mcentity.validation

import com.raptor.mcentity.mcentity.*
import java.util.HashSet
import java.util.Map
import java.util.Set
import java.util.UUID
import java.util.function.Consumer
import java.util.function.Predicate
import java.util.regex.Matcher
import java.util.regex.Pattern
import org.eclipse.emf.common.util.EList
import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor
import org.eclipse.xtext.util.Strings
import org.eclipse.xtext.validation.Check

import static com.raptor.mcentity.mcentity.McentityPackage.Literals.*
import com.raptor.mcentity.validation.MCEntityValidator.Predicates.NBTValuePredicate
import com.raptor.mcentity.validation.MCEntityValidator.Predicates.IArrayPredicate
import com.google.common.collect.ImmutableMap
import org.eclipse.xtext.util.internal.Nullable
import org.eclipse.xtext.validation.ValidationMessageAcceptor
import com.google.common.collect.ImmutableSet
import java.util.HashMap
import java.util.concurrent.atomic.AtomicReference
import java.util.stream.Collectors
import com.google.inject.Inject

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MCEntityValidator extends AbstractMCEntityValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MCEntityPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Inject McentityFactory factory

	static val KEY_REGEX = Pattern.compile('''[-.a-z_0-9]+''')
	static val FOLDER_REGEX = Pattern.compile('''(?:«KEY_REGEX»(?:/«KEY_REGEX»)*)''')
	static val NAMESPACED_KEY_REGEX = Pattern.compile('''(?:(?<namespace>«KEY_REGEX»):)?(?<key>«KEY_REGEX»)''')
	static val NAMESPACED_FOLDER_REGEX = Pattern.compile('''(?:(?<namespace>«KEY_REGEX»):)?(?<key>«FOLDER_REGEX»)''')
	static val UUID_REGEX = Pattern.compile('''[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}''')
	static val TAG_REGEX = Pattern.compile('''[a-zA-Z_0-9]+''')

	@Check
	def checkEntityData(EntityData entityData) {
		checkEntityNBT(new NBTData(entityData.nbt))
	}
	
	@Check
	def checkNBT(NBTCompound nbt) {
		val keys = <String>newHashSet()
		for(entry : nbt.entries) {
			if(!keys.add(entry.key)) {
				error("Duplicate key",
					entry,
					NBT_ENTRY__KEY
				)
			}
		}
	}
	
	@Check
	def checkJSON(JSONObject json) {
		val keys = <String>newHashSet()
		for(entry : json.entries) {
			if(!keys.add(entry.key)) {
				error("Duplicate key",
					entry,
					JSON_ENTRY__KEY
				)
			}
		}
	}
	
	@Check
	def checkSelectorArguments(SelectorArguments args) {
		val keys = <String>newHashSet()
		for(filter : args.filters) {
			if(!keys.add(filter.name)) {
				error("Duplicate key",
					filter,
					SELECTOR_FILTER__NAME
				)
			}
		}
	}
	
//	def String duplicateKey(String key) '''Duplicate key "«key»"'''
	
//	def String unrecognizedKey(String key) '''Unrecognized key "«key»"'''
	
	private static class NBTData {
		public final NBTCompound nbt
		public final Map<String, NBTEntry> map
		public final HashSet<String> keys
		public final int index
		
		new(int index, NBTCompound nbt) {
			this.nbt = nbt
			this.map = nbt.toMap()
			this.keys = new HashSet(map.keySet)
			this.index = index
		}
		
		new(NBTCompound nbt) {
			this(ValidationMessageAcceptor.INSIGNIFICANT_INDEX, nbt)
		}
	}
	
	def checkEntityNBT(NBTData it, @Nullable EntityDef entityType) {
		checkNBTKeyIsVec3D("Pos")
		checkNBTKeyIsVec3D("Motion")
		checkNBTKey("Rotation", [ isVec2F && with(it as NBTArray) [ elements.get(0).isFloat(0f, 360.0f) && elements.get(1).isFloat(-90.0f, 90.0f) ] ], "Expected an array of floats [yaw, pitch]")
		checkNBTKey("FallDistance", predicates.isFloat.min(0.0f))
		checkNBTKey("Fire", predicates.isShort)
		checkNBTKey("Air", predicates.isShort.range(0, 300))
		checkNBTKeyIsBool("OnGround")
		checkNBTKeyIsBool("NoGravity")
		checkNBTKeyIsBool("Invulnerable")
		checkNBTKey("PortalCooldown", predicates.isInt.min(0))	
		checkNBTKeyIsLongExact("UUIDMost")
		checkNBTKeyIsLongExact("UUIDLeast")
		checkNBTKey("CustomName", [ it instanceof NBTJSONTextComponent || isString("") ], "Expected a JSON text component")
		checkNBTKeyIsBool("CustomNameVisible")
		checkNBTKeyIsBool("Silent")
		checkNBTKeyIsBool("Glowing")
		checkNBTKey("Tags", predicates.isArray.matching(predicates.isString)) [
			NBTArray it |
			for(var i = 0; i < elements.size; i++) {
				if(!TAG_REGEX.matcher((elements.get(i) as NBTString).value).matches()) {
					warning("The value contains characters other than [a-zA-Z_0-9]",
						it,
						NBT_ARRAY__ELEMENTS,
						i
					)
				}
			}
		]
		checkNBTKeyIsArrayOfObjects("Passengers", "Expected an array of entity tags") [
			checkEntityNBT()
		]
		entityType?.check(it)
		checkNoOtherKeys()
	}
	
	def checkEntityNBT(NBTData it) {
//		checkNBTKey("id", [ isValidEntity ], "Expected an entity id") [
//			NBTValue value |
//			val namespace = if(value instanceof NamespacedKey) value.namespace else "minecraft"
//			val key = if(value instanceof NamespacedKey) value.key else (value as NBTString).value
//			ALL_ENTITIES.get(namespace)?.get(key)?.check(it)
//		]
		val idEntry = map.get("id")
		val entityType = if(idEntry !== null) {
			val value = idEntry.value
			var String namespace
			var String key
			if(value instanceof NamespacedKey) {
				namespace = value.namespace
				key = value.key
			} else if(value.isStringMatching(NAMESPACED_KEY_REGEX)) {
				val str = (value as NBTString).value
				val i = str.indexOf(':')
				namespace = if(i == -1) "minecraft" else str.substring(0, i)
				key = str.substring(i+1)
			} else {
				error("Expected an entity id",
					idEntry,
					NBT_ENTRY__VALUE
				)
			}
			ALL_ENTITIES.get(namespace)?.get(key)
		}
		keys.remove("id")
		if(idEntry !== null && entityType === null) {
			warning("Unknown entity id",
				idEntry,
				NBT_ENTRY__VALUE
			)
		}
		checkEntityNBT(entityType)
	}
	
	def checkNoOtherKeys(NBTData it) {
		if(!keys.isEmpty) {
			val entries = nbt.entries
			for(var i = 0; i < entries.size; i++) {
				val key = entries.get(i).key
				if(keys.contains(key)) {
					warning("Unrecognized key",
						nbt,
						NBT_COMPOUND__ENTRIES,
						i
					)
				}
			}
		}
	}
	
	def getEntityInfo(NBTData it) {
		val id_nbt = map.get("id")
		if(id_nbt !== null) {
			val value = id_nbt.value
			val namespace = if(value instanceof NamespacedKey) value.namespace else "minecraft"
			val key = if(value instanceof NamespacedKey) value.key else (value as NBTString).value
			ALL_ENTITIES.get(namespace)?.get(key)
		}
	}
	
	def checkMobNBT(NBTData it) { checkMobNBT(false, false) }
	
	def checkMobNBT(NBTData it, boolean breedable, boolean tameable) {
		val entityInfo = getEntityInfo()
		checkNBTKey("Health", predicates.isFloat.min(0.0f))
		checkNBTKey("AbsorptionAmount", predicates.isFloat.min(0.0f))
		checkNBTKey("HurtTime", predicates.isShort.min(0))
		checkNBTKeyIsInt("HurtByTimestamp")
		checkNBTKey("DeathTime", predicates.isShort.min(0))
		checkNBTKeyIsBool("FallFlying")
		checkNBTKeyIsInt("SleepingX")
		checkNBTKeyIsInt("SleepingY")
		checkNBTKeyIsInt("SleepingZ")
		checkNBTKeyIsObject("Brain") [
			checkNBTKeyIsObject("memories") [
				val checker = [
					checkNBTKey("pos", predicates.isIntArray.size(3))
					checkNBTKey("dimension", predicates.isString.matching("(minecraft:)?(overworld|the_(nether|end))"), "Expected a dimension id")
					requiredKeys("pos", "dimension")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("minecraft:meeting_point", checker)
				checkNBTKeyIsObject("minecraft:home", checker)
				checkNBTKeyIsObject("minecraft:job_site", checker) 
				checkNoOtherKeys()
			]
			checkNoOtherKeys()
		]
		val attributes = entityInfo?.attributes ?: genericAttributes
		checkNBTKeyIsArrayOfObjects("Attributes","Expected an array of attributes") [
			checkNBTKey("Name", predicates.isString.equalTo(attributes))
			checkNBTKey("Base", predicates.isDouble.lenient(false))
			checkNBTKeyIsArrayOfObjects("Modifiers", predicates.isArray.minSize(1)) [
				checkNBTKey("Name", predicates.isString && !predicates.isString.equalTo(""))
				checkNBTKey("Amount", predicates.isDouble.lenient(false))
				checkNBTKey("Operation", predicates.isInt.range(0, 2), "Expected 0, 1, or 2")
				checkNBTKeyIsLongExact("UUIDMost")
				checkNBTKeyIsLongExact("UUIDLeast")
				requiredKeys("Amount", "Operation")
				checkNoOtherKeys()
			]
			requiredKeys("Name", "Base")
			checkNoOtherKeys()
		]
		checkNBTKeyIsArrayOfObjects("ActiveEffects", "Expected an array of potion effects") [
			checkNBTKey("Id", predicates.isByte.lenient(false) || predicates.wrap([ isValidEffect ], "an effect id")) [
				NBTValue nbt |
				if(nbt instanceof NBTString || nbt instanceof NamespacedKey) {
					var String namespace
					var String key
					switch nbt {
						NBTString: {
							val m = NAMESPACED_KEY_REGEX.matcher(nbt.value)
							if(!m.matches())
								throw new AssertionError
							namespace = m.group("namespace") ?: "minecraft"
							key = m.group("key")
						}
						NamespacedKey: {
							namespace = nbt.namespace
							key = nbt.key
						}
						default: throw new AssertionError
					}
					val newvalue = factory.createNBTByte()
					newvalue.value = POTION_EFFECTS.get(namespace + ':' + key).byteValue
					map.get("Id").value = newvalue
				}
			]
			checkNBTKey("Amplifier", predicates.isByte)
			checkNBTKey("Duration", predicates.isInt)
			checkNBTKeyIsBool("Ambient")
			checkNBTKeyIsBool("ShowParticles")
			checkNBTKeyIsBool("ShowIcon")
			requiredKeys("Id", "Amplifier", "Duration")
			checkNoOtherKeys()
		]
		checkNBTKeyIsArrayOfObjects("HandItems", predicates.isArray.size(2), "Expected an array of size 2 where the elements are items") [
			checkItemNBT(false)
		]
		checkNBTKeyIsArrayOfObjects("ArmorItems", predicates.isArray.size(4), "Expected an array of size 2 where the elements are items") [
			checkItemNBT(false)
		]
		checkNBTKeyIsArray("HandDropChances", predicates.isArray.size(2), predicates.isFloat.range(0.0f, 1.0f))
		checkNBTKeyIsArray("ArmorDropChances", predicates.isArray.size(4), predicates.isFloat.range(0.0f, 1.0f))
		checkNBTKey("DeathLootTable", [ isNamespacedLocation ], "Expected a loot table id")
		checkNBTKey("DeathLootTableSeed", predicates.isLong)
		checkNBTKeyIsBool("CanPickUpLoot")
		checkNBTKeyIsBool("NoAI")
		checkNBTKeyIsBool("PersistenceRequired")
		checkNBTKeyIsBool("LeftHanded")
		checkNBTKey("Team", predicates.isString && !predicates.isString.equalTo(""))
		checkNBTKeyIsBool("Leashed")
		checkNBTKeyIsObject("Leash") [
			checkNBTKeyIsLongExact("UUIDMost")
			checkNBTKeyIsLongExact("UUIDLeast")
			checkNBTKeyIsInt("X")
			checkNBTKeyIsInt("Y")
			checkNBTKeyIsInt("Z")
			requiredKeys("UUIDMost", "UUIDLeast", "X", "Y", "Z")
			checkNoOtherKeys()
		]
		
		if(breedable) {
			checkNBTKeyIsBool("InLove")
			checkNBTKeyIsInt("Age")
			checkNBTKeyIsInt("ForcedAge")
			checkNBTKeyIsLongExact("LoveCauseLeast")
			checkNBTKeyIsLongExact("LoveCauseMost")
		}
		
		if(tameable) {
			checkNBTKey("OwnerUUID", [ isUUID ], "Expected a UUID")
			checkNBTKeyIsBool("Sitting")
		}
	}
	
	def checkFishNBT(NBTData it) {
		checkMobNBT()
		checkNBTKeyIsBool("FromBucket")
	} 
	
	def checkBaseHorseNBT(NBTData it) {
		checkMobNBT(true, false)
		checkNBTKeyIsBool("Bred")
		checkNBTKeyIsBool("EatingHaystack")
		checkNBTKeyIsBool("Tame")
		checkNBTKey("OwnerUUID", [ isUUID ], "Expected a UUID")
	}
	
	def checkRaiderNBT(NBTData it) {
		checkMobNBT()
		checkNBTKeyIsBool("HasRaidGoal")
		checkNBTKeyIsBool("Patrolling")
		checkNBTKeyIsBool("PatrolLeader")
		checkNBTKeyIsBool("PatrolTarget")
		checkNBTKeyIsObject("PatrolTarget") [
			checkNBTKeyIsInt("X")
			checkNBTKeyIsInt("Y")
			checkNBTKeyIsInt("Z")
			requiredKeys("X", "Y", "Z")
			checkNoOtherKeys()
		]
		checkNBTKeyIsInt("RaidId")
		checkNBTKeyIsInt("Wave")
	}
	
	def checkZombieNBT(NBTData it) {
		checkMobNBT()
		checkNBTKeyIsBool("IsBaby")
		checkNBTKeyIsBool("CanBreakDoors")
		checkNBTKeyIsInt("DrownedConversionTime")
		checkNBTKeyIsInt("InWaterTime")
	}
	
	def checkVillagerNBT(NBTData it) {
		checkNBTKeyIsObject("VillagerData") [
			checkNBTKeyIsInt("level")
			checkNBTKey("profession", [ isValidProfession ], "Expected a villager profession")
			checkNBTKey("type", [ isValidVillagerType ], "Expected a villager type")
			requiredKeys("level", "profession", "type")
			checkNoOtherKeys()
		]
		checkNBTKeyIsArrayOfObjects("Gossips") [
			checkNBTKey("Type", predicates.isString.equalTo(GOSSIP_TYPES))
			checkNBTKeyIsInt("Value")
			checkNBTKeyIsLongExact("TargetMost")
			checkNBTKeyIsLongExact("TargetLeast")
			requiredKeys("Type", "Value", "TargetMost", "TargetLeast")
			checkNoOtherKeys()
		]
		checkTraderOffersNBT()
	}
	
	def checkTraderOffersNBT(NBTData it) {
		checkNBTKeyIsObject("Offers") [
			checkNBTKeyIsArrayOfObjects("Recipes") [
				checkNBTKeyIsBool("rewardExp")
				checkNBTKey("maxUses", predicates.isInt.min(0))
				checkNBTKey("uses", predicates.isInt.min(0))
				checkNBTKeyIsObject("buy") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("buyB") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("sell") [
					checkItemNBT(false)
				]
				checkNBTKeyIsInt("xp")
				checkNBTKey("priceMultiplier", predicates.isFloat)
				checkNBTKeyIsInt("specialPrice")
				checkNBTKeyIsInt("demand")
				requiredKeys("buy", "buyB", "sell", "maxUses")
				checkNoOtherKeys()
			]
			requiredKeys("Recipes")
			checkNoOtherKeys()
		]
	}

	def checkProjectileNBT(NBTData it) {
		checkNBTKeyIsInt("xTile")
		checkNBTKeyIsInt("yTile")
		checkNBTKeyIsInt("zTile")
		checkNBTKeyIsBlockstate("inBlockState")
		checkNBTKeyIsByte("shake")
	}
	
	def checkPotionNBT(NBTData it) {
		checkNBTKey("CustomPotionColor", predicates.isInt.range(0, 0xFFFFFF))
		checkNBTKeyIsArrayOfObjects("CustomPotionEffects") [
			checkNBTKey("Id", predicates.isInt.range(1, 32))
			checkNBTKeyIsByte("Amplifier")
			checkNBTKeyIsInt("Duration")
			checkNBTKeyIsBool("Ambient")
			checkNBTKeyIsBool("ShowParticles")
			checkNBTKeyIsBool("ShowIcon")
		]
		checkNBTKey("Potion", predicates.isString.equalTo(DEFAULT_POTION_TYPES))
	}
	
	def checkMinecartNBT(NBTData it) {
		checkNBTKeyIsBool("CustomDisplayTile")
		checkNBTKeyIsBlockstate("DisplayState")
		checkNBTKeyIsInt("DisplayOffset")
	}
	
	def checkLootableNBT(NBTData it) {
		checkNBTKey("LootTable", [ isNamespacedLocation ], "Expected a loot table id")
		checkNBTKeyIsLong("LootTableSeed")
	}
	
	def checkCommandBlockNBT(NBTData it) {
		checkNBTKey("Command", predicates.isString)
		checkNBTKeyIsInt("SuccessCount")
		checkNBTKey("LastOutput", predicates.isString)
		checkNBTKeyIsBool("TrackOutput")
	}
	
	def checkSpawnerNBT(NBTData it) {
		checkNBTKeyIsArrayOfObjects("SpawnPotentials") [
			checkNBTKeyIsObject("Entity") [
				checkEntityNBT()
			]
			checkNBTKey("Weight", predicates.isInt.min(1))
		]
		checkNBTKeyIsObject("SpawnData") [
			checkEntityNBT()
		]
		checkNBTKey("SpawnCount", predicates.isShort.min(1))
		checkNBTKey("SpawnRange", predicates.isShort.min(0))
		checkNBTKey("Delay", predicates.isShort)
		checkNBTKey("MinSpawnDelay", predicates.isShort.min(0))
		checkNBTKey("MaxSpawnDelay", predicates.isShort.min(1))
		checkNBTKey("MaxNearbyEntities", predicates.isShort.min(0))
		checkNBTKey("RequiredPlayerRange", predicates.isShort.min(0))
	}
	
	def checkNBTKeyIsBlockstate(NBTData it, String keyIn) {
		checkNBTKeyIsBlockstate(keyIn, null as NBTData)
	}
	
	def checkNBTKeyIsBlockstate(NBTData it, String keyIn, @Nullable NBTData tileEntityData) {
		checkNBTKeyIsObject(keyIn) [
			checkNBTKeyIsObject("Properties") [
				for(key : map.keySet) {
					checkNBTKey(key, predicates.isString)
				}
			]
			checkNBTKey("Name", [ isValidBlock ], "Expected a block id", "Unknown block id") [
				NBTValue value |
				var String namespace
				var String key
				switch value {
					NBTString: {
						val m = NAMESPACED_KEY_REGEX.matcher(value.value)
						if(!m.matches())
							throw new AssertionError
						namespace = m.group("namespace") ?: "minecraft"
						key = m.group("key")
					}
					NamespacedKey: {
						namespace = value.namespace
						key = value.key
					}
					default: throw new AssertionError
				}
				val blockDef = ALL_BLOCKS.get(namespace)?.get(key)					
				if(map.containsKey("Properties")) {
					val properties = <String, String>newHashMap()
					val propsVal = map.get("Properties").value as NBTCompound
					for(entry : propsVal.entries) {
						properties.put(entry.key, (entry.value as NBTString).value)
					}
					val map2 = propsVal.toMap()
					blockDef.checkProperties(properties) [
						key2, msg |
						error(msg,
							map2.get(key2),
							NBT_ENTRY__KEY
						)
					]
				}
				if(tileEntityData !== null)
					blockDef.check(tileEntityData)	
			]
			requiredKeys("Name")
			checkNoOtherKeys()
		]
	}
	
	def checkNBTKeyIsBlockstate(NBTData it, String keyIn, @Nullable BlockDef blockDef) {
		checkNBTKeyIsObject(keyIn) [
			for(key : map.keySet) {
				checkNBTKey(key, predicates.isString)
			}
			val properties = <String, String>newHashMap()
			val propsVal = map.get("Properties").value as NBTCompound
			for(entry : propsVal.entries) {
				properties.put(entry.key, (entry.value as NBTString).value)
			}
			blockDef.checkProperties(properties) [
				key2, msg |
				error(msg,
					map.get(key2),
					NBT_ENTRY__KEY
				)
			]
		]
	}
	
	def checkItemNBT(NBTData it, boolean slot) {
		println("TEST0")
		if(map.isEmpty)
			return;
		checkNBTKey("tag", predicates.isObject)
		checkNBTKey("Count", predicates.isByte)
		checkNBTKey("id", [ isValidItem ], "Expected an item id", "Unknown item id") [
			NBTValue value |
			println("TEST1")
			var String namespace
			var String key
			switch value {
				NBTString: {
					val m = NAMESPACED_KEY_REGEX.matcher(value.value)
					if(!m.matches())
						throw new AssertionError
					namespace = m.group("namespace") ?: "minecraft"
					key = m.group("key")
				}
				NamespacedKey: {
					namespace = value.namespace
					key = value.key
				}
				default: throw new AssertionError
			}
			val itemDef = ALL_ITEMS.get(namespace)?.get(key)
			if(map.containsKey("tag")) {
				println("TEST")
				checkItemStackNBT(new NBTData(map.get("tag").value as NBTCompound), itemDef)
			}
			if(map.containsKey("Count")) {
				val countEntry = map.get("Count")
				val size = switch countValue : countEntry.value {
					NBTByte: countValue.value
					NBTInt: countValue.value
					default: throw new AssertionError
				}
				if(size > itemDef.maxStackSize) {
					warning("Count is greater than the item's max stack size",
						countEntry,
						NBT_ENTRY__VALUE
					)
				}
			}
		]
		if(!map.containsKey("id") && map.containsKey("tag")) {
			checkItemStackNBT(new NBTData(map.get("tag").value as NBTCompound), null)
		}
		requiredKeys("id", "Count")
		if(slot) {
			checkNBTKeyIsInt("Slot")
			requiredKeys("Slot")
		}
		checkNoOtherKeys()
	}
	
	def checkItemStackNBT(NBTData it) {
		checkItemStackNBT(it, null)
	}
	
	def checkItemStackNBT(NBTData it, ItemDef itemDef) {
//		checkNBTKey("CanDestroy", predicates.isArray.matching(predicates.wrap([isValidBlock], "a block id")))
		checkNBTKeyIsArray("CanDestroy") [
			NBTValue nbt, int index |
			switch(isValidBlock(nbt)) {
				case YES: {}
				case NO: error("Expected a block id",
					map.get("CanDestroy").value,
					NBT_ARRAY__ELEMENTS,
					index
				)
				case MAYBE: warning("Unknown block id",
					map.get("CanDestroy").value,
					NBT_ARRAY__ELEMENTS,
					index
				)
			}
		]
		checkNBTKeyIsInt("CustomModelData")
		checkNBTKeyIsArrayOfObjects("Enchantments") [
			checkEnchantmentNBT()
		]
		checkNBTKeyIsInt("RepairCost")
		checkNBTKeyIsArrayOfObjects("AttributeModifiers") [
			checkNBTKey("AttributeName", predicates.isString.equalTo(allAttributes))
			checkNBTKey("Name", predicates.isString.equalTo(allAttributes))
			checkNBTKey("Slot", predicates.isString.equalTo("mainhand", "offhand", "feet", "legs", "chest", "head"))
			checkNBTKey("Operation", predicates.isInt.range(0, 2))
			checkNBTKey("Amount", predicates.isDouble.lenient(false))
			checkNBTKeyIsLongExact("UUIDMost")
			checkNBTKeyIsLongExact("UUIDLeast")
		]
		checkNBTKeyIsObject("display") [
			checkNBTKey("Name", [ it instanceof NBTJSONTextComponent ], "Expected a JSON text component")
			checkNBTKey("Lore", predicates.isArray.matching(predicates.wrap([ it instanceof NBTJSONTextComponent], "a JSON text component")))
			checkNBTKey("color", predicates.isInt)
			checkNBTKey("MapColor", predicates.isInt)
		]
		itemDef?.check(it)
	}
	
	def checkEnchantmentNBT(NBTData it) {
		checkNBTKey("id", [ isValidEnchantment ], "Expected an enchantment id")
		checkNBTKey("lvl", predicates.isInt || predicates.isShort)
		requiredKeys("id", "lvl")
		checkNoOtherKeys()
	}
	
	def checkDamageableItemStackNBT(NBTData it) {
		checkNBTKeyIsInt("Damage")
		checkNBTKeyIsBool("Unbreakable")
	
	}
	
	def checkFireworksNBT(NBTData it) {
		checkNBTKeyIsObject("Fireworks") [
			checkNBTKeyIsByte("Flight")
			checkNBTKeyIsArrayOfObjects("Explosions") [
				checkFireworkExplosionNBT()
			]
		]
	}
	
	def checkFireworkExplosionNBT(NBTData it) {
		checkNBTKeyIsBool("Flicker")
		checkNBTKeyIsBool("Trail")
		checkNBTKey("Type", predicates.isByte.range(0, 4))
		checkNBTKey("Colors", predicates.isArray.matching(predicates.isInt))
		checkNBTKey("FadeColors", predicates.isArray.matching(predicates.isInt))
	}
	
	def checkBookPagesNBT(NBTData it) {
		checkNBTKey("pages", predicates.isArray.matching(predicates.isString || predicates.wrap([it instanceof NBTJSONTextComponent], "a JSON text component")))
	}
	
	def checkBlockItemStackNBT(NBTData it) {
//		checkNBTKey("CanPlaceOn", predicates.isArray.matching(predicates.wrap([isValidBlock], "a block id")))
		checkNBTKeyIsArray("CanPlaceOn") [
			NBTValue nbt, int index |
			switch(isValidBlock(nbt)) {
				case YES: {}
				case NO: error("Expected a block id",
					map.get("CanPlaceOn").value,
					NBT_ARRAY__ELEMENTS,
					index
				)
				case MAYBE: warning("Unknown block id",
					map.get("CanPlaceOn").value,
					NBT_ARRAY__ELEMENTS,
					index
				)
			}
		]
	}
	
	def static <I,O> with(I obj, (I)=>O mapper) {
		mapper.apply(obj)
	}
	
	def checkNBTKey(NBTData it, String key, Predicate<? super NBTValue> predicate, String errorMsg) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			if(!predicate.test(entry.value)) {
				error(errorMsg, entry, NBT_ENTRY__VALUE)	
			}
		}
	}
	
	def <T extends NBTValue> checkNBTKey(NBTData it, String key, Predicate<? super NBTValue> predicate, String errorMsg, Consumer<T> callback) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			if(predicate.test(entry.value)) {
				callback.accept(entry.value as T)
			} else {
				error(errorMsg, entry, NBT_ENTRY__VALUE)	
			}
		}
	}
	
	def checkNBTKey(NBTData it, String key, NBTValuePredicate predicate) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			if(!predicate.test(entry.value)) {
				error("Expected " + predicate.expected, entry, NBT_ENTRY__VALUE)	
			}
		}
	}
	
	def <T extends NBTValue> checkNBTKey(NBTData it, String key, NBTValuePredicate predicate, Consumer<T> callback) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			if(predicate.test(entry.value)) {
				callback.accept(entry.value as T)
			} else {
				error("Expected " + predicate.expected, entry, NBT_ENTRY__VALUE)	
			}
		}
	}
	
	def checkNBTKey(NBTData it, String key, NBTValuePredicate predicate, String errorMsg) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			if(!predicate.test(entry.value)) {
				error(errorMsg, entry, NBT_ENTRY__VALUE)	
			}
		}
	}
	
	def <T extends NBTValue> checkNBTKey(NBTData it, String key, NBTValuePredicate predicate, String errorMsg, Consumer<T> callback) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			if(predicate.test(entry.value)) {
				callback.accept(entry.value as T)
			} else {
				error(errorMsg, entry, NBT_ENTRY__VALUE)	
			}
		}
	}
	
	def checkNBTKeyIsObject(NBTData maks, String key) {
		checkNBTKey(maks, key, predicates.isObject)
	}
	
	def checkNBTKeyIsObject(NBTData maks, String key, Consumer<NBTData> callback) {
		checkNBTKey(maks, key, predicates.isObject) [
			NBTCompound nbt | callback.accept(new NBTData(nbt))
		]
	}
	
	def checkNBTKeyIsArrayOfObjects(NBTData maks, String key, Consumer<NBTData> callback) {
		checkNBTKey(maks, key, predicates.isArray.matching(predicates.isObject)) [
			NBTArray array |
			val elements = array.elements
			for(var i = 0; i < elements.size; i++) {
				callback.accept(new NBTData(i, elements.get(i) as NBTCompound))
			}
		]
	}	
	
	def checkNBTKeyIsArrayOfObjects(NBTData maks, String key, String errorMsg, Consumer<NBTData> callback) {
		checkNBTKey(maks, key, predicates.isArray.matching(predicates.isObject), errorMsg) [
			NBTArray array |
			val elements = array.elements
			for(var i = 0; i < elements.size; i++) {
				callback.accept(new NBTData(i, elements.get(i) as NBTCompound))
			}
		]
	}	
	
	def checkNBTKeyIsArrayOfObjects(NBTData maks, String key, IArrayPredicate predicate, String errorMsg, Consumer<NBTData> callback) {
		checkNBTKey(maks, key, predicate && predicates.isArray.matching(predicates.isObject), errorMsg) [
			NBTArray array |
			val elements = array.elements
			for(var i = 0; i < elements.size; i++) {
				callback.accept(new NBTData(i, elements.get(i) as NBTCompound))
			}
		]
	}
	
	def checkNBTKeyIsArrayOfObjects(NBTData maks, String key, IArrayPredicate predicate, Consumer<NBTData> callback) {
		checkNBTKey(maks, key, predicate && predicates.isArray.matching(predicates.isObject)) [
			NBTArray it |
			for(element : elements) {
				callback.accept(new NBTData(element as NBTCompound))
			}
		]
	}
	
	def <T extends NBTValue> checkNBTKeyIsArray(NBTData maks, String key, (T,int)=>void callback) {
		checkNBTKey(maks, key, predicates.isArray) [
			NBTArray array |
			val elements = array.elements
			for(var i = 0; i < elements.size; i++) {
				callback.apply(elements.get(i) as T, i)
			}
		]
	}
	
	def checkNBTKeyIsArray(NBTData maks, String key, IArrayPredicate predicate, NBTValuePredicate elementPredicate) {
		checkNBTKey(maks, key, predicate) [
			NBTArray it |
			for(var i = 0; i < elements.size; i++) {
				val element = elements.get(i)
				if(!elementPredicate.test(element)) {
					error("Expected " + elementPredicate.expected,
						it,
						element.eContainingFeature,
						i
					)
				}
			}
		]
	}
	
	
	
	def checkNBTKeyIsVec3D(NBTData maks, String key) {
		checkNBTKey(maks, key, [ isVec3D ], "Expected an array of 3 doubles")
	}
	
	def checkNBTKeyIsBool(NBTData maks, String key) {
		checkNBTKey(maks, key, predicates.isBool)
	}
	
	def checkNBTKeyIsByte(NBTData maks, String key) {
		checkNBTKey(maks, key, predicates.isByte)
	}
	
	def checkNBTKeyIsInt(NBTData maks, String key) {
		checkNBTKey(maks, key, predicates.isInt)
	}
	
	def checkNBTKeyIsLong(NBTData maks, String key) {
		checkNBTKey(maks, key, predicates.isLong)
	}
	
	def checkNBTKeyIsLongExact(NBTData maks, String key) {
		checkNBTKey(maks, key, predicates.isLong.lenient(false))
	}
	
	def checkNBTKey(NBTData it, String key, (NBTValue)=>Possibility tester, String errorMsg, String warningMsg) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			switch(tester.apply(entry.value)) {
				case MAYBE: warning(warningMsg, entry, NBT_ENTRY__VALUE)
				case NO: error(errorMsg, entry, NBT_ENTRY__VALUE)
			}
		}
	}
	
	def <T extends NBTValue> checkNBTKey(NBTData it, String key, (NBTValue)=>Possibility tester, String errorMsg, String warningMsg, Consumer<T> callback) {
		val entry = map.get(key)
		if(entry !== null) {
			keys.remove(key)
			switch(tester.apply(entry.value)) {
				case MAYBE: { warning(warningMsg, entry, NBT_ENTRY__VALUE); callback.accept(entry.value as T) }
				case NO: error(errorMsg, entry, NBT_ENTRY__VALUE)
				case YES: callback.accept(entry.value as T)
			}
		}
	}
	
	def requiredKeys(NBTData it, String... requiredKeys) {
		val missingKeys = newHashSet(requiredKeys)
		
//		println('''missingKeys[in]: «missingKeys»''')
//		missingKeys.removeIf[ key | map.containsKey(key) ]
//		println(map.keySet)
//		println('''missingKeys[out]: «missingKeys»''')

		missingKeys.removeAll(map.keySet)

		if(!missingKeys.isEmpty)
			error('''Missing required key«s(missingKeys.size)» «FOR key : missingKeys SEPARATOR ','»«key»«ENDFOR»''', 
				nbt.eContainer, 
				nbt.eContainingFeature,
				index
			)
	}
	
	static val genericAttributes = #{"generic.maxHealth", "generic.followRange", "generic.knockbackResistance", "generic.movementSpeed", "generic.attackDamage", "generic.armor", "generic.armorToughness", "generic.attackKnockback", "generic.attackSpeed", "generic.luck"}
	static val horseAttributes = ImmutableSet.copyOf(genericAttributes + #{"horse.jumpStrength"})
	static val parrotAttributes = ImmutableSet.copyOf(genericAttributes + #{"generic.flyingSpeed"})
	static val zombieAttributes = ImmutableSet.copyOf(genericAttributes + #{"zombie.spawnReinforcements"})
	static val allAttributes = ImmutableSet.copyOf(genericAttributes + #{"horse.jumpStrength", "generic.flyingSpeed", "zombie.spawnReinforcements"})
	
	static class EntityDef {
		val (NBTData)=>void checker
		val Set<String> attributes
		public var hasSpawnEgg = false
		
		new() {
			this(false, #{})[]
		}
		
		new(boolean hasSpawnEgg) {
			this(hasSpawnEgg, if(hasSpawnEgg) genericAttributes else #{})[]
		}
		
		new(boolean hasSpawnEgg, (NBTData)=>void checker) {
			this(hasSpawnEgg, if(hasSpawnEgg) genericAttributes else #{}, checker)
		}
		
		new((NBTData)=>void checker) {
			this(true, genericAttributes, checker)
		}
		
		new(boolean hasSpawnEgg, Set<String> attributes, (NBTData)=>void checker) {
			this.attributes = attributes
			this.checker = checker
			this.hasSpawnEgg = hasSpawnEgg
		}
		
		def hasSpawnEgg(boolean hasSpawnEgg) {
			this.hasSpawnEgg = hasSpawnEgg
			return this
		}
		
		def check(NBTCompound nbt) {
			check(new NBTData(nbt))
		}
		
		def check(NBTData maks) {
			checker.apply(maks)
		}
		
		def getAttributes() { attributes.unmodifiableView }
		
	}
	
	def toItem(EntityDef entity) {
		new ItemDef [
			checkNBTKeyIsObject("EntityTag") [
				checkEntityNBT(entity)
			]
		]
	}
	
	val DEFAULT_ENTITY_DEF = new EntityDef
	val DEFAULT_MOB_DEF = new EntityDef(true) [ checkMobNBT() ]
	val DEFAULT_BREEDABLE_MOB_DEF = new EntityDef(true) [ checkMobNBT(true, false) ]
	val DEFAULT_TAMEABLE_MOB_DEF = new EntityDef(true) [ checkMobNBT(false, true) ]
	val DEFAULT_BREEDABLE_TAMEABLE_MOB_DEF = new EntityDef(true) [ checkMobNBT(true, true) ]
	val DEFAULT_FISH_MOB_DEF = new EntityDef(true) [ checkFishNBT() ]
	
	val Map<String, Map<String, EntityDef>> ALL_ENTITIES = #{
		"minecraft" -> #{
			"bat" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsBool("BatFlags")
			],
			"blaze" -> DEFAULT_MOB_DEF,
			"cat" -> new EntityDef(true) [
				checkMobNBT(true, true)
				checkNBTKey("CatType", predicates.isInt.range(0, 10))
				checkNBTKey("CollarColor", predicates.isByte.range(0, 15))
			],
			"cave_spider" -> DEFAULT_MOB_DEF,
			"chicken" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKeyIsBool("IsChickenJockey")
				checkNBTKey("EggLayTime", predicates.isInt.min(0))
			],
			"cod" -> DEFAULT_FISH_MOB_DEF,
			"cow" -> DEFAULT_TAMEABLE_MOB_DEF,
			"creeper" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsBool("powered")
				checkNBTKey("ExplosionRadius", predicates.isByte.min(0))
				checkNBTKey("Fuse", predicates.isShort.min(0))
				checkNBTKeyIsBool("ignited")
			],
			"dolphin" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsInt("TreasurePosX")
				checkNBTKeyIsInt("TreasurePosY")
				checkNBTKeyIsInt("TreasurePosZ")
				checkNBTKeyIsBool("GotFish")
				checkNBTKeyIsBool("CanFindTreasure")
			],
			"donkey" -> new EntityDef(true, horseAttributes) [
				checkBaseHorseNBT()
				checkNBTKeyIsObject("ArmorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("SaddleItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsBool("ChestedHorse")
				checkNBTKeyIsArrayOfObjects("Items") [
					checkItemNBT(true)
				]
			],
			"drowned" -> new EntityDef(true, zombieAttributes) [
				checkZombieNBT()
			],
			"elder_guardian" -> DEFAULT_MOB_DEF,
			"ender_dragon" -> new EntityDef(false, genericAttributes) [
				checkNBTKey("DragonPhase", predicates.isInt.range(0, 10))
			],
			"enderman" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsBlockstate("carriedBlockstate")
			],
			"endermite" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKey("Lifetime", predicates.isInt.range(0, 2400))
				checkNBTKeyIsBool("PlayerSpawned")
			],
			"evoker" -> new EntityDef(true) [
				checkRaiderNBT()
				checkNBTKey("SpellTicks", predicates.isInt.min(0))
			],
			"fox" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKeyIsArrayOfObjects("TrustedUUIDs") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsBool("Sleeping")
				checkNBTKey("Type", predicates.isString.equalTo("red", "snow"))
				checkNBTKeyIsBool("Sitting")
				checkNBTKeyIsBool("Crouching")
			],
			"ghast" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsInt("ExplosionPower")
			],
			"giant" -> new EntityDef(false, genericAttributes) [
				checkMobNBT()
			],
			"guardian" -> DEFAULT_MOB_DEF,
			"horse" -> new EntityDef(true, horseAttributes) [
				checkBaseHorseNBT()
				checkNBTKeyIsObject("ArmorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("SaddleItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsBool("ChestedHorse")
				checkNBTKey("Temper", predicates.isInt.range(0, 100))
				checkNBTKeyIsInt("Variant")
			],
			"husk" -> new EntityDef(true, zombieAttributes) [
				checkZombieNBT()
			],
			"illusioner" -> new EntityDef(false, genericAttributes) [
				checkRaiderNBT()
				checkNBTKey("SpellTicks", predicates.isInt.min(0))
			],
			"iron_golem" -> new EntityDef(false, genericAttributes) [
				checkMobNBT()
				checkNBTKeyIsBool("PlayerCreated")
			],
			"llama" -> new EntityDef(true) [
				checkBaseHorseNBT()
				checkNBTKey("Temper", predicates.isInt.range(0, 100))
				checkNBTKey("Variant", predicates.isInt.range(0, 3))
				checkNBTKey("Strength", predicates.isInt.range(1, 5))
				checkNBTKeyIsObject("DecorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsArrayOfObjects("Items") [
					checkItemNBT(true)
				]
			],
			"magma_cube" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKey("Size", predicates.isInt.min(0))
				checkNBTKeyIsBool("wasOnGround")
			],
			"mooshroom" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKey("Type", predicates.isString.equalTo("red", "brown"))
				checkNBTKeyIsByte("EffectId")
				checkNBTKeyIsInt("EffectDuration")
			],
			"mule" -> new EntityDef(true) [
				checkBaseHorseNBT()
				checkNBTKey("Temper", predicates.isInt.range(0, 100))
				checkNBTKeyIsObject("ArmorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("SaddleItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsBool("ChestedHorse")
				checkNBTKeyIsArrayOfObjects("Items") [
					checkItemNBT(true)
				]
			],
			"ocelot" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKeyIsBool("Trusting")
			],
			"panda" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKey("MainGene", predicates.isString.equalTo(PANDA_GENES))
				checkNBTKey("HiddenGene", predicates.isString.equalTo(PANDA_GENES))
			],
			"parrot" -> new EntityDef(true, parrotAttributes) [
				checkMobNBT(false, true)
				checkNBTKey("Variant", predicates.isInt.range(0, 4))
			],
			"phantom" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsInt("AX")
				checkNBTKeyIsInt("AY")
				checkNBTKeyIsInt("AZ")
				checkNBTKey("Size", predicates.isInt.range(0, 64))
			],
			"pig" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKeyIsBool("Saddle")
			],
			"pillager" -> new EntityDef(true) [
				checkRaiderNBT()
				checkNBTKey("Inventory", predicates.isArray)
			],
			"polar_bear" -> DEFAULT_TAMEABLE_MOB_DEF,
			"pufferfish" -> new EntityDef(true) [
				checkFishNBT()
				checkNBTKey("PuffState", predicates.isInt.range(0, 2))
			],
			"rabbit" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKey("RabbitType", predicates.isInt.range(0, 5) || predicates.isInt.exact(99))
				checkNBTKey("MoreCarrotTicks", predicates.isInt.min(0))
			],
			"ravager" -> new EntityDef(true) [
				checkRaiderNBT()
				checkNBTKeyIsInt("AttackTick")
				checkNBTKeyIsInt("RoarTick")
				checkNBTKeyIsInt("StunTick")
			],
			"salmon" -> DEFAULT_FISH_MOB_DEF,
			"sheep" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKeyIsBool("Sheared")
				checkNBTKey("Color", predicates.isByte.range(0, 0xFFFFFF))
			],
			"shulker" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsByte("Peek")
				checkNBTKey("AttachFace", predicates.isByte.range(0, 5))
				checkNBTKey("Color", predicates.isByte.range(0, 16))
				checkNBTKeyIsInt("APX")
				checkNBTKeyIsInt("APY")
				checkNBTKeyIsInt("APZ")
			],
			"silverfish" -> DEFAULT_MOB_DEF,
			"skeleton" -> DEFAULT_MOB_DEF,
			"skeleton_horse" -> new EntityDef(true) [
				checkBaseHorseNBT()
				checkNBTKey("Temper", predicates.isInt.range(0, 100))
				checkNBTKeyIsObject("ArmorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("SaddleItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsBool("SkeletonTrap")
				checkNBTKey("SkeletonTrapTime", predicates.isInt.max(18000))
			],
			"slime" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKey("Size", predicates.isInt.min(0))
				checkNBTKeyIsBool("wasOnGround")
			],
			"snow_golem" -> new EntityDef(false, genericAttributes) [
				checkMobNBT()
				checkNBTKeyIsBool("Pumpkin")
			],
			"spider" -> DEFAULT_MOB_DEF,
			"squid" -> DEFAULT_MOB_DEF,
			"stray" -> DEFAULT_MOB_DEF,
			"trader_llama" -> new EntityDef(true) [
				checkBaseHorseNBT()
				checkNBTKey("Temper", predicates.isInt.range(0, 100))
				checkNBTKey("Variant", predicates.isInt.range(0, 3))
				checkNBTKey("Strength", predicates.isInt.range(1, 5))
				checkNBTKeyIsObject("DecorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsArrayOfObjects("Items") [
					checkItemNBT(true)
				]
				checkNBTKeyIsInt("DespawnDelay")
			],
			"tropical_fish" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsBool("FromBucket")
				checkNBTKey("Variant", predicates.isInt.range(0, 0xFFFF))
			],
			"turtle" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkNBTKeyIsBool("HasEgg")
				checkNBTKeyIsInt("HomePosX")
				checkNBTKeyIsInt("HomePosY")
				checkNBTKeyIsInt("HomePosZ")
				checkNBTKeyIsInt("TravelPosX")
				checkNBTKeyIsInt("TravelPosY")
				checkNBTKeyIsInt("TravelPosZ")
			],
			"vex" -> new EntityDef(true) [
				checkMobNBT()
				checkNBTKeyIsInt("BoundX")
				checkNBTKeyIsInt("BoundY")
				checkNBTKeyIsInt("BoundZ")
				checkNBTKey("LifeTicks", predicates.isInt.min(0))
			],
			"villager" -> new EntityDef(true) [
				checkMobNBT(true, false)
				checkVillagerNBT()
				checkNBTKeyIsBool("Willing")
				checkNBTKeyIsLong("LastRestock")
				checkNBTKeyIsLong("LastGossipDecay")
				checkNBTKey("ResocksToday", predicates.isInt.min(0))
				checkNBTKeyIsInt("Xp")
				checkNBTKeyIsArrayOfObjects("Inventory", predicates.isArray.rangeSize(0, 8)) [
					checkItemNBT(true)
				]
			],
			"vindicator" -> new EntityDef(true) [
				checkRaiderNBT()
				checkNBTKeyIsBool("Johnny")
			],
			"wandering_trader" -> new EntityDef(true) [
				checkNBTKeyIsInt("DespawnDelay")
				checkNBTKeyIsObject("WanderTarget") [
					checkNBTKeyIsInt("X")
					checkNBTKeyIsInt("Y")
					checkNBTKeyIsInt("Z")
					requiredKeys("X", "Y", "Z")
					checkNoOtherKeys()
				]
				checkTraderOffersNBT()
			],
			"witch" -> new EntityDef(true) [
				checkRaiderNBT()
			],
			"wither" -> new EntityDef(false, genericAttributes) [
				checkMobNBT()
				checkNBTKey("Invul", predicates.isInt.min(0))	
			],
			"wither_skeleton" -> DEFAULT_MOB_DEF,
			"wolf" -> new EntityDef(true) [
				checkMobNBT(true, true)
				checkNBTKeyIsBool("Angry")
				checkNBTKey("CollarColor", predicates.isByte.range(0, 15))
			],
			"zombie" -> new EntityDef(true, zombieAttributes) [
				checkZombieNBT()
			],
			"zombie_horse" -> new EntityDef(true) [
				checkBaseHorseNBT()
				checkNBTKey("Temper", predicates.isInt.range(0, 100))
				checkNBTKeyIsObject("ArmorItem") [
					checkItemNBT(false)
				]
				checkNBTKeyIsObject("SaddleItem") [
					checkItemNBT(false)
				]
			],
			"zombie_pigman" -> new EntityDef(true, zombieAttributes) [
				checkZombieNBT()
				checkNBTKey("Anger", predicates.isShort)
				checkNBTKey("HurtBy", [ isUUID ], "Expected a UUID")
			],
			"zombie_villager" -> new EntityDef(true, zombieAttributes) [
				checkZombieNBT()
				checkVillagerNBT()
				checkNBTKeyIsInt("ConversionTime")
				checkNBTKeyIsLongExact("ConversionPlayerLeast")
				checkNBTKeyIsLongExact("ConversionPlayerMost")
			],
			"arrow" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKey("pickup", predicates.isByte.range(0, 2))
				checkNBTKeyIsBool("player")
				checkNBTKey("life", predicates.isShort)
				checkNBTKey("damage", predicates.isDouble)
				checkNBTKeyIsBool("inGround")
				checkNBTKeyIsBool("crit")
				checkNBTKeyIsBool("ShotFromCrossbow")
				checkNBTKeyIsByte("PierceLevel")
				checkNBTKey("SoundEvent", predicates.isString && !predicates.isString.equalTo(""))
				checkNBTKeyIsLongExact("OwnerUUIDMost")
				checkNBTKeyIsLongExact("OwnerUUIDLeast")
			],
			"tipped_arrow" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKey("pickup", predicates.isByte.range(0, 2))
				checkNBTKeyIsBool("player")
				checkNBTKey("life", predicates.isShort)
				checkNBTKey("damage", predicates.isDouble)
				checkNBTKeyIsBool("inGround")
				checkNBTKeyIsBool("crit")
				checkNBTKeyIsBool("ShotFromCrossbow")
				checkNBTKeyIsByte("PierceLevel")
				checkNBTKey("SoundEvent", predicates.isString && !predicates.isString.equalTo(""))
				checkNBTKeyIsLongExact("OwnerUUIDMost")
				checkNBTKeyIsLongExact("OwnerUUIDLeast")
				checkNBTKey("Color", predicates.isInt.range(0, 0xFFFFFF))
				checkPotionNBT()
			],
			"spectral_arrow" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKey("pickup", predicates.isByte.range(0, 2))
				checkNBTKeyIsBool("player")
				checkNBTKey("life", predicates.isShort)
				checkNBTKey("damage", predicates.isDouble)
				checkNBTKeyIsBool("inGround")
				checkNBTKeyIsBool("crit")
				checkNBTKeyIsBool("ShotFromCrossbow")
				checkNBTKeyIsByte("PierceLevel")
				checkNBTKey("SoundEvent", predicates.isString && !predicates.isString.equalTo(""))
				checkNBTKeyIsLongExact("OwnerUUIDMost")
				checkNBTKeyIsLongExact("OwnerUUIDLeast")
				checkNBTKeyIsInt("Duration")
			],
			"dragon_fireball" -> new EntityDef [
				checkNBTKey("direction", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("power", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("life", predicates.isInt.min(0))
				requiredKeys("direction", "power")
			],
			"egg" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKeyIsObject("owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"ender_pearl" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKeyIsObject("owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"experience_bottle" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKeyIsObject("owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"fireball" -> new EntityDef [
				checkNBTKey("direction", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("power", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("life", predicates.isInt.min(0))
				checkNBTKeyIsInt("ExplosionPower")
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
				requiredKeys("direction", "power")
			],
			"llama_spit" -> new EntityDef [
				checkNBTKeyIsObject("Owner") [
					checkNBTKeyIsLongExact("OwnerUUIDMost")
					checkNBTKeyIsLongExact("OwnerUUIDLeast")
					requiredKeys("OwnerUUIDMost", "OwnerUUIDLeast")
					checkNoOtherKeys()
				]
			],
			"potion" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKeyIsObject("owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Potion") [
					checkItemNBT(false)
				]
			],
			"shulker_bullet" -> new EntityDef [
				checkNBTKeyIsObject("Owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					checkNBTKeyIsInt("X")
					checkNBTKeyIsInt("Y")
					checkNBTKeyIsInt("Z")
					requiredKeys("L", "M")
				]
				checkNBTKeyIsInt("Steps")
				checkNBTKeyIsObject("Target") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					checkNBTKeyIsInt("X")
					checkNBTKeyIsInt("Y")
					checkNBTKeyIsInt("Z")
					requiredKeys("L", "M")
				]
				checkNBTKey("TXD", predicates.isDouble)
				checkNBTKey("TYD", predicates.isDouble)
				checkNBTKey("TZD", predicates.isDouble)
			],
			"small_fireball" -> new EntityDef [
				checkNBTKey("direction", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("power", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("life", predicates.isInt.min(0))
				checkNBTKeyIsInt("ExplosionPower")
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
				requiredKeys("direction", "power")
			],
			"snowball" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKeyIsObject("owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"trident" -> new EntityDef [
				checkProjectileNBT()
				checkNBTKey("pickup", predicates.isByte.range(0, 2))
				checkNBTKeyIsBool("player")
				checkNBTKey("life", predicates.isShort)
				checkNBTKey("damage", predicates.isDouble)
				checkNBTKeyIsBool("inGround")
				checkNBTKeyIsBool("crit")
				checkNBTKeyIsBool("ShotFromCrossbow")
				checkNBTKeyIsByte("PierceLevel")
				checkNBTKey("SoundEvent", predicates.isString && !predicates.isString.equalTo(""))
				checkNBTKeyIsLongExact("OwnerUUIDMost")
				checkNBTKeyIsLongExact("OwnerUUIDLeast")
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"wither_skull" -> new EntityDef [
				checkNBTKey("direction", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("power", predicates.isArray.size(3).matching(predicates.isDouble))
				checkNBTKey("life", predicates.isInt.min(0))
				requiredKeys("direction", "power")
			],
			"experience_orb" -> new EntityDef [
				checkNBTKey("Age", predicates.isShort)
				checkNBTKeyIsByte("Health")
				checkNBTKey("Value", predicates.isShort)
			],
			"item" -> new EntityDef [
				checkNBTKey("Age", predicates.isShort)
				checkNBTKey("Health", predicates.isShort)
				checkNBTKey("PickupDelay", predicates.isShort)
				checkNBTKeyIsObject("Owner") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Thrower") [
					checkNBTKeyIsLongExact("L")
					checkNBTKeyIsLongExact("M")
					requiredKeys("L", "M")
					checkNoOtherKeys()
				]
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"boat" -> new EntityDef [
				checkNBTKey("Type", predicates.isString.equalTo(WOOD_TYPES))
			],
			"minecart" -> new EntityDef [
				checkMinecartNBT()
			],
			"chest_minecart" -> new EntityDef [
				checkMinecartNBT()
				checkNBTKeyIsArrayOfObjects("Items") [
					checkItemNBT(true)
				]
				checkLootableNBT()
			],
			"command_block_minecart" -> new EntityDef [
				checkMinecartNBT()
				checkCommandBlockNBT()
			],
			"furnace_minecart" -> new EntityDef [
				checkMinecartNBT()
				checkNBTKey("PushX", predicates.isDouble)
				checkNBTKey("PushZ", predicates.isDouble)
				checkNBTKey("Fuel", predicates.isShort)
			],
			"hopper_minecart" -> new EntityDef [
				checkMinecartNBT()
				checkNBTKeyIsArrayOfObjects("Items", predicates.isArray.rangeSize(0, 4)) [
					checkItemNBT(true)
					checkNBTKey("Slot", predicates.isInt.range(0, 4))
				]
				checkNBTKey("TransferCooldown", predicates.isInt.range(0, 8))
				checkNBTKeyIsBool("Enabled")
				checkLootableNBT()
			],
			"spawner_minecart" -> new EntityDef [
				checkMinecartNBT()
				checkSpawnerNBT()
			],
			"tnt_minecart" -> new EntityDef [
				checkMinecartNBT()
				checkNBTKey("TNTFuse", predicates.isInt.min(-1))
			],
			"falling_block" -> new EntityDef [
				val tileEntityData = new AtomicReference<NBTData>
				checkNBTKeyIsObject("TileEntityData") [ tileEntityData.set(it) ]
				checkNBTKeyIsBlockstate("BlockState", tileEntityData.get())
				checkNBTKey("Time", predicates.isInt.min(0))
				checkNBTKeyIsBool("DropItem")
				checkNBTKeyIsBool("HurtEntities")
				checkNBTKeyIsInt("FallHurtMax")
				checkNBTKey("FallHurtAmount", predicates.isFloat)
			],
			"tnt" -> new EntityDef [
				checkNBTKey("Fuse", predicates.isShort.min(0))
			],
			"area_effect_cloud" -> new EntityDef [
				checkNBTKeyIsInt("Age")
				checkNBTKey("Color", predicates.isInt.range(0, 0xFFFFFF))
				checkNBTKeyIsInt("Duration")
				checkNBTKeyIsInt("ReapplicationDelay")
				checkNBTKeyIsInt("WaitTime")
				checkNBTKeyIsInt("DurationOnUse")
				checkNBTKeyIsLongExact("OwnerUUIDLeast")
				checkNBTKeyIsLongExact("OwnerUUIDMost")
				checkNBTKey("Radius", predicates.isFloat)
				checkNBTKey("RadiusOnUse", predicates.isFloat)
				checkNBTKey("RadiusPerTick", predicates.isFloat)
				checkNBTKey("Particle", predicates.isString)
				checkNBTKey("Potion", predicates.isString.equalTo(DEFAULT_POTION_TYPES))
				checkNBTKeyIsArrayOfObjects("Effects") [
					checkNBTKey("Id", predicates.isInt.range(1, 32))
					checkNBTKeyIsByte("Amplifier")
					checkNBTKeyIsInt("Duration")
					checkNBTKeyIsBool("Ambient")
					checkNBTKeyIsBool("ShowParticles")
					checkNBTKeyIsBool("ShowIcon")
				]
			],
			"armor_stand" -> new EntityDef [
				checkNBTKeyIsArrayOfObjects("ActiveEffects") [
					checkNBTKey("Id", predicates.isInt.range(1, 32))
					checkNBTKeyIsByte("Amplifier")
					checkNBTKeyIsInt("Duration")
					checkNBTKeyIsBool("Ambient")
					checkNBTKeyIsBool("ShowParticles")
					checkNBTKeyIsBool("ShowIcon")
				]
				checkNBTKeyIsArrayOfObjects("HandItems", predicates.isArray.size(2)) [
					checkItemNBT(false)
				]
				checkNBTKeyIsArrayOfObjects("ArmorItems", predicates.isArray.size(4)) [
					checkItemNBT(false)
				]
				checkNBTKeyIsBool("Marker")
				checkNBTKeyIsBool("Invisible")
				checkNBTKeyIsBool("NoBasePlate")
				checkNBTKeyIsBool("FallFlying")
				checkNBTKeyIsObject("Pose") [
					val check = predicates.isArray.size(3).matching(predicates.isFloat)
					for(key : #{"Body", "LeftArm", "RightArm", "LeftLeg", "RightLeg", "Head"}) {
						checkNBTKey(key, check)
					}
				]
				checkNBTKeyIsBool("ShowArms")
				checkNBTKeyIsBool("Small")
				checkNBTKeyIsInt("DisabledSlots")
			],
			"end_crystal" -> new EntityDef [
				checkNBTKeyIsBool("ShowBottom")
				checkNBTKeyIsObject("BeamTarget") [
					checkNBTKeyIsInt("X")
					checkNBTKeyIsInt("Y")
					checkNBTKeyIsInt("Z")
					requiredKeys("X", "Y", "Z")
					checkNoOtherKeys()
				]
			],
			"evoker_fangs" -> new EntityDef [
				checkNBTKeyIsInt("Warmup")
				checkNBTKeyIsObject("Owner") [
					checkNBTKeyIsLongExact("OwnerUUIDLeast")
					checkNBTKeyIsLongExact("OwnerUUIDMost")
					requiredKeys("OwnerUUIDLeast", "OwnerUUIDMost")
					checkNoOtherKeys()
				]
			],
			"eye_of_ender" -> new EntityDef [
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
			],
			"firework_rocket" -> new EntityDef [
				checkNBTKeyIsInt("Life")
				checkNBTKeyIsInt("LifeTime")
				checkNBTKeyIsBool("ShotAtAngle")
				checkNBTKeyIsObject("FireworksItem") [
					checkItemNBT(false)
				]
			],
			"item_frame" -> new EntityDef [
				checkNBTKeyIsInt("TileX")
				checkNBTKeyIsInt("TileY")
				checkNBTKeyIsInt("TileZ")
				checkNBTKey("Facing", predicates.isByte.range(0, 5))
				checkNBTKeyIsObject("Item") [
					checkItemNBT(false)
				]
				checkNBTKey("ItemDropChance", predicates.isFloat.range(0.0f, 1.0f))
				checkNBTKey("ItemRotation", predicates.isByte.range(0, 8))
			],
			"painting" -> new EntityDef [
				checkNBTKeyIsInt("TileX")
				checkNBTKeyIsInt("TileY")
				checkNBTKeyIsInt("TileZ")
				checkNBTKey("Facing", predicates.isByte.range(0, 5))
				checkNBTKey("Motive", [ isValidPainting ], "Expected a painting id")
			],
			"fishing_bobber" -> new EntityDef
		}
	}
	
	static interface PropertyDef {
		def boolean isValid(String str)
	}
	
	def static PropertyDef property(String... options) { property(newHashSet(options)) }
	
	def static PropertyDef property(Set<String> options) {[ options.contains(it) ]}
	
	static val PropertyDef BOOL_PROPERTY = [ it == "true" || it == "false" ]
	
	def static PropertyDef property(int min, int max) {[
		try {
			val i = Integer.parseInt(it)
			return i >= min && i <= max
		} catch(NumberFormatException e) {
			return false
		}
	]}
	
	static val PropertyDef FACING_PROPERTY = property("up", "down", "north", "south", "east", "west")
	static val PropertyDef HORIZ_FACING_PROPERTY = property("north", "south", "east", "west")
	static val PropertyDef AXIS_PROPERTY = property("x", "y", "z")
	static val PropertyDef HORIZ_AXIS_PROPERTY = property("x", "z")
	
	static class BlockDef {
		val Map<String, PropertyDef> properties
		@Nullable
		val (NBTData)=>void checker
		public var hasItem = true
		
		new() {
			this(null, null)
		}
		
		new((NBTData)=>void checker) {
			this(#{}, checker)
		}
		
		new(Map<String, PropertyDef> properties) {
			this(properties, null)
		}
		
		new(Map<String, PropertyDef> properties, (NBTData)=>void checker) {
			this.properties = properties
			this.checker = checker
		}
		
		def hasItem(boolean hasItem) {
			this.hasItem = hasItem
			return this 
		}
		
		def check(NBTCompound nbt) {
			checker?.apply(new NBTData(nbt))
		}
		
		def check(NBTData maks) {
			checker?.apply(maks)
		}
		
		def getProperties() { properties.unmodifiableView }
		
		def checkProperties(Map<String, String> props, (String /*key*/, String /*msg*/)=>void errorMessageAcceptor) {
			for(entry : props.entrySet) {
				val prop = properties.get(entry.key)
				if(prop === null) {
					errorMessageAcceptor.apply(entry.key, '''Block does not have property "«entry.key»"''')
				} else if(!prop.isValid(entry.value)) {
					errorMessageAcceptor.apply(entry.key, '''Invalid value for property "«entry.key»"''')
				}
			}
		}
		
	}
	
	val DEFAULT_BLOCK_DEF = new BlockDef
	
	val Map<String, Map<String, BlockDef>> ALL_BLOCKS = #{
		"minecraft" -> #{
			"stone" -> DEFAULT_BLOCK_DEF,
			"portal" -> new BlockDef(#{"axis" -> HORIZ_AXIS_PROPERTY}).hasItem(false),
			"spawner" -> new BlockDef [
				checkNBTKeyIsObject("BlockEntityTag") [
					checkSpawnerNBT()
				]
			]
		}
	}
	
	static class ItemDef {
		@Nullable
		val (NBTData)=>void checker
		//public val BlockDef block
		public val int maxStackSize
		
		new() {
			this(64, null)
		}
		
		new((NBTData)=>void checker) {
			this(64, checker)
		}
		
		new(int maxStackSize) {
			this(maxStackSize, null)
		}
		
		new(int maxStackSize, (NBTData)=>void checker) {
			this.maxStackSize = maxStackSize
			//this.block = null
			this.checker = checker
		}
		
//		new(BlockDef block) {
//			this.maxStackSize = 64
//			this.block = block
//			this.checker = if(block.checker !== null) [
//				checkNBTKeyIsObject("BlockEntityTag") [
//					block.checker.apply(it)
//				]
//			]
//		}
		
		def check(NBTCompound nbt) {
			checker?.apply(new NBTData(nbt))
		}
		
		def check(NBTData maks) {
			checker?.apply(maks)
		}
	}
	
	def toItemDef(BlockDef block) {
		new ItemDef(64, if(block.checker !== null) [
			checkNBTKeyIsObject("BlockEntityTag") [
				block.checker.apply(it)
			]
			checkNBTKeyIsBlockstate("BlockStateTag", block)
			checkBlockItemStackNBT()
		])
	}
	
	val DEFAULT_ITEM_DEF = new ItemDef
	val NONSTACKABLE_ITEM_DEF = new ItemDef(1)
	val DEFAULT_ITEM_DEF16 = new ItemDef(16)
	val DAMAGEABLE_ITEM_DEF = new ItemDef(1) [
		checkDamageableItemStackNBT()
	]
	val POTION_ITEM_DEF = new ItemDef(1) [
		checkPotionNBT()
	]
	val PLACEABLE_ITEM_DEF = new ItemDef [
		checkBlockItemStackNBT()
	]
	val NONSTACKABLE_PLACEABLE_ITEMDEF = new ItemDef(1) [
		checkBlockItemStackNBT()
	]
	
	val Map<String, Map<String, ItemDef>> ALL_ITEMS = #{
		"minecraft" -> #{
			"acacia_boat" -> NONSTACKABLE_ITEM_DEF,
			"armor_stand" -> new ItemDef(16) [
				checkBlockItemStackNBT()
				checkNBTKeyIsObject("EntityTag") [
					checkEntityNBT(ALL_ENTITIES.get("minecraft").get("armor_stand"))
				]
			],
			"beetroot_seeds" -> PLACEABLE_ITEM_DEF,
			"birch_boat" -> NONSTACKABLE_ITEM_DEF,
			"bottle_o_enchanting" -> DEFAULT_ITEM_DEF,
			"bucket" -> new ItemDef(16),
			"cod_bucket" -> new ItemDef(1) [
				checkNBTKeyIsObject("EntityTag") [
					checkEntityNBT(ALL_ENTITIES.get("minecraft").get("cod"))
				]
			],
			"salmon_bucket" -> new ItemDef(1) [
				checkNBTKeyIsObject("EntityTag") [
					checkEntityNBT(ALL_ENTITIES.get("minecraft").get("salmon"))
				]				
			],
			"pufferfish_bucket" -> new ItemDef(1) [
				checkNBTKeyIsObject("EntityTag") [
					checkEntityNBT(ALL_ENTITIES.get("minecraft").get("pufferfish"))
				]				
			],
			"tropical_fish_bucket" -> new ItemDef(1) [
				checkNBTKeyIsObject("EntityTag") [
					checkEntityNBT(ALL_ENTITIES.get("minecraft").get("tropical_fish"))
				]
				checkNBTKeyIsObject("BucketVariantTag") [
					checkEntityNBT(ALL_ENTITIES.get("minecraft").get("tropical_fish"))
				]	
			],
			"carrot" -> PLACEABLE_ITEM_DEF,
			"cocoa_beans" -> PLACEABLE_ITEM_DEF,
			"dark_oak_boat" -> NONSTACKABLE_ITEM_DEF,
			"egg" -> DEFAULT_ITEM_DEF16,
			"ender_pearl" -> DEFAULT_ITEM_DEF16,
			"end_crystal" -> PLACEABLE_ITEM_DEF,
			"eye_of_ender" -> DEFAULT_ITEM_DEF16,
			"firework_rocket" -> new ItemDef [
				checkFireworksNBT()
			],
			"fire_charge" -> PLACEABLE_ITEM_DEF,
			"flint_and_steel" -> new ItemDef(1) [
				checkDamageableItemStackNBT()
				checkBlockItemStackNBT()
			],
			"item_frame" -> PLACEABLE_ITEM_DEF,
			"jungle_boat" -> NONSTACKABLE_ITEM_DEF,
			"lava_bucket" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"lead" -> DEFAULT_ITEM_DEF,
			"lingering_potion" -> POTION_ITEM_DEF,
			"melon_seeds" -> PLACEABLE_ITEM_DEF,
			"minecart" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"chest_minecart" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"command_block_minecart" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"furnace_minecart" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"hopper_minecart" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"tnt_minecart" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"nether_wart" -> DEFAULT_ITEM_DEF,
			"oak_boat" -> NONSTACKABLE_ITEM_DEF,
			"painting" -> PLACEABLE_ITEM_DEF,
			"potato" -> PLACEABLE_ITEM_DEF,
			"pumpkin_seeds" -> PLACEABLE_ITEM_DEF,
			"redstone" -> PLACEABLE_ITEM_DEF,
			"snowball" -> DEFAULT_ITEM_DEF16,
			"splash_potion" -> POTION_ITEM_DEF,
			"spruce_boat" -> NONSTACKABLE_ITEM_DEF,
			"string" -> PLACEABLE_ITEM_DEF,
			"sweet_berries" -> PLACEABLE_ITEM_DEF,
			"trident" -> DAMAGEABLE_ITEM_DEF,
			"water_bucket" -> NONSTACKABLE_PLACEABLE_ITEMDEF,
			"wheat_seeds" -> PLACEABLE_ITEM_DEF,
			"apple" -> DEFAULT_ITEM_DEF,
			"arrow" -> DEFAULT_ITEM_DEF,
			"baked_potato" -> DEFAULT_ITEM_DEF,
			"beetroot_soup" -> NONSTACKABLE_ITEM_DEF,
			"beetroot" -> DEFAULT_ITEM_DEF,
			"black_dye" -> DEFAULT_ITEM_DEF,
			"blue_dye" -> DEFAULT_ITEM_DEF,
			"bone" -> DEFAULT_ITEM_DEF,
			"bone_meal" -> DEFAULT_ITEM_DEF,
			"book_and_quill" -> new ItemDef(1) [
				checkBookPagesNBT()
			],
			"bow" -> DAMAGEABLE_ITEM_DEF,
			"bowl" -> DEFAULT_ITEM_DEF16,
			"bread" -> DEFAULT_ITEM_DEF,
			"brown_dye" -> DEFAULT_ITEM_DEF,
			"carrot_on_a_stick" -> DAMAGEABLE_ITEM_DEF,
			"chainmail_boots" -> DAMAGEABLE_ITEM_DEF,
			"chainmail_chestplate" -> DAMAGEABLE_ITEM_DEF,
			"chainmail_helmet" -> DAMAGEABLE_ITEM_DEF,
			"chainmail_leggings" -> DAMAGEABLE_ITEM_DEF,
			"charcoal" -> DEFAULT_ITEM_DEF,
			"chorus_fruit" -> DEFAULT_ITEM_DEF,
			"coal" -> DEFAULT_ITEM_DEF,
			"cooked_chicken" -> DEFAULT_ITEM_DEF,
			"cooked_cod" -> DEFAULT_ITEM_DEF,
			"cooked_mutton" -> DEFAULT_ITEM_DEF,
			"cooked_porkchop" -> DEFAULT_ITEM_DEF,
			"cooked_rabbit" -> DEFAULT_ITEM_DEF,
			"cooked_salmon" -> DEFAULT_ITEM_DEF,
			"cookie" -> DEFAULT_ITEM_DEF,
			"crossbow" -> DAMAGEABLE_ITEM_DEF,
			"cyan_dye" -> DEFAULT_ITEM_DEF,
			"debug_stick" -> NONSTACKABLE_ITEM_DEF,
			"diamond_axe" -> DAMAGEABLE_ITEM_DEF,
			"diamond_boots" -> DAMAGEABLE_ITEM_DEF,
			"diamond_chestplate" -> DAMAGEABLE_ITEM_DEF,
			"diamond_helmet" -> DAMAGEABLE_ITEM_DEF,
			"diamond_hoe" -> DAMAGEABLE_ITEM_DEF,
			"diamond_horse_armor" -> NONSTACKABLE_ITEM_DEF,
			"diamond_leggings" -> DAMAGEABLE_ITEM_DEF,
			"diamond_pickaxe" -> DAMAGEABLE_ITEM_DEF,
			"diamond_shovel" -> DAMAGEABLE_ITEM_DEF,
			"diamond_sword" -> DAMAGEABLE_ITEM_DEF,
			"iron_axe" -> DAMAGEABLE_ITEM_DEF,
			"iron_boots" -> DAMAGEABLE_ITEM_DEF,
			"iron_chestplate" -> DAMAGEABLE_ITEM_DEF,
			"iron_helmet" -> DAMAGEABLE_ITEM_DEF,
			"iron_hoe" -> DAMAGEABLE_ITEM_DEF,
			"iron_horse_armor" -> NONSTACKABLE_ITEM_DEF,
			"iron_leggings" -> DAMAGEABLE_ITEM_DEF,
			"iron_pickaxe" -> DAMAGEABLE_ITEM_DEF,
			"iron_shovel" -> DAMAGEABLE_ITEM_DEF,
			"iron_sword" -> DAMAGEABLE_ITEM_DEF,
			"golden_axe" -> DAMAGEABLE_ITEM_DEF,
			"golden_boots" -> DAMAGEABLE_ITEM_DEF,
			"golden_chestplate" -> DAMAGEABLE_ITEM_DEF,
			"golden_helmet" -> DAMAGEABLE_ITEM_DEF,
			"golden_hoe" -> DAMAGEABLE_ITEM_DEF,
			"golden_horse_armor" -> NONSTACKABLE_ITEM_DEF,
			"golden_leggings" -> DAMAGEABLE_ITEM_DEF,
			"golden_pickaxe" -> DAMAGEABLE_ITEM_DEF,
			"golden_shovel" -> DAMAGEABLE_ITEM_DEF,
			"golden_sword" -> DAMAGEABLE_ITEM_DEF,
			"dried_kelp" -> DEFAULT_ITEM_DEF,
			"elytra" -> DAMAGEABLE_ITEM_DEF,
			"map" -> DEFAULT_ITEM_DEF,
			"enchanted_book" -> new ItemDef(1) [
				checkNBTKeyIsArrayOfObjects("StoredEnchantments", predicates.isArray.minSize(1)) [
					checkEnchantmentNBT()
				]
				requiredKeys("StoredEnchantments")
			],
			"enchanted_golden_apple" -> DEFAULT_ITEM_DEF,
			"filled_map" -> new ItemDef [
				checkNBTKeyIsInt("map")
				checkNBTKeyIsInt("map_scale_direction")
				val ids = <String>newHashSet()
				checkNBTKeyIsArrayOfObjects("Decorations") [
					checkNBTKey("id", predicates.isString && !predicates.isString.equalTo(ids)) [
						NBTString value |
						ids += value.value
					]
					checkNBTKey("type", predicates.isByte.range(0, 26))
					checkNBTKey("x", predicates.isDouble)
					checkNBTKey("z", predicates.isDouble)
					checkNBTKey("rot", predicates.isDouble.range(0.0, 360.0))
					requiredKeys("id", "type", "x", "z")
					checkNoOtherKeys()
				]
			],
			"fishing_rod" -> DAMAGEABLE_ITEM_DEF,
			"glass_bottle" -> DEFAULT_ITEM_DEF,
			"golden_apple" -> DEFAULT_ITEM_DEF,
			"gray_dye" -> DEFAULT_ITEM_DEF,
			"green_dye" -> DEFAULT_ITEM_DEF,
			"ink_sac" -> DEFAULT_ITEM_DEF,
			"iron_ingot" -> DEFAULT_ITEM_DEF,
			"iron_nugget" -> DEFAULT_ITEM_DEF,
			"gold_ingot" -> DEFAULT_ITEM_DEF,
			"gold_nugget" -> DEFAULT_ITEM_DEF,
			"knowledge_book" -> new ItemDef(1) [
				checkNBTKeyIsArray("Recipes") [
					NBTValue nbt, int index |
					if(!isNamespacedLocation(nbt)) {
						error("Expected a recipe id",
							map.get("Recipes"),
							NBT_ENTRY__VALUE,
							index
						)
					}
				]
			],
			"lapis_lazuli" -> DEFAULT_ITEM_DEF,
			"leather_boots" -> DAMAGEABLE_ITEM_DEF,
			"leather_helmet" -> DAMAGEABLE_ITEM_DEF,
			"leather_chestplate" -> DAMAGEABLE_ITEM_DEF,
			"leather_leggings" -> DAMAGEABLE_ITEM_DEF,
			"leather_horse_armor" -> NONSTACKABLE_ITEM_DEF,
			"light_blue_dye" -> DEFAULT_ITEM_DEF,
			"light_gray_dye" -> DEFAULT_ITEM_DEF,
			"lime_dye" -> DEFAULT_ITEM_DEF,
			"magenta_dye" -> DEFAULT_ITEM_DEF,
			"melon_slice" -> DEFAULT_ITEM_DEF,
			"milk_bucket" -> NONSTACKABLE_ITEM_DEF,
			"mushroom_stew" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_13" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_cat" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_blocks" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_chirp" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_far" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_mall" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_mellohi" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_stal" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_strad" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_ward" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_11" -> NONSTACKABLE_ITEM_DEF,
			"music_disc_wait" -> NONSTACKABLE_ITEM_DEF,
			"name_tag" -> DEFAULT_ITEM_DEF,
			"orange_dye" -> DEFAULT_ITEM_DEF,
			"pink_dye" -> DEFAULT_ITEM_DEF,
			"poisonous_potato" -> DEFAULT_ITEM_DEF,
			"potion" -> POTION_ITEM_DEF,
			"pufferfish" -> DEFAULT_ITEM_DEF,
			"pumpkin_pie" -> DEFAULT_ITEM_DEF,
			"purple_dye" -> DEFAULT_ITEM_DEF,
			"rabbit_stew" -> DEFAULT_ITEM_DEF,
			"beef" -> DEFAULT_ITEM_DEF,
			"chicken" -> DEFAULT_ITEM_DEF,
			"mutton" -> DEFAULT_ITEM_DEF,
			"cod" -> DEFAULT_ITEM_DEF,
			"porkchop" -> DEFAULT_ITEM_DEF,
			"rabbit" -> DEFAULT_ITEM_DEF,
			"salmon" -> DEFAULT_ITEM_DEF,
			"red_dye" -> DEFAULT_ITEM_DEF,
			"rotten_flesh" -> DEFAULT_ITEM_DEF,
			"saddle" -> NONSTACKABLE_ITEM_DEF,
			"shears" -> DAMAGEABLE_ITEM_DEF,
			"shield" -> new ItemDef(1) [
				checkDamageableItemStackNBT()
				// TODO
			],
			"spectral_arrow" -> DEFAULT_ITEM_DEF,
			"spider_eye" -> DEFAULT_ITEM_DEF,
			"cooked_beef" -> DEFAULT_ITEM_DEF,
			"stone_axe" -> DAMAGEABLE_ITEM_DEF,
			"stone_hoe" -> DAMAGEABLE_ITEM_DEF,
			"stone_pickaxe" -> DAMAGEABLE_ITEM_DEF,
			"stone_shovel" -> DAMAGEABLE_ITEM_DEF,
			"stone_sword" -> DAMAGEABLE_ITEM_DEF,
			"sugar" -> DEFAULT_ITEM_DEF,
			"suspicious_stew" -> new ItemDef(1) [
				checkNBTKeyIsArrayOfObjects("Effects") [
					// TODO
				]
			],
			"totem_of_undying" -> NONSTACKABLE_ITEM_DEF,
			"tropical_fish" -> DEFAULT_ITEM_DEF,
			"turtle_helmet" -> DAMAGEABLE_ITEM_DEF,
			"wheat" -> DEFAULT_ITEM_DEF,
			"white_dye" -> DEFAULT_ITEM_DEF,
			"wooden_axe" -> DAMAGEABLE_ITEM_DEF,
			"wooden_hoe" -> DAMAGEABLE_ITEM_DEF,
			"wooden_pickaxe" -> DAMAGEABLE_ITEM_DEF,
			"wooden_shovel" -> DAMAGEABLE_ITEM_DEF,
			"wooden_sword" -> DAMAGEABLE_ITEM_DEF,
			"tipped_arrow" -> new ItemDef(64) [
				checkPotionNBT()
			],
			"yellow_dye" -> DEFAULT_ITEM_DEF,
			"written_book" -> new ItemDef(1) [
				checkBookPagesNBT()
				checkNBTKeyIsBool("resolved")
				checkNBTKey("generation", predicates.isInt.range(0, 3))
				checkNBTKey("author", predicates.isString)
				checkNBTKey("title", predicates.isString)
			],
			"flower_banner_pattern" -> NONSTACKABLE_ITEM_DEF,
			"creeper_banner_pattern" -> NONSTACKABLE_ITEM_DEF,
			"skull_banner_pattern" -> NONSTACKABLE_ITEM_DEF,
			"mojang_banner_pattern" -> NONSTACKABLE_ITEM_DEF,
			"globe_banner_pattern" -> NONSTACKABLE_ITEM_DEF,
			"blaze_powder" -> DEFAULT_ITEM_DEF,
			"blaze_rod" -> DEFAULT_ITEM_DEF,
			"book" -> DEFAULT_ITEM_DEF,
			"brick" -> DEFAULT_ITEM_DEF,
			"clay" -> DEFAULT_ITEM_DEF,
			"clock" -> NONSTACKABLE_ITEM_DEF,
			"comppass" -> NONSTACKABLE_ITEM_DEF,
			"diamond" -> DEFAULT_ITEM_DEF,
			"dragons_breath" -> NONSTACKABLE_ITEM_DEF,
			"emerald" -> DEFAULT_ITEM_DEF,
			"feather" -> DEFAULT_ITEM_DEF,
			"fermented_spider_eye" -> DEFAULT_ITEM_DEF,
			"firework_star" -> new ItemDef [
				checkNBTKeyIsObject("Explosion") [
					checkFireworkExplosionNBT()
				]
			],
			"flint" -> DEFAULT_ITEM_DEF,
			"glistering_melon" -> DEFAULT_ITEM_DEF,
			"glowstone_dust" -> DEFAULT_ITEM_DEF,
			"gunpowder" -> DEFAULT_ITEM_DEF,
			"heart_of_the_sea" -> DEFAULT_ITEM_DEF,
			"honey_bottle" -> DEFAULT_ITEM_DEF16,
			"honeycomb" -> DEFAULT_ITEM_DEF,
			"leather" -> DEFAULT_ITEM_DEF,
			"magma_cream" -> DEFAULT_ITEM_DEF,
			"nautilus_shell" -> DEFAULT_ITEM_DEF,
			"nether_brick" -> DEFAULT_ITEM_DEF,
			"nether_quart" -> DEFAULT_ITEM_DEF,
			"nether_star" -> DEFAULT_ITEM_DEF,
			"paper" -> DEFAULT_ITEM_DEF,
			"phantom_membrane" -> DEFAULT_ITEM_DEF,
			"popped_chorus_fruit" -> DEFAULT_ITEM_DEF,
			"prismarine_crystals" -> DEFAULT_ITEM_DEF,
			"prismarine_shard" -> DEFAULT_ITEM_DEF,
			"rabbit_hide" -> DEFAULT_ITEM_DEF,
			"rabbit_foot" -> DEFAULT_ITEM_DEF,
			"scute" -> DEFAULT_ITEM_DEF,
			"shulker_shell" -> DEFAULT_ITEM_DEF,
			"slimeball" -> DEFAULT_ITEM_DEF,
			"stick" -> DEFAULT_ITEM_DEF,
			"player_head" -> new ItemDef [
				checkNBTKey("SkullOwner", predicates.isString.matching("[a-zA-Z_0-9]+") || predicates.isObject) [
					NBTValue nbt |
					if(nbt instanceof NBTCompound) {
						val it = new NBTData(nbt as NBTCompound)
						checkNBTKey("Id", [ isUUID ], "Expected a player UUID")
						checkNBTKey("Name", predicates.isString.matching("[a-zA-Z_0-9]+"))
						checkNBTKeyIsObject("Properties") [
							checkNBTKeyIsArrayOfObjects("textures") [
								checkNBTKey("Signature", predicates.isString)
								checkNBTKey("Value", predicates.isString.matching("[a-zA-Z0-9=+/]+"), "Expected a Base64 string")
							]
						] 
					}
				]
			]
		} + (
			ALL_BLOCKS.get("minecraft").filter[_, it | hasItem ].mapValues[toItemDef]
		  + ALL_ENTITIES.get("minecraft").filter[_, it | hasSpawnEgg ].entrySet.stream()
		  		.collect(Collectors.toMap(
		  			[
//		  				switch(key) {
//		  					case "armor_stand",
//		  					case "end_crystal": key
//		  					default: '''«key»_spawn_egg'''
//		  				}
						'''«key»_spawn_egg'''
		  			], 
		  			[value.toItem]
		  		))
		  )
	}
	
	val PANDA_GENES = #{"normal", "aggressive", "lazy", "worried", "playful", "weak", "brown"}
	
	val VILLAGER_PROFESSIONS = #{ 
		"minecraft:armorer", "minecraft:butcher", "minecraft:cartographer", "minecraft:cleric", "minecraft:farmer",
		"minecraft:fisherman", "minecraft:fletcher", "minecraft:leatherworker", "minecraft:librarian", 
		"minecraft:nitwit", "minecraft:none", "minecraft:mason", "minecraft:shepherd", "minecraft:toolsmith", "minecraft:weaponsmith"
	}
	
	val VILLAGER_TYPES = #{
		"minecraft:desert", "minecraft:jungle", "minecraft:plains", "minecraft:savanna", "minecraft:snow", "minecraft:swamp", "minecraft:taiga"
	}
	
	val GOSSIP_TYPES = #{"major_negative", "minor_negative", "major_positive", "minor_positive", "trading"}
	
	val DEFAULT_POTION_TYPES = #{
		"minecraft:empty", "minecraft:water", "minecraft:mundane", "minecraft:thick", "minecraft:awkward", 
		"minecraft:night_vision", "minecraft:invisibility", "minecraft:leaping", "minecraft:fire_resistance", 
		"minecraft:swiftness", "minecraft:slowness", "minecraft:water_breathing", "minecraft:healing", 
		"minecraft:harming", "minecraft:poison", "minecraft:regeneration", "minecraft:strength", "minecraft:weakness", 
		"minecraft:luck", "minecraft:turtle_master", "minecraft:slow_falling", "minecraft:strong_leaping",
		"minecraft:strong_swiftness", "minecraft:strong_slowness", "minecraft:strong_healing", "minecraft:strong_harming", 
		"minecraft:strong_poison", "minecraft:strong_regeneration", "minecraft:strong_strength", "minecraft:strong_turtle_master", 
		"minecraft:long_night_vision", "minecraft:long_invisiblity", "minecraft:long_leaping", "minecraft:long_fire_resistance", 
		"minecraft:long_swiftness", "minecraft:long_slowness", "minecraft:long_water_breathing", "minecraft:long_poison", 
		"minecraft:long_regeneration", "minecraft:long_strength", "minecraft:long_weakness", "minecraft:long_turtle_master", 
		"minecraft:long_slow_falling"
	}
	
	val WOOD_TYPES = #{"oak", "spruce", "birch", "jungle", "acacia", "dark_oak"}
	
	val PAINTING_TYPES = #{
		"minecraft:kebab", "minecraft:aztec", "minecraft:alban", "minecraft:aztec2", "minecraft:bomb", "minecraft:plant", 
		"minecraft:wasteland", "minecraft:wanderer", "minecraft:graham", "minecraft:pool", "minecraft:courbet", 
		"minecraft:sunset", "minecraft:sea", "minecraft:creebet", "minecraft:match", "minecraft:bust", "minecraft:stage", 
		"minecraft:void", "minecraft:skull_and_roses", "minecraft:wither", "minecraft:fighters", "minecraft:skeleton", 
		"minecraft:donkey_kong", "minecraft:pointer", "minecraft:pigscene", "minecraft:burning_skull"
	}
	
	val ENCHANTMENT_IDS = #{
		"minecraft:bane_of_arthropods", "minecraft:channeling", "minecraft:vanishing_curse", "minecraft:efficiency",
		"minecraft:fire_aspect", "minecraft:flame", "minecraft:fortune", "minecraft:impaling", "minecraft:luck_of_the_sea",
		"minecraft:infinity", "minecraft:knockback", "minecraft:looting", "minecraft:loyalty", "minecraft:lure",
		"minecraft:mending", "minecraft:multishot", "minecraft:piercing", "minecraft:power", "minecraft:punch",
		"minecraft:quick_charge", "minecraft:riptide", "minecraft:sharpness", "minecraft:silk_touch", "minecraft:smite",
		"minecraft:sweeping", "minecraft:unbreaking", "minecraft:chopping"
	}
	
	val POTION_EFFECTS = #{
		"minecraft:speed" -> 1,
		"minecraft:slowness" -> 2,
		"minecraft:haste" -> 3,
		"minecraft:mining_fatigue" -> 4,
		"minecraft:strength" -> 5,
		"minecraft:instant_health" -> 6,
		"minecraft:instant_damage" -> 7,
		"minecraft:jump_boost" -> 8,
		"minecraft:nausea" -> 9,
		"minecraft:regeneration" -> 10,
		"minecraft:resistance" -> 11,
		"minecraft:fire_resistance" -> 12,
		"minecraft:water_breathing" -> 13,
		"minecraft:invisibility" -> 14,
		"minecraft:blindness" -> 15,
		"minecraft:night_vision" -> 16,
		"minecraft:hunger" -> 17,
		"minecraft:weakness" -> 18,
		"minecraft:poison" -> 19,
		"minecraft:wither" -> 20,
		"minecraft:health_boost" -> 21,
		"minecraft:absorption" -> 22,
		"minecraft:saturation" -> 23,
		"minecraft:glowing" -> 24,
		"minecraft:levitation" -> 25,
		"minecraft:luck" -> 26,
		"minecraft:unluck" -> 27,
		"minecraft:slow_falling" -> 28,
		"minecraft:conduit_power" -> 29,
		"minecraft:dolphins_grace" -> 30,
		"minecraft:bad_omean" -> 31,
		"minecraft:hero_of_the_village" -> 32
	}
	
	def dispatch boolean isValidEntity(NamespacedKey it) {
		ALL_ENTITIES.get(namespace)?.get(key) !== null
	}
	
	def dispatch boolean isValidEntity(NBTString it) {
		if(value.matches("[-.a-z_0-9]+(:[-.a-z_0-9]+)?")) {
			val i = value.indexOf(':')
			val namespace = if(i == -1) "minecraft" else value.substring(0, i)
			val key = if(i == -1) value else value.substring(i+1)
			return ALL_ENTITIES.get(namespace)?.get(key) !== null
		} else {
			return false
		}
	}
	
	def dispatch boolean isValidEntity(NBTValue it) { false }
	
	def dispatch boolean isValidProfession(NamespacedKey it) {
		VILLAGER_PROFESSIONS.contains(namespace + ':' + key)
	}
	
	def dispatch boolean isValidProfession(NBTString it) {
		val i = value.indexOf(':')
		if(i == -1)
			VILLAGER_PROFESSIONS.contains("minecraft:" + value)
		else
			VILLAGER_PROFESSIONS.contains(value)
	}
	
	def dispatch boolean isValidProfession(NBTValue it) { false }
	
	def dispatch boolean isValidVillagerType(NamespacedKey it) {
		VILLAGER_TYPES.contains(namespace + ':' + key)
	}
	
	def dispatch boolean isValidVillagerType(NBTString it) {
		val i = value.indexOf(':')
		if(i == -1)
			VILLAGER_TYPES.contains("minecraft:" + value)
		else
			VILLAGER_TYPES.contains(value)
	}
	
	def dispatch boolean isValidVillagerType(NBTValue it) { false }
	
	def dispatch boolean isValidPainting(NamespacedKey it) {
		PAINTING_TYPES.contains(namespace + ':' + key)
	}
	
	def dispatch boolean isValidPainting(NBTString it) {
		val i = value.indexOf(':')
		if(i == -1)
			PAINTING_TYPES.contains("minecraft:" + value)
		else
			PAINTING_TYPES.contains(value)
	}
	
	def dispatch boolean isValidPainting(NBTValue it) { false }
	
	def dispatch boolean isValidEnchantment(NamespacedKey it) {
		ENCHANTMENT_IDS.contains(namespace + ':' + key)
	}
	
	def dispatch boolean isValidEnchantment(NBTString it) {
		val i = value.indexOf(':')
		if(i == -1)
			ENCHANTMENT_IDS.contains("minecraft:" + value)
		else
			ENCHANTMENT_IDS.contains(value)
	}
	
	def dispatch boolean isValidEnchantment(NBTValue it) { false }
	
	
	def dispatch isValidItem(NBTString it) {
		val m = NAMESPACED_KEY_REGEX.matcher(value)
		if(m.matches()) {
			if(ALL_ITEMS.get(m.group("namespace") ?: "minecraft")?.get(m.group("key")) !== null)
				Possibility.YES
			else
				Possibility.MAYBE
		} else {
			Possibility.NO
		}
	}
	
	def dispatch isValidItem(NamespacedKey it) { 
		if(ALL_ITEMS.get(namespace)?.get(key) !== null)
			Possibility.YES
		else
			Possibility.MAYBE
	}
	
	def dispatch isValidItem(NBTValue it) { Possibility.NO }
	
	def dispatch isValidBlock(NBTString it) {
		val m = NAMESPACED_KEY_REGEX.matcher(value)
		if(m.matches()) {
			if(ALL_BLOCKS.get(m.group("namespace") ?: "minecraft")?.get(m.group("key")) !== null)
				Possibility.YES
			else
				Possibility.MAYBE
		} else {
			Possibility.NO
		}
	}
	
	def dispatch isValidBlock(NamespacedKey it) { 
		if(ALL_BLOCKS.get(namespace)?.get(key) !== null)
			Possibility.YES
		else
			Possibility.MAYBE
	}
	
	def dispatch isValidBlock(NBTValue it) { Possibility.NO }
	
	def dispatch boolean isValidEffect(NamespacedKey it) { POTION_EFFECTS.containsKey(namespace + ':' + key) }
	
	def dispatch boolean isValidEffect(NBTString it) {
		val m = NAMESPACED_KEY_REGEX.matcher(value)
		return m.matches() && POTION_EFFECTS.containsKey((m.group("namespace") ?: "minecraft") + ':' + m.group("key"))
	}
	
	def dispatch boolean isValidEffect(NBTValue it) { false }
	
	enum Possibility { YES, MAYBE, NO }
	
	// isVec3D
	
	def static isVec3D(NBTValue it) { isArray(3) [ isDouble ] }
	
	// isVec2F
	
	def static isVec2F(NBTValue it) { isArray(2) [ isFloat ] }
	
	// isString
	
	def static isString(NBTValue it) { it instanceof NBTString }
	
	// isString(exact)
	
	def static isString(NBTValue it, String exact) { it instanceof NBTString && (it as NBTString).value == exact }
	
	// isStringMatching(regex)
	
	def static isStringMatching(NBTValue it, Pattern regex) { it instanceof NBTString && regex.matcher((it as NBTString).value).matches() }
	
	// isUUID
	
	def static isUUID(NBTValue it) { isStringMatching(UUID_REGEX) }
	
	// isNamespacedKey
	
	def static dispatch isNamespacedKey(NBTString it) { NAMESPACED_KEY_REGEX.matcher(value).matches() }
	
	def static dispatch isNamespacedKey(NamespacedKey it) { KEY_REGEX.matcher(key).matches() }
	
	def static dispatch isNamespacedKey(NBTValue it) { false }
	
	// isNamespacedLocation
	
	def static dispatch isNamespacedLocation(NBTString it) { NAMESPACED_FOLDER_REGEX.matcher(value).matches() }
	
	def static dispatch isNamespacedLocation(NamespacedKey it) { FOLDER_REGEX.matcher(key).matches() }
	
	def static dispatch isNamespacedLocation(NBTValue it) { false }
	
	// isDouble
	
	def static isDouble(NBTValue it) { it instanceof NBTDouble || it instanceof NBTInt }
	
	// isDouble(exact)
	
	def static dispatch isDouble(NBTDouble it, double exact) { value == exact }
	
	def static dispatch isDouble(NBTInt it, double exact) { value == exact }
	
	def static dispatch isDouble(NBTValue it, double exact) { false }
	
	// isDouble(min, max)
	
	def static dispatch isDouble(NBTDouble it, double min, double max) { value >= min && value <= max }
	
	def static dispatch isDouble(NBTInt it, double min, double max) { value >= min && value <= max }
	
	def static dispatch isDouble(NBTValue it, double min, double max) { false }
	
	// isFloat
	
	def static isFloat(NBTValue it) { it instanceof NBTFloat || it instanceof NBTInt }
	
	// isFloat(exact)
	
	def static dispatch isFloat(NBTFloat it, float exact) { value == exact }
	
	def static dispatch isFloat(NBTInt it, float exact) { value == exact }
	
	def static dispatch isFloat(NBTValue it, float exact) { false }
	
	// isFloat(min, max)
	
	def static dispatch isFloat(NBTFloat it, float min, float max) { value >= min && value <= max }
	
	def static dispatch isFloat(NBTInt it, float min, float max) { value >= min && value <= max }
	
	def static dispatch isFloat(NBTValue it, float min, float max) { false }
	
	// isLong
	
	def static isLong(NBTValue it) { it instanceof NBTLong || it.isInt }
	
	// isLong(exact)
	
	def static dispatch isLong(NBTLong it, long exact) { value == exact }
	
	def static dispatch isLong(NBTInt it, long exact) { value == exact }
	
	def static dispatch isLong(NBTShort it, long exact) { value == exact }
	
	def static dispatch isLong(NBTByte it, long exact) { value == exact }
	
	def static dispatch isLong(NBTBool it, long exact) { value == (exact != 0) }
	
	def static dispatch isLong(NBTValue it, long exact) { false }
	
	// isLong(min, max)
	
	def static dispatch isLong(NBTLong it, long min, long max) { value >= min && value <= max }
	
	def static dispatch isLong(NBTInt it, long min, long max) { value >= min && value <= max }
	
	def static dispatch isLong(NBTShort it, long min, long max) { value >= min && value <= max }
	
	def static dispatch isLong(NBTByte it, long min, long max) { value >= min && value <= max }
	
	def static dispatch isLong(NBTValue it, long min, long max) { false }
	
	// isInt
	
	def static isInt(NBTValue it) { it instanceof NBTInt || it instanceof NBTShort || it instanceof NBTByte || it instanceof NBTBool }
	
	// isInt(exact)
	
	def static dispatch isInt(NBTInt it, int exact) { value == exact }
	
	def static dispatch isInt(NBTShort it, int exact) { value == exact }
	
	def static dispatch isInt(NBTByte it, int exact) { value == exact }
	
	def static dispatch isInt(NBTValue it, int exact) { false }
	
	// isInt(min, max)
	
	def static dispatch isInt(NBTInt it, int min, int max) { value >= min && value <= max }
	
	def static dispatch isInt(NBTShort it, int min, int max) { value >= min && value <= max }
	
	def static dispatch isInt(NBTByte it, int min, int max) { value >= min && value <= max }
	
	def static dispatch isInt(NBTValue it, int min, int max) { false }
	
	// isShort
	
	def static dispatch isShort(NBTShort it) { true }
	
	def static dispatch isShort(NBTInt it) { value >= Short.MIN_VALUE && value <= Short.MAX_VALUE }
	
	def static dispatch isShort(NBTByte it) { true }
	
	def static dispatch isShort(NBTValue it) { false }
	
	// isShort(exact)
	
	def static dispatch isShort(NBTShort it, short exact) { value == exact }
	
	def static dispatch isShort(NBTInt it, short exact) { value == exact }
	
	def static dispatch isShort(NBTByte it, short exact) { value == exact }
	
	def static dispatch isShort(NBTValue it, short exact) { false }
	
	// isShort(min, max)
	
	def static dispatch isShort(NBTShort it, short min, short max) { value >= min && value <= max }
	
	def static dispatch isShort(NBTInt it, short min, short max) { value >= min && value <= max }
	
	def static dispatch isShort(NBTByte it, short min, short max) { value >= min && value <= max }
	
	def static dispatch isShort(NBTValue it, short min, short max) { false }
	
	// isConvertibleToShort
	
	def static dispatch isConvertibleToShort(NBTShort it) { Possibility.YES }
	
	def static dispatch isConvertibleToShort(NBTInt it) { if(value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTByte it) { Possibility.MAYBE }
	
	def static dispatch isConvertibleToShort(NBTValue it) { Possibility.NO }
	
	// isConvertibleToShort(exact)
	
	def static dispatch isConvertibleToShort(NBTShort it, short exact) { if(value == exact) Possibility.YES else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTInt it, short exact) { if(value == exact) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTByte it, short exact) { if(value == exact) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTValue it, short exact) { Possibility.NO }
	
	// isConvertibleToShort(min, max)
	
	def static dispatch isConvertibleToShort(NBTShort it, short min, short max) { if(value >= min && value <= max) Possibility.YES else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTInt it, short min, short max) { if(value >= min && value <= max) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTByte it, short min, short max) { if(value >= min && value <= max) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToShort(NBTValue it, short min, short max) { Possibility.NO }
	
	// isByte
	
	def static dispatch isByte(NBTByte it) { true }
	
	def static dispatch isByte(NBTShort it) { value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE }
	
	def static dispatch isByte(NBTInt it) { value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE }
	
	def static dispatch isByte(NBTValue it) { false }
	
	// isConvertibleToByte
	
	def static dispatch isConvertibleToByte(NBTByte it) { Possibility.YES }
	
	def static dispatch isConvertibleToByte(NBTShort it) { if(value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToByte(NBTInt it) { if(value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) Possibility.MAYBE else Possibility.NO }
	
	def static dispatch isConvertibleToByte(NBTValue it) { Possibility.NO }
	
	// isBool
	
	def static dispatch isBool(NBTBool it) { true }
	
	def static dispatch isBool(NBTInt it) { value == 0 || value == 1 }
	
	def static dispatch isBool(NBTByte it) { value == 0 || value == 1 }
	
	def static dispatch isBool(NBTValue it) { false }
	
	// isBool(exact)
	
	def static dispatch isBool(NBTBool it, boolean exact) { value == exact }
	
	def static dispatch isBool(NBTInt it, boolean exact) { exact == (value != 0) }
	
	def static dispatch isBool(NBTByte it, boolean exact) { exact == (value != 0) }
	
	// isArray
	
	def static isArray(NBTValue it) { it instanceof NBTArray }
	
	// isArray(size)
	
	def static isArray(NBTValue it, int size) { it instanceof NBTArray && (it as NBTArray).elements.size == size }
	
	// isArray(elementPredicate)
	
	def static boolean isArray(NBTValue it, (NBTValue)=>boolean elementPredicate) {
		if(it instanceof NBTArray) {
			for(element : elements) {
				if(!elementPredicate.apply(element))
					return false
			}
			return true
		}
	}
	
	// isArray(size, elementPredicate)
	
	def static isArray(NBTValue it, int size, (NBTValue)=>boolean elementPredicate) {
		if(it instanceof NBTArray) {
			val elements = it.elements
			if(elements.size != size)
				return false
			for(element : elements) {
				if(!elementPredicate.apply(element))
					return false
			}
			return true
		}
		return false
	}
	
	// isArray(minSize, maxSize)
	
	def static boolean isArray(NBTValue it, int minSize, int maxSize) {
		if(it instanceof NBTArray) {
			val size = it.elements.size
			return size >= minSize && size <= maxSize
		}
	}
	
	// isArray(minSize, maxSize, elementPredicate)
	
	def static isArray(NBTValue it, int minSize, int maxSize, (NBTValue)=>boolean elementPredicate) {
		if(it instanceof NBTArray) {
			val elements = it.elements
			if(elements.size < minSize || elements.size > maxSize)
				return false
			for(element : elements) {
				if(!elementPredicate.apply(element))
					return false
			}
			return true
		}
		return false
	}
	
	// isCompound
	
	def static isCompound(NBTValue it) { it instanceof NBTCompound }
	
	// isCompound(size)
	
	def static isCompound(NBTValue it, int size) { it instanceof NBTCompound && (it as NBTCompound).entries.size == size }
	
	// isCompound(minSize, maxSize)
	
	def static boolean isCompound(NBTValue it, int minSize, int maxSize) {
		if(it instanceof NBTCompound) {
			val size = entries.size
			return size >= minSize && size <= maxSize
		}
	}
	
	// isCompound(entryPredicate)
	
	def static boolean isCompound(NBTValue it, (String, NBTValue)=>boolean entryPredicate) {
		if(it instanceof NBTCompound) {
			for(entry : entries) {
				if(!entryPredicate.apply(entry.key, entry.value))
					return false
			}
			return true
		}
	}
	
	// isCompound(valuePredicate)
	
	def static boolean isCompound(NBTValue it, (NBTValue)=>boolean valuePredicate) {
		if(it instanceof NBTCompound) {
			for(entry : entries) {
				if(!valuePredicate.apply(entry.value))
					return false
			}
			return true
		}
	}
	
	// isCompound(keyPredicate)
	
	def static boolean isCompound(NBTValue it, Predicate<String> keyPredicate) {
		if(it instanceof NBTCompound) {
			for(entry : entries) {
				if(!keyPredicate.test(entry.key))
					return false
			}
			return true
		}
	}
	
	// isCompound(size, entryPredicate)
	
	def static boolean isCompound(NBTValue it, int size, (String, NBTValue)=>boolean entryPredicate) {
		if(it instanceof NBTCompound) {
			val entries = it.entries
			if(entries.size == size) {
				for(entry : entries) {
					if(!entryPredicate.apply(entry.key, entry.value))
						return false
				}
				return true
			}
		}
	}
	
	// isCompound(size, valuePredicate)
	
	def static boolean isCompound(NBTValue it, int size, (NBTValue)=>boolean valuePredicate) {
		if(it instanceof NBTCompound) {
			val entries = it.entries
			if(entries.size == size) {
				for(entry : entries) {
					if(!valuePredicate.apply(entry.value))
						return false
				}
				return true
			}
		}
	}
	
	// isCompound(size, keyPredicate)
	
	def static boolean isCompound(NBTValue it, int size, Predicate<String> keyPredicate) {
		if(it instanceof NBTCompound) {
			val entries = it.entries
			if(entries.size == size) {
				for(entry : entries) {
					if(!keyPredicate.test(entry.key))
						return false
				}
				return true
			}
		}
	}
	
	// isCompound(minSize, maxSize, entryPredicate)
	
	def static boolean isCompound(NBTValue it, int minSize, int maxSize, (String, NBTValue)=>boolean entryPredicate) {
		if(it instanceof NBTCompound) {
			val entries = it.entries
			if(entries.size >= minSize && entries.size <= maxSize) {
				for(entry : entries) {
					if(!entryPredicate.apply(entry.key, entry.value))
						return false
				}
				return true
			}
		}
	}
	
	// isCompound(minSize, maxSize, valuePredicate)
	
	def static boolean isCompound(NBTValue it, int minSize, int maxSize, (NBTValue)=>boolean valuePredicate) {
		if(it instanceof NBTCompound) {
			val entries = it.entries
			if(entries.size >= minSize && entries.size <= maxSize) {
				for(entry : entries) {
					if(!valuePredicate.apply(entry.value))
						return false
				}
				return true
			}
		}
	}
	
	// isCompound(minSize, maxSize, keyPredicate)
	
	def static boolean isCompound(NBTValue it, int minSize, int maxSize, Predicate<String> keyPredicate) {
		if(it instanceof NBTCompound) {
			val entries = it.entries
			if(entries.size >= minSize && entries.size <= maxSize) {
				for(entry : entries) {
					if(!keyPredicate.test(entry.key))
						return false
				}
				return true
			}
		}
	}
	
	// toMap()
	
	def static toMap(NBTCompound nbt) {
		val map = <String, NBTEntry>newHashMap()
		for(entry : nbt.entries) {
			map.put(entry.key, entry)
		}
		return ImmutableMap.copyOf(map)
	}
	
	static val predicates = new Predicates
	
	def package static s(int amount) { if(amount == 1) "" else "s" }
	
	static class Predicates {
		
		val _isByte = new BytePredicate(true)
		val _isByteExact = new BytePredicate(false)
		val _isShort = new ShortPredicate(true)
		val _isShortExact = new ShortPredicate(false)
		val _isInt = new IntPredicate
		val _isFloat = new FloatPredicate(true)
		val _isFloatExact = new FloatPredicate(false)
		val _isLong = new LongPredicate(true)
		val _isLongExact = new LongPredicate(false)
		val _isDouble = new DoublePredicate(true)
		val _isDoubleExact = new DoublePredicate(false)
		val _isString = new StringPredicate
		val _isArray = new ArrayPredicate
		val _isObject = new ObjectPredicate
		val _isBool = new BoolPredicate
		val _isIntArray = new IntArrayPredicate
		val _isByteArray = new ByteArrayPredicate
		val _isLongArray = new LongArrayPredicate
		
		def isByte() { _isByte }
		
		def isShort() { _isShort }
		
		def isInt() { _isInt }
		
		def isLong() { _isLong }
		
		def isFloat() { _isFloat }
		
		def isDouble() { _isDouble }
		
		def isString() { _isString }
		
		def ArrayPredicate isArray() { _isArray }
		
		def isObject() { _isObject }
		
		def isBool() { _isBool }
		
		def isLongArray() { _isLongArray }
		
		def isIntArray() { _isIntArray }
		
		def isByteArray() { _isByteArray }

		private static interface NBTValuePredicate {
			
			def boolean test(NBTValue it)
			
			def NBTValuePredicate operator_or(NBTValuePredicate pred) { new OrPredicate(this, pred) }
			
			def NBTValuePredicate operator_and(NBTValuePredicate pred) { new AndPredicate(this, pred) }
			
			def NBTValuePredicate operator_not() { new NegatedPredicate(this) }
			
			def String getExpected()
			
			def withExpected(String expectedStr) {
				val $this = this
				return new NBTValuePredicate {
					override test(NBTValue value) { $this.test(value) }
					
					override getExpected() { expectedStr }
				}
			}
			
		}
		
		@FinalFieldsConstructor
		private static class NegatedPredicate implements NBTValuePredicate {
			val NBTValuePredicate predicate
			
			override test(NBTValue it) { !predicate.test(it) }
			
			override operator_not() { predicate }
			
			override getExpected() '''anything except «IF predicate instanceof AndPredicate || predicate instanceof OrPredicate || predicate instanceof StringPredicate.EqualsStringPredicate2»(«predicate.expected»)«ELSE»«predicate.expected»«ENDIF»'''
			
		}
		
		@FinalFieldsConstructor
		private static class AndPredicate implements NBTValuePredicate {
			val NBTValuePredicate first
			val NBTValuePredicate second
			
			override test(NBTValue it) { first.test(it) && second.test(it) }
			
			override getExpected() '''«predStr(first)» and «predStr(second)»'''
			
			def static predStr(NBTValuePredicate pred) '''«IF pred instanceof OrPredicate || pred instanceof StringPredicate.EqualsStringPredicate2»(«pred.expected»)«ELSE»«pred.expected»«ENDIF»'''
			
		}
		
		@FinalFieldsConstructor
		private static class OrPredicate implements NBTValuePredicate {
			val NBTValuePredicate first
			val NBTValuePredicate second
			
			override test(NBTValue it) { first.test(it) || second.test(it) }
			
			override getExpected() '''«predStr(first)» or «predStr(second)»'''
			
			def static predStr(NBTValuePredicate pred) '''«IF pred instanceof StringPredicate.EqualsStringPredicate2»(«pred.expected»)«ELSE»«pred.expected»«ENDIF»'''
			
		}
		
		@FinalFieldsConstructor
		static class BytePredicate implements NBTValuePredicate {
			val boolean isLenient
			
			def dispatch test(NBTInt it) { isLenient && value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE }
						
			def dispatch test(NBTValue it) { it instanceof NBTByte || isLenient && it instanceof NBTBool }
			
			def lenient(boolean lenient) { if(lenient) predicates._isByte else predicates._isByteExact }
			
			def exact(int exact) { new ExactBytePredicate(isLenient, exact as byte) }
			
			def min(int min) { new MinBytePredicate(isLenient, min as byte) }
			
			def max(int max) { new MaxBytePredicate(isLenient, max as byte) }
			
			def range(int min, int max) { new RangeBytePredicate(isLenient, min as byte, max as byte) }
			
			override getExpected() '''a byte'''
			
			@FinalFieldsConstructor
			static class ExactBytePredicate implements NBTValuePredicate {
				val boolean isLenient
				val byte exact
				
				def dispatch test(NBTInt it) { isLenient && value == exact }
				
				def dispatch test(NBTBool it) { isLenient && value == (exact != 0) }
				
				def dispatch test(NBTByte it) { value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new ExactBytePredicate(lenient, exact) }
				
				override getExpected() '''a byte equal to «exact»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinBytePredicate implements NBTValuePredicate {
				val boolean isLenient
				val byte min
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= Byte.MAX_VALUE }
				
				def dispatch test(NBTBool it) { isLenient && if(value) min <= 1 else min <= 0 }
				
				def dispatch test(NBTByte it) { value >= min }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MinBytePredicate(lenient, min) }
				
				def max(int max) { new RangeBytePredicate(isLenient, min, max as byte) }
				
				override getExpected() '''a byte >= «min»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxBytePredicate implements NBTValuePredicate {
				val boolean isLenient
				val byte max
				
				def dispatch test(NBTInt it) { isLenient && value >= Byte.MIN_VALUE && value <= max }
				
				def dispatch test(NBTBool it) { isLenient && if(value) max >= 1 else max >= 0 }
				
				def dispatch test(NBTByte it) { value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MaxBytePredicate(lenient, max) }
				
				def min(int min) { new RangeBytePredicate(isLenient, min as byte, max) }
				
				override getExpected() '''a byte <= «max»''' 
				
			}
			
			@FinalFieldsConstructor
			static class RangeBytePredicate implements NBTValuePredicate {
				val boolean isLenient
				val byte min
				val byte max
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= max }
				
				
				def dispatch test(NBTBool it) { isLenient && if(value) 1 >= min && 1 <= max else 0 >= min && 0 <= max }
				def dispatch test(NBTByte it) { value >= min && value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new RangeBytePredicate(lenient, min, max) }
				
				override getExpected() '''a byte between «min» and «max»'''
				
			}
			
		}
	
		@FinalFieldsConstructor
		static class ShortPredicate implements NBTValuePredicate {
			val boolean isLenient
			
			def dispatch test(NBTInt it) { isLenient && value >= Short.MIN_VALUE && value <= Short.MAX_VALUE }
			
			def dispatch test(NBTValue it) { it instanceof NBTShort }
			
			def lenient(boolean lenient) { if(lenient) predicates._isShort else predicates._isShortExact }
			
			def exact(int exact) { new ExactShortPredicate(isLenient, exact as short) }
			
			def min(int min) { new MinShortPredicate(isLenient, min as short) }
			
			def max(int max) { new MaxShortPredicate(isLenient, max as short) }
			
			def range(int min, int max) { new RangeShortPredicate(isLenient, min as short, max as short) }
			
			override getExpected() '''a short'''
			
			@FinalFieldsConstructor
			static class ExactShortPredicate implements NBTValuePredicate {
				val boolean isLenient
				val short exact
				
				def dispatch test(NBTInt it) { isLenient && value == exact }
				
				def dispatch test(NBTShort it) { value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new ExactShortPredicate(lenient, exact) }
				
				override getExpected() '''a short equal to «exact»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinShortPredicate implements NBTValuePredicate {
				val boolean isLenient
				val short min
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= Short.MAX_VALUE }
				
				def dispatch test(NBTShort it) { value >= min }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MinShortPredicate(lenient, min) }
				
				def max(int max) { new RangeShortPredicate(isLenient, min, max as short) }
				
				override getExpected() '''a short >= «min»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxShortPredicate implements NBTValuePredicate {
				val boolean isLenient
				val short max
				
				def dispatch test(NBTInt it) { isLenient && value >= Short.MIN_VALUE && value <= max }
				
				def dispatch test(NBTShort it) { value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MaxShortPredicate(lenient, max) }
				
				def min(int min) { new RangeShortPredicate(isLenient, min as short, max) }
				
				override getExpected() '''a short <= «max»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeShortPredicate implements NBTValuePredicate {
				val boolean isLenient
				val short min
				val short max
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= max }
				
				def dispatch test(NBTShort it) { value >= min && value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new RangeShortPredicate(lenient, min, max) }
				
				override getExpected() '''a short between «min» and «max»'''
				
			}
			
		}
		
		static class IntPredicate implements NBTValuePredicate {
			
			override test(NBTValue it) { it instanceof NBTInt }
			
			def exact(int exact) { new ExactIntPredicate(exact) }
			
			def min(int min) { new MinIntPredicate(min) }
			
			def max(int max) { new MaxIntPredicate(max) }
			
			def range(int min, int max) { new RangeIntPredicate(min, max) }
			
			override getExpected() '''an int'''
			
			@FinalFieldsConstructor
			static class ExactIntPredicate implements NBTValuePredicate {
				val int exact
				
				def dispatch test(NBTInt it) { value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''an int equal to «exact»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinIntPredicate implements NBTValuePredicate {
				val int min
				
				def dispatch test(NBTInt it) { value >= min }
				
				def dispatch test(NBTValue it) { false }
				
				def max(int max) { new RangeIntPredicate(min, max) }
				
				override getExpected() '''an int >= «min»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxIntPredicate implements NBTValuePredicate {
				val int max
				
				def dispatch test(NBTInt it) { value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def min(int min) { new RangeIntPredicate(min, max) }
				
				override getExpected() '''an int <= «max»'''
			}
			
			@FinalFieldsConstructor
			static class RangeIntPredicate implements NBTValuePredicate {
				val int min
				val int max
				
				def dispatch test(NBTInt it) { value >= min && value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''an int between «min» and «max»'''
				
			}
			
		}
		
		@FinalFieldsConstructor
		static class LongPredicate implements NBTValuePredicate {
			val boolean isLenient
			
			override test(NBTValue it) { it instanceof NBTLong || isLenient && it instanceof NBTInt }
			
			def lenient(boolean lenient) { if(lenient) predicates._isLong else predicates._isLongExact }
			
			def exact(long exact) { new ExactLongPredicate(isLenient, exact) }
			
			def min(long min) { new MinLongPredicate(isLenient, min) }
			
			def max(long max) { new MaxLongPredicate(isLenient, max) }
			
			def range(long min, long max) { new RangeLongPredicate(isLenient, min, max) }
			
			override getExpected() '''a long'''
			
			@FinalFieldsConstructor
			static class ExactLongPredicate implements NBTValuePredicate {
				val boolean isLenient
				val long exact
				
				def dispatch test(NBTLong it) { value == exact }
				
				def dispatch test(NBTInt it) { isLenient && value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new ExactLongPredicate(lenient, exact) }
				
				override getExpected() '''a long equal to «exact»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinLongPredicate implements NBTValuePredicate {
				val boolean isLenient
				val long min
				
				def dispatch test(NBTLong it) { value >= min }
				
				def dispatch test(NBTInt it) { isLenient && value >= min }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MinLongPredicate(lenient, min) }
				
				def max(long max) { new RangeLongPredicate(isLenient, min, max) }
				
				override getExpected() '''a long >= «min»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxLongPredicate implements NBTValuePredicate {
				val boolean isLenient
				val long max
				
				def dispatch test(NBTLong it) { value <= max }
				
				def dispatch test(NBTInt it) { isLenient && value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MaxLongPredicate(lenient, max) }
				
				def min(long min) { new RangeLongPredicate(isLenient, min, max) }
				
				override getExpected() '''a long <= «max»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeLongPredicate implements NBTValuePredicate {
				val boolean isLenient
				val long min
				val long max
				
				def dispatch test(NBTLong it) { value >= min && value <= max }
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new RangeLongPredicate(lenient, min, max) }
				
				override getExpected() '''a long between «min» and «max»'''
				
			}
			
		}
		
		@FinalFieldsConstructor
		static class FloatPredicate implements NBTValuePredicate {
			val boolean isLenient
			
			def dispatch test(NBTDouble it) { isLenient && value === (value as float) }
			
			def dispatch test(NBTInt it) { isLenient && value === (value as float) }
			
			def dispatch test(NBTValue it) { it instanceof NBTFloat }
			
			def lenient(boolean lenient) { if(lenient) predicates._isFloat else predicates._isFloatExact }
			
			def exact(float exact) { new ExactFloatPredicate(isLenient, exact) }
			
			def min(float min) { new MinFloatPredicate(isLenient, min) }
			
			def max(float max) { new MaxFloatPredicate(isLenient, max) }
			
			def range(float min, float max) { new RangeFloatPredicate(isLenient, min, max) }
			
			override getExpected() '''a float'''
			
			@FinalFieldsConstructor
			static class ExactFloatPredicate implements NBTValuePredicate {
				val boolean isLenient
				val float exact
				
				def dispatch test(NBTDouble it) { isLenient && value == exact }
				
				def dispatch test(NBTFloat it) { value == exact }
				
				def dispatch test(NBTInt it) { isLenient && value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new ExactFloatPredicate(lenient, exact) }
				
				override getExpected() '''a float equal to «exact»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinFloatPredicate implements NBTValuePredicate {
				val boolean isLenient
				val float min
				
				def dispatch test(NBTDouble it) { isLenient && value >= min && value === (value as float) }
				
				def dispatch test(NBTFloat it) { value >= min }
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value === (value as float) }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MinFloatPredicate(lenient, min) }
				
				def max(float max) { new RangeFloatPredicate(isLenient, min, max) }
				
				override getExpected() '''a float >= «min»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxFloatPredicate implements NBTValuePredicate {
				val boolean isLenient
				val float max
				
				def dispatch test(NBTDouble it) { isLenient && value <= max && value === (value as float) }
				
				def dispatch test(NBTInt it) { isLenient && value <= max && value === (value as float) }
				
				def dispatch test(NBTFloat it) { value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MaxFloatPredicate(lenient, max) }
				
				def min(float min) { new RangeFloatPredicate(isLenient, min, max) }
				
				override getExpected() '''a float <= «max»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeFloatPredicate implements NBTValuePredicate {
				val boolean isLenient
				val float min
				val float max
				
				def dispatch test(NBTDouble it) { isLenient && value >= min && value <= max && value === (value as float) }
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= max && value == (value as float) }
				
				def dispatch test(NBTFloat it) { value >= min && value <= max }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new RangeFloatPredicate(lenient, min, max) }
				
				override getExpected() '''a float between «min» and «max»'''
				
			}
			
		}
		
		@FinalFieldsConstructor
		static class DoublePredicate implements NBTValuePredicate {
			val boolean isLenient
			
			def dispatch test(NBTInt it) { isLenient && value == (value as double) }
			
			def dispatch test(NBTValue it) { it instanceof NBTDouble }
			
			def dispatch test(Void it) { false }
			
			def lenient(boolean lenient) { if(lenient) predicates._isDouble else predicates._isDoubleExact }
			
			def exact(double exact) { new ExactDoublePredicate(isLenient, exact) }
			
			def min(double min) { new MinDoublePredicate(isLenient, min) }
			
			def max(double max) { new MaxDoublePredicate(isLenient, max) }
			
			def range(double min, double max) { new RangeDoublePredicate(isLenient, min, max) }
			
			override getExpected() '''a double'''
			
			@FinalFieldsConstructor
			static class ExactDoublePredicate implements NBTValuePredicate {
				val boolean isLenient
				val double exact
				
				def dispatch test(NBTDouble it) { value == exact }
				
				def dispatch test(NBTInt it) { isLenient && value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new ExactDoublePredicate(lenient, exact) }
				
				override getExpected() '''a double equal to «exact»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinDoublePredicate implements NBTValuePredicate {
				val boolean isLenient
				val double min
				
				def dispatch test(NBTDouble it) { value >= min }
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value === (value as double) }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MinDoublePredicate(lenient, min) }
				
				def max(double max) { new RangeDoublePredicate(isLenient, min, max) }
				
				override getExpected() '''a double >= «min»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxDoublePredicate implements NBTValuePredicate {
				val boolean isLenient
				val double max
				
				def dispatch test(NBTDouble it) { value <= max }
				
				def dispatch test(NBTInt it) { isLenient && value <= max && value === (value as double) }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new MaxDoublePredicate(lenient, max) }
				
				def min(double min) { new RangeDoublePredicate(isLenient, min, max) }
				
				override getExpected() '''a double <= «max»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeDoublePredicate implements NBTValuePredicate {
				val boolean isLenient
				val double min
				val double max
				
				def dispatch test(NBTDouble it) { value >= min && value <= max }
				
				def dispatch test(NBTInt it) { isLenient && value >= min && value <= max && value === (value as double) }
				
				def dispatch test(NBTValue it) { false }
				
				def lenient(boolean lenient) { if(lenient === isLenient) this else new RangeDoublePredicate(lenient, min, max) }
				
				override getExpected() '''a double between «min» and «max»'''
				
			}
			
		}
		
		static class StringPredicate implements NBTValuePredicate {
			
			override test(NBTValue it) { it instanceof NBTString }
			
			def equalTo(String str) { new EqualsStringPredicate(str) }
			
			def equalTo(Set<String> strs) { if(strs.isEmpty) this else new EqualsStringPredicate2(strs) }
			
			def equalTo(String... strs) { if(strs.length > 0) new EqualsStringPredicate2(newHashSet(strs)) else this }
			
			def startingWith(String str) { new PrefixStringPredicate(str) }
			
			def endingWith(String str) { new SuffixStringPredicate(str) }
			
			def matching(String regex) { new RegexStringPredicate(Pattern.compile(regex)) }
			
			override getExpected() '''a string'''
			
			def static String stringName(String str) '''«IF str.isEmpty»the empty string«ELSE»the string "«Strings.convertToJavaString(str, false)»"«ENDIF»'''
			
			@FinalFieldsConstructor
			static class EqualsStringPredicate implements NBTValuePredicate {
				val String exact
				
				def dispatch test(NBTString it) { value == exact }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() { stringName(exact) }
				
			}
			
			@FinalFieldsConstructor
			static class EqualsStringPredicate2 implements NBTValuePredicate {
				val Set<String> strs
				
				def dispatch test(NBTString it) { strs.contains(value) }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() {
					val sb = new StringBuilder
					var first = true
					var size = strs.size
					if(strs.contains("")) {
						if(size > 1)
							sb.append("either ")
						sb.append("the empty string")
						first = false
						size--
					}
					var first2 = true
					for(str : strs) {
						if(!str.isEmpty) {
							if(first) first = false
							else sb.append(" or ")
							if(first2) {
								if(size > 1)
									sb.append("one of the strings ")
								else
									sb.append("the string")
								first2 = false
							}
							sb.append('"').append(Strings.convertToJavaString(str, false)).append('"')
						}
					}
					sb.toString()
				}
				
			}
			
			@FinalFieldsConstructor
			static class PrefixStringPredicate implements NBTValuePredicate {
				val String prefix
				
				def dispatch test(NBTString it) { value.startsWith(prefix) }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''«IF prefix.isEmpty»a string«ELSE»a string beginnning with "«Strings.convertToJavaString(prefix, false)»"«ENDIF»'''
							
			}
			
			@FinalFieldsConstructor
			static class SuffixStringPredicate implements NBTValuePredicate {
				val String suffix
				
				def dispatch test(NBTString it) { value.endsWith(suffix) }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''«IF suffix.isEmpty»a string«ELSE»a string ending with "«Strings.convertToJavaString(suffix, false)»"«ENDIF»'''
				
			}
			
			static class RegexStringPredicate implements NBTValuePredicate {
				val Matcher matcher
				
				new(Pattern regex) {
					matcher = regex.matcher("")
				}
				
				def dispatch test(NBTString it) { matcher.reset(value).matches() }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''a string matching the regular expression «matcher.pattern»'''
				
			}
			
		}


		interface IArrayPredicate extends NBTValuePredicate {
			
			def operator_and(IArrayPredicate other) { new AndArrayPredicate(this, other) }
			
			def operator_or(IArrayPredicate other) { new OrArrayPredicate(this, other) }
			
			static class AndArrayPredicate extends AndPredicate implements IArrayPredicate {
	
				new(NBTValuePredicate first, NBTValuePredicate second) {
					super(first, second)
				}
				
			}
			
			static class OrArrayPredicate extends OrPredicate implements IArrayPredicate {
				
				new(NBTValuePredicate first, NBTValuePredicate second) {
					super(first, second)
				}
				
			}
			
		}
		
		interface IArrayPredicate2 extends IArrayPredicate3, IArrayPredicate4 {
			
			def IArrayPredicate size(int size)
			
			def IArrayPredicate rangeSize(int minSize, int maxSize)
			
		}
		
		interface IArrayPredicate3 extends IArrayPredicate {
			
			def IArrayPredicate maxSize(int maxSize)
			
		}
		
		interface IArrayPredicate4 extends IArrayPredicate {
			
			def IArrayPredicate minSize(int minSize)
			
		}

		static class ArrayPredicate implements IArrayPredicate2 {
			
			override test(NBTValue it) { it instanceof NBTArray }
			
			override SizeArrayPredicate size(int size) { new SizeArrayPredicate(size) }
			
			override MinSizeArrayPredicate minSize(int minSize) { new MinSizeArrayPredicate(minSize) }
			
			override MaxSizeArrayPredicate maxSize(int maxSize) { new MaxSizeArrayPredicate(maxSize) }
			
			override RangeSizeArrayPredicate rangeSize(int minSize, int maxSize) { new RangeSizeArrayPredicate(minSize, maxSize) }
			
			def matching(NBTValuePredicate elementPredicate) { new MatchingArrayPredicate(elementPredicate) }
			
			override getExpected() '''an array'''			
			
			@FinalFieldsConstructor
			static class SizeArrayPredicate implements IArrayPredicate {
				val int exactSize
				
				def dispatch test(NBTArray it) { elements.size == exactSize }
				
				def dispatch test(NBTValue it) { false }
				
				def matching(NBTValuePredicate elementPredicate) { new SizeMatchingArrayPredicate(exactSize, elementPredicate) }
				
				override getExpected() '''an array of size «exactSize»'''
				
				@FinalFieldsConstructor
				static class SizeMatchingArrayPredicate implements IArrayPredicate {
					val int exactSize
					val NBTValuePredicate elementPredicate
					
					def dispatch test(NBTArray it) {
						if(elements.size == exactSize) {
							for(element : elements) {
								if(!elementPredicate.test(element))
									return false
							}
							return true
						}
						return false
					}
					
					def dispatch test(NBTValue it) { false }
					
					override getExpected() '''an array of size «exactSize» where each element is «elementPredicate.expected»'''
					
				}
				
			}
			
			@FinalFieldsConstructor
			static class MinSizeArrayPredicate implements IArrayPredicate3 {
				val int minSize
				
				def dispatch test(NBTArray it) { elements.size >= minSize }
				
				def dispatch test(NBTValue it) { false }
				
				override RangeSizeArrayPredicate maxSize(int maxSize) { new RangeSizeArrayPredicate(minSize, maxSize) }
				
				def matching(NBTValuePredicate elementPredicate) { new MinSizeMatchingArrayPredicate(minSize, elementPredicate) }
				
				override getExpected() '''an array of at least «minSize» element«s(minSize)»'''
				
				@FinalFieldsConstructor
				static class MinSizeMatchingArrayPredicate implements IArrayPredicate3 {
					val int minSize
					val NBTValuePredicate elementPredicate
					
					def dispatch test(NBTArray it) {
						if(elements.size >= minSize) {
							for(element : elements) {
								if(!elementPredicate.test(element))
									return false
							}
							return true
						}
						return false
					}
					
					def dispatch test(NBTValue it) { false }
					
					override RangeSizeArrayPredicate.RangeSizeMatchingArrayPredicate maxSize(int maxSize) { new RangeSizeArrayPredicate.RangeSizeMatchingArrayPredicate(minSize, maxSize, elementPredicate) }
					
					override getExpected() '''an array of at least «minSize» element«s(minSize)» where each element is «elementPredicate.expected»'''
					
				}
				
			}
			
			@FinalFieldsConstructor
			static class MaxSizeArrayPredicate implements IArrayPredicate4 {
				val int maxSize
				
				def dispatch test(NBTArray it) { elements.size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				override RangeSizeArrayPredicate minSize(int minSize) { new RangeSizeArrayPredicate(minSize, maxSize) }
				
				def matching(NBTValuePredicate elementPredicate) { new MaxSizeMatchingArrayPredicate(maxSize, elementPredicate) }
				
				override getExpected() '''an array of at most «maxSize» element«s(maxSize)»'''
				
				@FinalFieldsConstructor
				static class MaxSizeMatchingArrayPredicate implements IArrayPredicate4 {
					val int maxSize
					val NBTValuePredicate elementPredicate
					
					def dispatch test(NBTArray it) {
						if(elements.size <= maxSize) {
							for(element : elements) {
								if(!elementPredicate.test(element))
									return false
							}
							return true
						}
						return false
					}
					
					def dispatch test(NBTValue it) { false }
					
					override RangeSizeArrayPredicate.RangeSizeMatchingArrayPredicate minSize(int minSize) { new RangeSizeArrayPredicate.RangeSizeMatchingArrayPredicate(minSize, maxSize, elementPredicate) }
					
					override getExpected() '''an array of at most «maxSize» element«s(maxSize)» where each element is «elementPredicate.expected»'''
					
				}
				
			}
			
			@FinalFieldsConstructor
			static class RangeSizeArrayPredicate implements IArrayPredicate {
				val int minSize
				val int maxSize
				
				def dispatch test(NBTArray it) { val size = elements.size; size >= minSize && size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				def matching(NBTValuePredicate elementPredicate) { new RangeSizeMatchingArrayPredicate(minSize, maxSize, elementPredicate) }
				
				override getExpected() '''an array of size between «minSize» and «maxSize»'''
				
				@FinalFieldsConstructor
				static class RangeSizeMatchingArrayPredicate implements IArrayPredicate {
					val int minSize
					val int maxSize
					val NBTValuePredicate elementPredicate
					
					def dispatch test(NBTArray it) {
						val size = elements.size
						if(size >= minSize && size <= maxSize) {
							for(element : elements) {
								if(!elementPredicate.test(element))
									return false
							}
							return true
						}
						return false
					}
					
					def dispatch test(NBTValue it) { false }
					
					override getExpected() '''an array of size between «minSize» and «maxSize» where each element is «elementPredicate.expected»'''
					
				}
				
			}
			
			@FinalFieldsConstructor
			static class MatchingArrayPredicate implements IArrayPredicate {
				val NBTValuePredicate elementPredicate
				
				def dispatch test(NBTArray it) {
					for(element : elements) {
						if(!elementPredicate.test(element))
							return false
					}
					return true
				}
				
				def dispatch test(NBTValue it) { false }
				
				def minSize(int minSize) { new MinSizeArrayPredicate.MinSizeMatchingArrayPredicate(minSize, elementPredicate) }
				
				def maxSize(int maxSize) { new MaxSizeArrayPredicate.MaxSizeMatchingArrayPredicate(maxSize, elementPredicate) }
				
				def rangeSize(int minSize, int maxSize) { new RangeSizeArrayPredicate.RangeSizeMatchingArrayPredicate(minSize, maxSize, elementPredicate) }
				
				override getExpected() '''an array where each element is «elementPredicate.expected»'''
				
			}
			
		}
		
		static class IntArrayPredicate implements NBTValuePredicate {
			
			override test(NBTValue it) { it instanceof NBTIntArray }
			
			def size(int exactSize) { new SizeIntArrayPredicate(exactSize) }
			
			def minSize(int minSize) { new MinSizeIntArrayPredicate(minSize) }
			
			def maxSize(int maxSize) { new MaxSizeIntArrayPredicate(maxSize) }
			
			def rangeSize(int minSize, int maxSize) { new RangeSizeIntArrayPredicate(minSize, maxSize) }
			
			override getExpected() '''an int array'''
			
			@FinalFieldsConstructor
			static class SizeIntArrayPredicate implements NBTValuePredicate {
				val int exactSize
				
				def dispatch test(NBTIntArray it) { elements.size == exactSize }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''an int array of size «exactSize»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinSizeIntArrayPredicate implements NBTValuePredicate {
				val int minSize
				
				def dispatch test(NBTIntArray it) { elements.size >= minSize }
				
				def dispatch test(NBTValue it) { false }
				
				def maxSize(int maxSize) { new RangeSizeIntArrayPredicate(minSize, maxSize) }
				
				override getExpected() '''an int array of at least «minSize» int«s(minSize)»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxSizeIntArrayPredicate implements NBTValuePredicate {
				val int maxSize
				
				def dispatch test(NBTIntArray it) { elements.size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				def minSize(int minSize) { new RangeSizeIntArrayPredicate(minSize, maxSize) }
				
				override getExpected() '''an int array of at most «maxSize» int«s(maxSize)»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeSizeIntArrayPredicate implements NBTValuePredicate {
				val int minSize
				val int maxSize
				
				def dispatch test(NBTArray it) { val size = elements.size; size >= minSize && size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''an int array of size between «minSize» and «maxSize»'''
				
			}
			
		}
		
		static class LongArrayPredicate implements NBTValuePredicate {
			
			override test(NBTValue it) { it instanceof NBTLongArray }
			
			def size(int exactSize) { new SizeLongArrayPredicate(exactSize) }
			
			def minSize(int minSize) { new MinSizeLongArrayPredicate(minSize) }
			
			def maxSize(int maxSize) { new MaxSizeLongArrayPredicate(maxSize) }
			
			def rangeSize(int minSize, int maxSize) { new RangeSizeLongArrayPredicate(minSize, maxSize) }
			
			override getExpected() '''a long array'''
			
			@FinalFieldsConstructor
			static class SizeLongArrayPredicate implements NBTValuePredicate {
				val int exactSize
				
				def dispatch test(NBTLongArray it) { elements.size == exactSize }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''a long array of size «exactSize»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinSizeLongArrayPredicate implements NBTValuePredicate {
				val int minSize
				
				def dispatch test(NBTLongArray it) { elements.size >= minSize }
				
				def dispatch test(NBTValue it) { false }
				
				def maxSize(int maxSize) { new RangeSizeLongArrayPredicate(minSize, maxSize) }
				
				override getExpected() '''a long array of at least «minSize» long«s(minSize)»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxSizeLongArrayPredicate implements NBTValuePredicate {
				val int maxSize
				
				def dispatch test(NBTLongArray it) { elements.size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				def minSize(int minSize) { new RangeSizeLongArrayPredicate(minSize, maxSize) }
				
				override getExpected() '''a long array of at most «maxSize» long«s(maxSize)»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeSizeLongArrayPredicate implements NBTValuePredicate {
				val int minSize
				val int maxSize
				
				def dispatch test(NBTArray it) { val size = elements.size; size >= minSize && size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''a long array of size between «minSize» and «maxSize»'''
				
			}
			
		}
		
		static class ByteArrayPredicate implements NBTValuePredicate {
			
			override test(NBTValue it) { it instanceof NBTByteArray }
			
			def size(int exactSize) { new SizeByteArrayPredicate(exactSize) }
			
			def minSize(int minSize) { new MinSizeByteArrayPredicate(minSize) }
			
			def maxSize(int maxSize) { new MaxSizeByteArrayPredicate(maxSize) }
			
			def rangeSize(int minSize, int maxSize) { new RangeSizeByteArrayPredicate(minSize, maxSize) }
			
			override getExpected() '''a byte array'''
			
			@FinalFieldsConstructor
			static class SizeByteArrayPredicate implements NBTValuePredicate {
				val int exactSize
				
				def dispatch test(NBTByteArray it) { elements.size == exactSize }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''a byte array of size «exactSize»'''
				
			}
			
			@FinalFieldsConstructor
			static class MinSizeByteArrayPredicate implements NBTValuePredicate {
				val int minSize
				
				def dispatch test(NBTByteArray it) { elements.size >= minSize }
				
				def dispatch test(NBTValue it) { false }
				
				def maxSize(int maxSize) { new RangeSizeByteArrayPredicate(minSize, maxSize) }
				
				override getExpected() '''a byte array of at least «minSize» byte«s(minSize)»'''
				
			}
			
			@FinalFieldsConstructor
			static class MaxSizeByteArrayPredicate implements NBTValuePredicate {
				val int maxSize
				
				def dispatch test(NBTByteArray it) { elements.size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				def minSize(int minSize) { new RangeSizeByteArrayPredicate(minSize, maxSize) }
				
				override getExpected() '''a byte array of at most «maxSize» byte«s(maxSize)»'''
				
			}
			
			@FinalFieldsConstructor
			static class RangeSizeByteArrayPredicate implements NBTValuePredicate {
				val int minSize
				val int maxSize
				
				def dispatch test(NBTArray it) { val size = elements.size; size >= minSize && size <= maxSize }
				
				def dispatch test(NBTValue it) { false }
				
				override getExpected() '''a byte array of size between «minSize» and «maxSize»'''
				
			}
			
		}
		
		static class ObjectPredicate implements NBTValuePredicate {
			
			override test(NBTValue it) { it instanceof NBTCompound }
			
			override getExpected() '''a tag compound'''
				
		}
		
		static class BoolPredicate implements NBTValuePredicate {
			
			def dispatch test(NBTInt it) { value == 0 || value == 1 }
			
			def dispatch test(NBTByte it) { value == 0 || value == 1 }
			
			def dispatch test(NBTValue it) { it instanceof NBTBool }
			
			override getExpected() '''a boolean value (1 or 0)'''
			
		}
		
		def wrap((NBTValue)=>boolean tester, String expectedMsg) {
			new NBTValuePredicate {
				override test(NBTValue value) { tester.apply(value) }
				
				override getExpected() { expectedMsg }
			}
		}
		
	}
	
}
