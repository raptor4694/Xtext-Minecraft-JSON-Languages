/**
 * generated by Xtext 2.21.0
 */
package com.raptor.mcloottable.validation;

import com.google.common.base.Objects;
import com.raptor.mcloottable.mcloot.ApplyBonusLootFunction;
import com.raptor.mcloottable.mcloot.DoubleRange;
import com.raptor.mcloottable.mcloot.EnumLootTableType;
import com.raptor.mcloottable.mcloot.ExactDoubleRange;
import com.raptor.mcloottable.mcloot.ExactLongRange;
import com.raptor.mcloottable.mcloot.LongRange;
import com.raptor.mcloottable.mcloot.LootEntry;
import com.raptor.mcloottable.mcloot.LootPool;
import com.raptor.mcloottable.mcloot.LootTable;
import com.raptor.mcloottable.mcloot.MclootPackage;
import com.raptor.mcloottable.mcloot.NormalDoubleRange;
import com.raptor.mcloottable.mcloot.NormalLongRange;
import com.raptor.mcloottable.util.MclootUtils;
import com.raptor.mcloottable.util.MinecraftData;
import com.raptor.mcloottable.validation.AbstractMclootValidator;
import com.raptor.mcloottable.validation.SeenInfo;
import java.util.HashMap;
import java.util.List;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MclootValidator extends AbstractMclootValidator {
  @Check
  public void checkLootTable(final LootTable it) {
    boolean _isPoolsDefined = it.isPoolsDefined();
    if (_isPoolsDefined) {
      if ((it.isTypeDefined() && Objects.equal(it.getType(), EnumLootTableType.EMPTY))) {
        this.error("Type \'empty\' cannot specify any pools", 
          MclootPackage.Literals.LOOT_TABLE__POOLS_DEFINED);
      } else {
        boolean _isEmpty = it.getPools().isEmpty();
        if (_isEmpty) {
          this.error("No pools given", 
            MclootPackage.Literals.LOOT_TABLE__POOLS_DEFINED);
        }
      }
    } else {
      if ((it.isTypeDefined() && (!Objects.equal(it.getType(), EnumLootTableType.EMPTY)))) {
        this.error("No pools given", 
          MclootPackage.Literals.LOOT_TABLE__TYPE_DEFINED);
      }
    }
    boolean _isEmpty_1 = it.getPools().isEmpty();
    boolean _not = (!_isEmpty_1);
    if (_not) {
      final Function1<LootPool, String> _function = (LootPool it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Duplicate loot pool \"");
        String _name = it_1.getName();
        _builder.append(_name);
        _builder.append("\"");
        return _builder.toString();
      };
      this.<LootPool>checkUnique(it.getPools(), MclootPackage.Literals.LOOT_POOL__NAME, _function);
    }
  }
  
  @Check
  public void checkLootPool(final LootPool it) {
    boolean _isEmpty = it.getEntries().isEmpty();
    if (_isEmpty) {
      EAttribute _xifexpression = null;
      boolean _isEntriesDefined = it.isEntriesDefined();
      if (_isEntriesDefined) {
        _xifexpression = MclootPackage.Literals.LOOT_POOL__ENTRIES_DEFINED;
      } else {
        _xifexpression = MclootPackage.Literals.LOOT_POOL__NAME;
      }
      this.error("No entries given", _xifexpression);
    } else {
      final Function1<LootEntry, String> _function = (LootEntry it_1) -> {
        String _elvis = null;
        String _entryName = it_1.getEntryName();
        if (_entryName != null) {
          _elvis = _entryName;
        } else {
          String _name = it_1.getName();
          _elvis = _name;
        }
        return _elvis;
      };
      final Function1<LootEntry, EStructuralFeature> _function_1 = (LootEntry it_1) -> {
        EAttribute _xifexpression_1 = null;
        String _entryName = it_1.getEntryName();
        boolean _tripleEquals = (_entryName == null);
        if (_tripleEquals) {
          _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__NAME;
        } else {
          _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__ENTRY_NAME;
        }
        return _xifexpression_1;
      };
      final Function1<LootEntry, String> _function_2 = (LootEntry it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Duplicate loot pool \"");
        String _elvis = null;
        String _entryName = it_1.getEntryName();
        if (_entryName != null) {
          _elvis = _entryName;
        } else {
          String _name = it_1.getName();
          _elvis = _name;
        }
        _builder.append(_elvis);
        _builder.append("\"");
        return _builder.toString();
      };
      this.<LootEntry, String>checkUnique(true, it.getEntries(), _function, _function_1, _function_2);
    }
    boolean _isRollsDefined = it.isRollsDefined();
    if (_isRollsDefined) {
      this.checkULongRange(it.getRolls());
    }
    if ((it.isFunctionsDefined() && it.getFunctions().isEmpty())) {
      this.warning("No functions given", 
        MclootPackage.Literals.LOOT_POOL__FUNCTIONS_DEFINED);
    }
  }
  
  @Check
  public void checkLootEntry(final LootEntry it) {
    String _type = it.getType();
    if (_type != null) {
      switch (_type) {
        case "tag":
          final Procedure1<String> _function = (String name) -> {
            boolean _contains = MinecraftData.VANILLA_ITEM_TAGS.contains(name);
            boolean _not = (!_contains);
            if (_not) {
              this.warning("Unknown vanilla item tag", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
            String _name = it.getName();
            boolean _tripleNotEquals = (name != _name);
            if (_tripleNotEquals) {
              this.info("Namespace defaulting to \'minecraft\'", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
          };
          MclootUtils.ifMinecraftKey(it.getName(), _function);
          break;
        case "item":
          final Procedure1<String> _function_1 = (String name) -> {
            boolean _contains = MinecraftData.VANILLA_ITEMS.contains(name);
            boolean _not = (!_contains);
            if (_not) {
              this.warning("Unknown vanilla item name", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
            String _name = it.getName();
            boolean _tripleNotEquals = (name != _name);
            if (_tripleNotEquals) {
              this.info("Namespace defaulting to \'minecraft\'", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
          };
          MclootUtils.ifMinecraftKey(it.getName(), _function_1);
          break;
        case "loot_table":
          final Procedure1<String> _function_2 = (String name) -> {
            boolean _contains = MinecraftData.VANILLA_LOOT_TABLES.contains(name);
            boolean _not = (!_contains);
            if (_not) {
              this.warning("Unknown vanilla loot table", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
            String _name = it.getName();
            boolean _tripleNotEquals = (name != _name);
            if (_tripleNotEquals) {
              this.info("Namespace defaulting to \'minecraft\'", 
                MclootPackage.Literals.LOOT_ENTRY__NAME);
            }
          };
          MclootUtils.ifMinecraftKey(it.getName(), _function_2);
          break;
        case "group":
        case "alternatives":
        case "sequence":
          boolean _isEmpty = it.getChildren().isEmpty();
          if (_isEmpty) {
            EAttribute _xifexpression = null;
            boolean _isChildrenDefined = it.isChildrenDefined();
            if (_isChildrenDefined) {
              _xifexpression = MclootPackage.Literals.LOOT_ENTRY__CHILDREN_DEFINED;
            } else {
              EAttribute _xifexpression_1 = null;
              String _entryName = it.getEntryName();
              boolean _tripleNotEquals = (_entryName != null);
              if (_tripleNotEquals) {
                _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__ENTRY_NAME;
              } else {
                _xifexpression_1 = MclootPackage.Literals.LOOT_ENTRY__TYPE;
              }
              _xifexpression = _xifexpression_1;
            }
            this.error("No children given", _xifexpression);
          }
          break;
      }
    }
    if ((it.isFunctionsDefined() && it.getFunctions().isEmpty())) {
      this.warning("No functions given", 
        MclootPackage.Literals.LOOT_ENTRY__FUNCTIONS_DEFINED);
    }
    if ((it.isWeightDefined() && (it.getWeight() <= 0))) {
      this.error("Weight must be at least 1", 
        MclootPackage.Literals.LOOT_ENTRY__WEIGHT);
    }
  }
  
  @Check
  public Object checkLootFunction(final ApplyBonusLootFunction it) {
    return null;
  }
  
  @Check
  public void checkLongRange(final NormalLongRange it) {
    if ((MclootUtils.isMinDefined(it) && MclootUtils.isMaxDefined(it))) {
      long _min = it.getMin();
      long _max = it.getMax();
      boolean _greaterThan = (_min > _max);
      if (_greaterThan) {
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
      } else {
        long _min_1 = it.getMin();
        long _max_1 = it.getMax();
        boolean _equals = (_min_1 == _max_1);
        if (_equals) {
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
        }
      }
    }
  }
  
  @Check
  public void checkNormalDoubleRange(final NormalDoubleRange it) {
    if ((MclootUtils.isMinDefined(it) && MclootUtils.isMaxDefined(it))) {
      double _min = it.getMin();
      double _max = it.getMax();
      boolean _greaterThan = (_min > _max);
      if (_greaterThan) {
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
        this.error("Range start cannot be greater than range end", 
          MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
      } else {
        double _min_1 = it.getMin();
        double _max_1 = it.getMax();
        boolean _equals = (_min_1 == _max_1);
        if (_equals) {
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
          this.warning("Range size == 1, don\'t need range syntax", 
            MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
        }
      }
    }
  }
  
  public void checkLongRange(final LongRange range, final Long min_param, final Long max_param) {
    Long _elvis = null;
    if (min_param != null) {
      _elvis = min_param;
    } else {
      _elvis = Long.valueOf(Long.MIN_VALUE);
    }
    final long min = (long) _elvis;
    Long _elvis_1 = null;
    if (max_param != null) {
      _elvis_1 = max_param;
    } else {
      _elvis_1 = Long.valueOf(Long.MAX_VALUE);
    }
    final long max = (long) _elvis_1;
    boolean _matched = false;
    if (range instanceof ExactLongRange) {
      _matched=true;
      long _value = ((ExactLongRange)range).getValue();
      boolean _lessThan = (_value < min);
      if (_lessThan) {
        this.error("Value is too small", range, 
          MclootPackage.Literals.EXACT_LONG_RANGE__VALUE);
      } else {
        long _value_1 = ((ExactLongRange)range).getValue();
        boolean _greaterThan = (_value_1 > max);
        if (_greaterThan) {
          this.error("Value is too large", range, 
            MclootPackage.Literals.EXACT_LONG_RANGE__VALUE);
        }
      }
    }
    if (!_matched) {
      if (range instanceof NormalLongRange) {
        _matched=true;
        boolean _isMinDefined = MclootUtils.isMinDefined(((NormalLongRange)range));
        if (_isMinDefined) {
          long _min = ((NormalLongRange)range).getMin();
          boolean _lessThan = (_min < min);
          if (_lessThan) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
          } else {
            long _min_1 = ((NormalLongRange)range).getMin();
            boolean _greaterThan = (_min_1 > max);
            if (_greaterThan) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_LONG_RANGE__MIN);
            }
          }
        }
        boolean _isMaxDefined = MclootUtils.isMaxDefined(((NormalLongRange)range));
        if (_isMaxDefined) {
          long _max = ((NormalLongRange)range).getMax();
          boolean _lessThan_1 = (_max < min);
          if (_lessThan_1) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
          } else {
            long _max_1 = ((NormalLongRange)range).getMax();
            boolean _greaterThan_1 = (_max_1 > max);
            if (_greaterThan_1) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_LONG_RANGE__MAX);
            }
          }
        }
      }
    }
  }
  
  public void checkULongRange(final LongRange range) {
    this.checkLongRange(range, Long.valueOf(0L), null);
  }
  
  public void checkDoubleRange(final DoubleRange range, final Double min_param, final Double max_param) {
    Double _elvis = null;
    if (min_param != null) {
      _elvis = min_param;
    } else {
      _elvis = Double.valueOf(Double.NEGATIVE_INFINITY);
    }
    final double min = (double) _elvis;
    Double _elvis_1 = null;
    if (max_param != null) {
      _elvis_1 = max_param;
    } else {
      _elvis_1 = Double.valueOf(Double.POSITIVE_INFINITY);
    }
    final double max = (double) _elvis_1;
    boolean _matched = false;
    if (range instanceof ExactDoubleRange) {
      _matched=true;
      double _value = ((ExactDoubleRange)range).getValue();
      boolean _lessThan = (_value < min);
      if (_lessThan) {
        this.error("Value is too small", range, 
          MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE);
      } else {
        double _value_1 = ((ExactDoubleRange)range).getValue();
        boolean _greaterThan = (_value_1 > max);
        if (_greaterThan) {
          this.error("Value is too large", range, 
            MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE);
        }
      }
    }
    if (!_matched) {
      if (range instanceof NormalDoubleRange) {
        _matched=true;
        boolean _isMinDefined = MclootUtils.isMinDefined(((NormalDoubleRange)range));
        if (_isMinDefined) {
          double _min = ((NormalDoubleRange)range).getMin();
          boolean _lessThan = (_min < min);
          if (_lessThan) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
          } else {
            double _min_1 = ((NormalDoubleRange)range).getMin();
            boolean _greaterThan = (_min_1 > max);
            if (_greaterThan) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
            }
          }
        }
        boolean _isMaxDefined = MclootUtils.isMaxDefined(((NormalDoubleRange)range));
        if (_isMaxDefined) {
          double _max = ((NormalDoubleRange)range).getMax();
          boolean _lessThan_1 = (_max < min);
          if (_lessThan_1) {
            this.error("Value is too small", range, 
              MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
          } else {
            double _max_1 = ((NormalDoubleRange)range).getMax();
            boolean _greaterThan_1 = (_max_1 > max);
            if (_greaterThan_1) {
              this.error("Value is too large", range, 
                MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
            }
          }
        }
      }
    }
  }
  
  public void checkPercentageRange(final DoubleRange range) {
    boolean _matched = false;
    if (range instanceof ExactDoubleRange) {
      _matched=true;
      this.checkPercentage(range, MclootPackage.Literals.EXACT_DOUBLE_RANGE__VALUE);
    }
    if (!_matched) {
      if (range instanceof NormalDoubleRange) {
        _matched=true;
        boolean _isMinDefined = MclootUtils.isMinDefined(((NormalDoubleRange)range));
        if (_isMinDefined) {
          this.checkPercentage(range, MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MIN);
        }
        boolean _isMaxDefined = MclootUtils.isMaxDefined(((NormalDoubleRange)range));
        if (_isMaxDefined) {
          this.checkPercentage(range, MclootPackage.Literals.NORMAL_DOUBLE_RANGE__MAX);
        }
      }
    }
  }
  
  public void checkPercentage(final EObject object, final EStructuralFeature feature) {
    Object _eGet = object.eGet(feature);
    final double value = (((Double) _eGet)).doubleValue();
    if (((value < 0) || (value > 1))) {
      this.error("Value must be between 0 and 1", object, feature);
    }
  }
  
  protected static boolean isWithin(final double value, final double min, final double max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static boolean isWithin(final float value, final float min, final float max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static boolean isWithin(final long value, final long min, final long max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static boolean isWithin(final int value, final int min, final int max) {
    return ((min <= value) && (value <= max));
  }
  
  protected static <T extends Object> SeenInfo<T> seen(final T value) {
    return new SeenInfo<T>(value);
  }
  
  protected static <K extends Object, T extends Object> HashMap<K, SeenInfo<T>> newSeenMap() {
    return new HashMap<K, SeenInfo<T>>();
  }
  
  protected static <K extends Object, T extends Object> HashMap<K, SeenInfo<T>> newSeenMap(final int capacity) {
    return new HashMap<K, SeenInfo<T>>(capacity);
  }
  
  protected <T extends EObject> void checkUnique(final List<T> items, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T>checkUnique(items, feature, _function);
  }
  
  protected <T extends EObject> void checkUnique(final boolean warning, final List<T> items, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T>checkUnique(warning, items, feature, _function);
  }
  
  protected <T extends EObject> void checkUnique(final List<T> items, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, Object> _function = (T it) -> {
      return it.eGet(feature);
    };
    this.<T, Object>checkUnique(items, _function, feature, errorMessageSupplier);
  }
  
  protected <T extends EObject> void checkUnique(final boolean warning, final List<T> items, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, Object> _function = (T it) -> {
      return it.eGet(feature);
    };
    this.<T, Object>checkUnique(warning, items, _function, feature, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T, K>checkUnique(items, keyMapper, feature, _function);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final boolean warning, final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final String errorMessage) {
    final Function1<T, String> _function = (T it) -> {
      return errorMessage;
    };
    this.<T, K>checkUnique(warning, items, keyMapper, feature, _function);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, EStructuralFeature> _function = (T it) -> {
      return feature;
    };
    this.<T, K>checkUnique(items, keyMapper, _function, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final boolean warning, final List<T> items, final Function1<? super T, ? extends K> keyMapper, final EStructuralFeature feature, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final Function1<T, EStructuralFeature> _function = (T it) -> {
      return feature;
    };
    this.<T, K>checkUnique(warning, items, keyMapper, _function, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final List<T> items, final Function1<? super T, ? extends K> keyMapper, final Function1<? super T, ? extends EStructuralFeature> featureMapper, final Function1<? super T, ? extends String> errorMessageSupplier) {
    this.<T, K>checkUnique(false, items, keyMapper, featureMapper, errorMessageSupplier);
  }
  
  protected <T extends EObject, K extends Object> void checkUnique(final boolean warning, final List<T> items, final Function1<? super T, ? extends K> keyMapper, final Function1<? super T, ? extends EStructuralFeature> featureMapper, final Function1<? super T, ? extends String> errorMessageSupplier) {
    final HashMap<K, SeenInfo<T>> seen = MclootValidator.<K, T>newSeenMap(items.size());
    for (final T item : items) {
      {
        final K key = keyMapper.apply(item);
        if ((key != null)) {
          final SeenInfo<T> info = seen.get(key);
          if ((info == null)) {
            seen.put(key, MclootValidator.<T>seen(item));
          } else {
            if ((!info.errored)) {
              info.errored = true;
              if (warning) {
                this.warning(errorMessageSupplier.apply(info.value), 
                  info.value, 
                  featureMapper.apply(info.value));
              } else {
                this.error(errorMessageSupplier.apply(info.value), 
                  info.value, 
                  featureMapper.apply(info.value));
              }
            }
            if (warning) {
              this.warning(errorMessageSupplier.apply(item), item, 
                featureMapper.apply(item));
            } else {
              this.error(errorMessageSupplier.apply(item), item, 
                featureMapper.apply(item));
            }
          }
        }
      }
    }
  }
}
