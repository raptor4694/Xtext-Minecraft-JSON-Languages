/*
 * generated by Xtext 2.21.0
 */
package com.raptor.mcloottable.validation

import com.raptor.mcloottable.mcloot.*
import java.util.HashMap
import org.eclipse.xtext.validation.Check
import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor
import org.eclipse.xtend.lib.annotations.ToString
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import com.raptor.mcloottable.util.MinecraftData

import static com.raptor.mcloottable.mcloot.MclootPackage.Literals.*
import static extension com.raptor.mcloottable.util.MclootUtils.*
import static com.raptor.mcloottable.util.MinecraftData.*
import static java.lang.Math.*
import java.util.List
import java.util.EnumMap

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MclootValidator extends AbstractMclootValidator {

    @Check
    def checkNoDuplicates(MCJsonObject it) {
        if (entries.size <= 1) { return }
        val seenEntries = <String,MCJsonEntry>newSeenMap(entries.size)
        for (entry : entries) {
            val info = seenEntries.get(entry.name)
            if (info === null) {
                seenEntries.put(entry.name, seen(entry))
            } else {
                if (!info.errored) {
                    info.errored = true
                    error("Duplicate entry",
                        info.value,
                        MC_JSON_ENTRY__NAME
                    )
                }
                error("Duplicate entry",
                    entry,
                    MC_JSON_ENTRY__NAME
                )
            }
        }
    }

    @Check
    def checkLootTable(LootTable it) {
        if (poolsDefined) {
            if (typeDefined && type == EnumLootTableType.EMPTY) {
                error("Type 'empty' cannot specify any pools",
                    LOOT_TABLE__POOLS_DEFINED
                )
            } else if (pools.isEmpty) {
                error("No pools given",
                    LOOT_TABLE__POOLS_DEFINED
                )
            }
        } else if (typeDefined && type != EnumLootTableType.EMPTY) {
            error("No pools given",
                LOOT_TABLE__TYPE_DEFINED
            )
        }
        if (!pools.isEmpty) {
            checkUnique(pools, LOOT_POOL__NAME, ['''Duplicate loot pool "«name»"'''])
        }
    }
    
    @Check
    def checkLootPool(LootPool it) {
        if (entries.isEmpty) {
            error("No entries given",
                if (entriesDefined) LOOT_POOL__ENTRIES_DEFINED else LOOT_POOL__NAME
            )
        } else {
            checkUnique(/*warning:*/ true, entries, [entryName ?: name], 
                [if (entryName === null) LOOT_ENTRY__NAME else LOOT_ENTRY__ENTRY_NAME], 
                ['''Duplicate loot entry "«entryName ?: name»"''']
            )
        }
        if (rollsDefined) {
            checkULongRange(rolls)
        }
        if (functionsDefined && functions.isEmpty) {
            warning("No functions given",
                LOOT_POOL__FUNCTIONS_DEFINED
            )
        }
    }
    
    @Check
    def checkLootEntry(LootEntry it) {
        switch (type) {
            case "tag": {
                ifMinecraftKey(name) [name |
                    if (!isVanillaItemTag(name)) {
                        warning("Unknown vanilla item tag",
                            LOOT_ENTRY__NAME
                        )
                    }
                    if (name !== it.name) {
                        info("Namespace defaulting to 'minecraft'",
                            LOOT_ENTRY__NAME
                        )
                    }
                ]
            }
            case "item": {
                ifMinecraftKey(name) [name |
                    if (!isVanillaItem(name)) {
                        warning("Unknown vanilla item name",
                            LOOT_ENTRY__NAME
                        )
                    }
                    if (name !== it.name) {
                        info("Namespace defaulting to 'minecraft'",
                            LOOT_ENTRY__NAME
                        )
                    }
                ]
            }
            case "loot_table": {
                ifMinecraftKey(name) [name |
                    if (!isVanillaLootTable(name)) {
                        warning("Unknown vanilla loot table",
                            LOOT_ENTRY__NAME
                        )
                    }
                    if (name !== it.name) {
                        info("Namespace defaulting to 'minecraft'",
                            LOOT_ENTRY__NAME
                        )
                    }
                ]
            }
//            case "dynamic": {
//                if (name != "contents" && name != "self") {
//                    error("Type 'dynamic' requires a value of either 'contents' or 'self'",
//                        LOOT_ENTRY__NAME
//                    )
//                }
//            }
            case "group", case "alternatives", case "sequence": {
                if (children.isEmpty) {
                    error("No children given",
                        if (childrenDefined) LOOT_ENTRY__CHILDREN_DEFINED
                        else if (entryName !== null) LOOT_ENTRY__ENTRY_NAME
                        else LOOT_ENTRY__TYPE
                    )
                }
            }
        }
        if (functionsDefined && functions.isEmpty) {
            warning("No functions given",
                LOOT_ENTRY__FUNCTIONS_DEFINED
            )
        }
        if (weightDefined && weight <= 0) {
            error("Weight must be at least 1",
                LOOT_ENTRY__WEIGHT
            )
        }
    }
    
    @Check
    def checkLootFunction(ApplyBonusLootFunction it) {
        ifMinecraftKey(enchantment) [enchantment |
            if (!isVanillaEnchantment(enchantment)) {
                warning("Unknown vanilla enchantment",
                    APPLY_BONUS_LOOT_FUNCTION__ENCHANTMENT
                )
            }
        ]
        switch (formula) {
            case BINOMIAL_WITH_BONUS_COUNT: {
                if (bonusMultiplierDefined) {
                    error("'bonusMultiplier' parameter only allowed when formula is 'uniform_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__BONUS_MULTIPLIER_DEFINED
                    )
                }
                if (!extraDefined) {
                    error("Missing 'extra' parameter for formula 'binomial_with_bonus_count'",
                        LOOT_FUNCTION__ID
                    )
                }
                if (!probabilityDefined) {
                    error("Missing 'probability' parameter for formula 'binomial_with_bonus_count'",
                        LOOT_FUNCTION__ID
                    )
                } else {
                    checkPercentage(it, APPLY_BONUS_LOOT_FUNCTION__PROBABILITY)
                }
            }
            case ORE_DROPS: {
                if (bonusMultiplierDefined) {
                    error("'bonusMultiplier' parameter only allowed when formula is 'uniform_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__BONUS_MULTIPLIER_DEFINED
                    )
                }
                if (extraDefined) {
                    error("'extra' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__EXTRA_DEFINED
                    )
                }
                if (probabilityDefined) {
                    error("'probability' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__PROBABILITY_DEFINED
                    )
                }
            }
            case UNIFORM_BONUS_COUNT: {
                if (extraDefined) {
                    error("'extra' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__EXTRA_DEFINED
                    )
                }
                if (probabilityDefined) {
                    error("'probability' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__PROBABILITY_DEFINED
                    )
                }
                if (!bonusMultiplierDefined) {
                    error("Missing 'bonusMultiplier' parameter for formula 'uniform_bonus_count'",
                        LOOT_FUNCTION__ID
                    )
                }
            }
        }
    }
    
    @Check
    def checkLootFunction(CopyStateLootFunction it) {
        ifMinecraftKey(block) [block |
            val blockStates = VANILLA_BLOCK_STATES.get(block)
            if (blockStates === null) {
                warning("Unknown vanilla block name",
                    COPY_STATE_LOOT_FUNCTION__BLOCK
                )
                checkUniqueValues(COPY_STATE_LOOT_FUNCTION__PROPERTIES, "Duplicate property")
            } else if (!properties.isEmpty) {
               checkUniqueValues(COPY_STATE_LOOT_FUNCTION__PROPERTIES, [String property, i |
                   if (!blockStates.containsKey(property)) {
                        error('''Block minecraft:«block» does not have a state named «property».''',
                            COPY_STATE_LOOT_FUNCTION__PROPERTIES, i
                        )
                    }
                    return property
               ], "Duplicate property")
            }
        ].otherwise [
            checkUniqueValues(COPY_STATE_LOOT_FUNCTION__PROPERTIES, "Duplicate property")
        ]
    }
    
    @Check
    def checkLootFunction(EnchantRandomlyLootFunction it) {
        if (!enchantments.isEmpty) {
            checkUniqueValues(ENCHANT_RANDOMLY_LOOT_FUNCTION__ENCHANTMENTS, [String enchantment, i |
                ifMinecraftKey(enchantment) [ ench |
                    if (!isVanillaEnchantment(ench)) {
                        warning("Unknown vanilla enchantment name",
                            ENCHANT_RANDOMLY_LOOT_FUNCTION__ENCHANTMENTS, i
                        )
                    }
                    if (enchantment !== ench) {
                        info("Namespace defaulting to 'minecraft'",
                            ENCHANT_RANDOMLY_LOOT_FUNCTION__ENCHANTMENTS, i
                        )
                    }
                ]
                return enchantment
            ], "Duplicate enchantment")
        }
    }
    
    @Check
    def checkLootFunction(EnchantWithLevelsLootFunction it) {
        checkULongRange(levels)
    }
    
    @Check
    def checkLootFunction(ExplorationMapLootFunction it) {
        if (eContainer instanceof LootEntry) {
            val entry = eContainer as LootEntry
            if (entry.type == "item") {
                if (entry.name != "minecraft:map" && entry.name != "map") {
                    warning("exploration_map function only works with item 'minecraft:map'",
                        LOOT_FUNCTION__ID
                    )
                }
            }
        }
        if (!isVanillaStructureFeature(destination)) {
            warning("Unknown vanilla structure feature name",
                EXPLORATION_MAP_LOOT_FUNCTION__DESTINATION
            )
        }
        if (!isVanillaMapIcon(decoration)) {
            warning("Unknown vanilla map icon name",
                EXPLORATION_MAP_LOOT_FUNCTION__DECORATION
            )
        }
    }
    
    @Check
    def checkLootFunction(FillPlayerHeadLootFunction it) {
        if (eContainer instanceof LootEntry) {
            val entry = eContainer as LootEntry
            if (entry.type == "item") {
                if (entry.name != "minecraft:player_head" && entry.name != "player_head") {
                    warning("fill_player_head function only works with item 'minecraft:player_head'",
                        LOOT_FUNCTION__ID
                    )
                }
            }
        }
    }
    
    @Check
    def checkLootFunction(SetAttributesLootFunction it) {
        checkUnique(modifiers, ATTRIBUTE_MODIFIER__UUID, "Duplicate UUID")
    }
    
    @Check
    def checkAttributeModifier(AttributeModifier it) {
        if (slotDefined && !singleSlot) {
            if (slots.isEmpty) {
                warning("No slots given",
                    ATTRIBUTE_MODIFIER__SLOT_DEFINED
                )
            } else {
                checkUniqueValues(ATTRIBUTE_MODIFIER__SLOTS, "Duplicate slot entry")
            }
        }
    }
    
    @Check
    def checkLootFunction(SetContentsLootFunction it) {
        if (entries.isEmpty) {
            error("No entries given",
                LOOT_FUNCTION__ID
            )
        } else {
            checkUnique(/*warning:*/ true, entries, [entryName ?: name], 
                [if (entryName === null) LOOT_ENTRY__NAME else LOOT_ENTRY__ENTRY_NAME], 
                ['''Duplicate loot entry "«entryName ?: name»"''']
            )
        }
    }
    
    @Check
    def checkUniformCount(UniformCount it) {
        if (min > max) {
            error("Range start cannot be greater than range end",
                UNIFORM_COUNT__MIN
            )
            error("Range start cannot be greater than range end",
                UNIFORM_COUNT__MAX
            )
        } else if (min == max) {
            warning("Range size == 1, don't need range syntax",
                UNIFORM_COUNT__MIN
            )
            warning("Range size == 1, don't need range syntax",
                UNIFORM_COUNT__MAX
            )
        }
    }
    
    @Check
    def checkBinomialCount(BinomialCount it) {
        checkPercentage(BINOMIAL_COUNT__P)
    }
    
    @Check
    def checkLootFunction(SetDamageLootFunction it) {
        checkPercentageRange(damage)
    }
    
    @Check
    def checkLootFunction(SetStewEffectLootFunction it) {
        checkUnique(effects, STEW_EFFECT__TYPE, "Duplicate effect")
    }
    
    @Check
    def checkStewEffect(StewEffect it) {
        ifMinecraftKey(type) [type |
            if (!isVanillaMobEffect(type)) {
                warning("Unknown vanilla mob effect type",
                    STEW_EFFECT__TYPE
                )
            }
            if (type !== it.type) {
                info("Namespace defaulting to 'minecraft'",
                    STEW_EFFECT__TYPE
                )
            }
        ]
    }
    
    @Check
    def checkLootCondition(BlockStatePropertiesLootCondition it) {
        ifMinecraftKey(block) [block |
            val states = VANILLA_BLOCK_STATES.get(block)
            if (states === null) {
                warning("Unknown vanilla block name",
                    BLOCK_STATE_PROPERTIES_LOOT_CONDITION__BLOCK
                )
                if (!properties.isEmpty) {
                    checkUnique(properties, BLOCK_STATE_PROPERTY__NAME, "Duplicate property")
                }
            } else if (!properties.isEmpty) {
                checkUnique(properties, [property |
                    val propObject = states.get(property.name)
                    if (propObject === null) {
                        error('''Block minecraft:«block» does not have a state named «property.name».''',
                            property,
                            BLOCK_STATE_PROPERTY__NAME
                        )
                    } else if (!propObject.isValid(property.value)) {
                        error('''"«property.value»" is not valid for property «property.name» of minecraft:«block»''',
                            property,
                            BLOCK_STATE_PROPERTY__VALUE
                        )
                    }
                    return property.name
                ], BLOCK_STATE_PROPERTY__NAME, "Duplicate property") 
            }
        ].otherwise [
            if (!properties.isEmpty) {
                checkUnique(properties, BLOCK_STATE_PROPERTY__NAME, "Duplicate property")
            }
        ]
    }
    
    @Check
    def checkLootCondition(EntityScoresLootCondition it) {
        if (scores.isEmpty) {
            warning("No scores given",
                LOOT_CONDITION__ID
            )
        } else {
            checkUnique(scores, ENTITY_SCORE__OBJECTIVE, "Duplicate score objective")
        }
    }
    
    @Check
    def checkLootCondition(RandomChanceLootCondition it) {
        checkPercentage(RANDOM_CHANCE_LOOT_CONDITION__CHANCE)
    }
    
    @Check
    def checkLootCondition(TableBonusLootCondition it) {
        ifMinecraftKey(enchantment) [enchantment |
            if (!isVanillaEnchantment(enchantment)) {
                warning("Unknown vanilla enchantment name",
                    TABLE_BONUS_LOOT_CONDITION__ENCHANTMENT
                )
            }
            if (enchantment !== it.enchantment) {
                info("Namespace defaulting to 'minecraft'",
                    TABLE_BONUS_LOOT_CONDITION__ENCHANTMENT
                )
            }
        ]
        checkPercentages(TABLE_BONUS_LOOT_CONDITION__CHANCES)
    }
    
    @Check
    def checkLootCondition(ToolEnchantmentLootCondition it) {
        if (enchantments.isEmpty) {
            warning("No enchantments defined",
                LOOT_CONDITION__ID
            )
        } else {
            checkUnique(enchantments, [level |
                ifMinecraftKey(level.enchantment) [enchantment |
                    if (!isVanillaEnchantment(enchantment)) {
                        warning("Unknown vanilla enchantment name",
                            level,
                            ENCHANTMENT_LEVEL__ENCHANTMENT
                        )
                    }
                    if (enchantment !== level.enchantment) {
                        info("Namespace defaulting to 'minecraft'",
                            level,
                            ENCHANTMENT_LEVEL__ENCHANTMENT
                        )
                    }
                ]
                return level.enchantment
            ], ENCHANTMENT_LEVEL__ENCHANTMENT, "Duplicate enchantment level entry")
        }
    }
    
    @Check
    def checkEntityPredicate(EntityPredicate it) {
        if (effectsDefined) {
            if (effects.isEmpty) {
                warning("No effects given",
                    ENTITY_PREDICATE__EFFECTS_DEFINED
                )
            } else {
                checkUnique(effects, [effect |
                    ifMinecraftKey(effect.id) [id |
                        if (!isVanillaMobEffect(id)) {
                            warning("Unknown vanilla mob effect type",
                                effect,
                                EFFECT_PREDICATE__ID
                            )
                        }
                        if (id !== effect.id) {
                            info("Namespace defaulting to 'minecraft'",
                                effect,
                                EFFECT_PREDICATE__ID
                            )
                        }
                    ]
                    return effect.id
                ], EFFECT_PREDICATE__ID, "Duplicate effect predicate")
            }
        }
        if (!equipment.isEmpty) {
            val seen = new EnumMap<EnumEquipmentSlot, SeenInfo<Pair<EquipmentPredicate,Integer>>>(EnumEquipmentSlot)
            for (predicate : equipment) {
                val slots = predicate.slots
                for (var i = 0; i < slots.size; i++) {
                    val enumEquipmentSlot = slots.get(i)
                    val info = seen.get(enumEquipmentSlot)
                    if (info === null) {
                        seen.put(enumEquipmentSlot, seen(predicate -> i))
                    } else {
                        if (!info.errored) {
                            info.errored = true
                            error("Duplicate equipment slot definition",
                                info.value.key,
                                EQUIPMENT_PREDICATE__SLOTS, info.value.value
                            )
                        }
                        error("Duplicate equipment slot definition",
                            predicate,
                            EQUIPMENT_PREDICATE__SLOTS, i
                        )
                    }
                }
            }
            if (seen.size == 6 && defaultEquipment !== null) {
                warning("Unused default equipment",
                    ENTITY_PREDICATE__DEFAULT_EQUIPMENT
                )
            }
        }
    }
    
    @Check
    def checkLongRange(NormalLongRange it) {
        if (minDefined && maxDefined) {
            if (min > max) {
                error("Range start cannot be greater than range end",
                    NORMAL_LONG_RANGE__MIN
                )
                error("Range start cannot be greater than range end",
                    NORMAL_LONG_RANGE__MAX
                )
            } else if (min == max) {
                warning("Range size == 1, don't need range syntax",
                    NORMAL_LONG_RANGE__MIN
                )
                warning("Range size == 1, don't need range syntax",
                    NORMAL_LONG_RANGE__MAX
                )
            }
        }
    }
    
    @Check
    def checkDoubleRange(NormalDoubleRange it) {
        if (minDefined && maxDefined) {
            if (min > max) {
                error("Range start cannot be greater than range end",
                    NORMAL_DOUBLE_RANGE__MIN
                )
                error("Range start cannot be greater than range end",
                    NORMAL_DOUBLE_RANGE__MAX
                )
            } else if (min == max) {
                warning("Range size == 1, don't need range syntax",
                    NORMAL_DOUBLE_RANGE__MIN
                )
                warning("Range size == 1, don't need range syntax",
                    NORMAL_DOUBLE_RANGE__MAX
                )
            }
        }
    }
    
    def checkLongRange(LongRange range, Long min_param, Long max_param) {
        val long min = min_param ?: Long.MIN_VALUE
        val long max = max_param ?: Long.MAX_VALUE
        switch (range) {
            ExactLongRange: {
                if (range.value < min) {
                    error("Value is too small",
                        range,
                        EXACT_LONG_RANGE__VALUE
                    )
                } else if (range.value > max) {
                    error("Value is too large",
                        range,
                        EXACT_LONG_RANGE__VALUE
                    )
                }
            }
            NormalLongRange: {
                if (range.minDefined) {
                    if (range.min < min) {
                        error("Value is too small",
                            range,
                            NORMAL_LONG_RANGE__MIN
                        )
                    } else if (range.min > max) {
                        error("Value is too large",
                            range,
                            NORMAL_LONG_RANGE__MIN
                        )
                    }
                }
                if (range.maxDefined) {
                    if (range.max < min) {
                        error("Value is too small",
                            range,
                            NORMAL_LONG_RANGE__MAX
                        )
                    } else if (range.max > max) {
                        error("Value is too large",
                            range,
                            NORMAL_LONG_RANGE__MAX
                        )
                    }
                }
            }
        }
    }
    
    def checkULongRange(LongRange range) {
        checkLongRange(range, 0L, null)
    }
    
    def checkDoubleRange(DoubleRange range, Double min_param, Double max_param) {
        val double min = min_param ?: Double.NEGATIVE_INFINITY
        val double max = max_param ?: Double.POSITIVE_INFINITY
        switch (range) {
            ExactDoubleRange: {
                if (range.value < min) {
                    error("Value is too small",
                        range,
                        EXACT_DOUBLE_RANGE__VALUE
                    )
                } else if (range.value > max) {
                    error("Value is too large",
                        range,
                        EXACT_DOUBLE_RANGE__VALUE
                    )
                }
            }
            NormalDoubleRange: {
                if (range.minDefined) {
                    if (range.min < min) {
                        error("Value is too small",
                            range,
                            NORMAL_DOUBLE_RANGE__MIN
                        )
                    } else if (range.min > max) {
                        error("Value is too large",
                            range,
                            NORMAL_DOUBLE_RANGE__MIN
                        )
                    }
                }
                if (range.maxDefined) {
                    if (range.max < min) {
                        error("Value is too small",
                            range,
                            NORMAL_DOUBLE_RANGE__MAX
                        )
                    } else if (range.max > max) {
                        error("Value is too large",
                            range,
                            NORMAL_DOUBLE_RANGE__MAX
                        )
                    }
                }
            }
        }
    }

    def checkPercentageRange(DoubleRange range) {
       switch (range) {
           ExactDoubleRange: {
               checkPercentage(range, EXACT_DOUBLE_RANGE__VALUE)
           }
           NormalDoubleRange: {
               if (range.minDefined) {
                   checkPercentage(range, NORMAL_DOUBLE_RANGE__MIN)
               }
               if (range.maxDefined) {
                   checkPercentage(range, NORMAL_DOUBLE_RANGE__MAX)
               }
           }
       }
    }

    def checkPercentage(EObject object, EStructuralFeature feature) {
        val double value = object.eGet(feature) as Double
        if (value < 0 || value > 1) {
            error("Value must be between 0 and 1",
                object,
                feature
            )
        }
    }
    
    def checkPercentages(EObject object, EStructuralFeature feature) {
        val values = object.eGet(feature) as List<Double>
        for (var i = 0; i < values.size; i++) {
            val double value = values.get(i)
            if (value < 0 || value > 1) {
                error("Value must be between 0 and 1",
                    object,
                    feature, i
                )
            }
        }
    }
    
    def protected static isWithin(double value, double min, double max) { min <= value && value <= max }
    def protected static isWithin(float value, float min, float max) { min <= value && value <= max }
    def protected static isWithin(long value, long min, long max) { min <= value && value <= max }
    def protected static isWithin(int value, int min, int max) { min <= value && value <= max }

    def protected static <T> seen(T value) { new SeenInfo(value) }
    
    def protected static <K,T> newSeenMap() { new HashMap<K,SeenInfo<T>> }
    def protected static <K,T> newSeenMap(int capacity) { new HashMap<K,SeenInfo<T>>(capacity) }
	
	
	def protected <T extends EObject> checkUnique(List<T> items, EStructuralFeature feature, String errorMessage) {
        checkUnique(items, feature, [errorMessage])
    }
    
    def protected <T extends EObject> checkUnique(boolean warning, List<T> items, EStructuralFeature feature, String errorMessage) {
        checkUnique(warning, items, feature, [errorMessage])
    }
    
	def protected <T extends EObject> checkUnique(List<T> items, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
	    checkUnique(items, [eGet(feature)], feature, errorMessageSupplier)
	}
	
	def protected <T extends EObject> checkUnique(boolean warning, List<T> items, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
        checkUnique(warning, items, [eGet(feature)], feature, errorMessageSupplier)
    }
	
	def protected <T extends EObject,K> checkUnique(List<T> items, (T)=>K keyMapper, EStructuralFeature feature, String errorMessage) {
	    checkUnique(items, keyMapper, feature, [errorMessage])
	}
	
	def protected <T extends EObject,K> checkUnique(boolean warning, List<T> items, (T)=>K keyMapper, EStructuralFeature feature, String errorMessage) {
        checkUnique(warning, items, keyMapper, feature, [errorMessage])
    }
	
	def protected <T extends EObject,K> checkUnique(List<T> items, (T)=>K keyMapper, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
	    checkUnique(items, keyMapper, [feature], errorMessageSupplier)
	}
	
	def protected <T extends EObject,K> checkUnique(boolean warning, List<T> items, (T)=>K keyMapper, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
        checkUnique(warning, items, keyMapper, [feature], errorMessageSupplier)
    }
	
	def protected <T extends EObject,K> checkUnique(List<T> items,  (T)=>K keyMapper, (T)=>EStructuralFeature featureMapper, (T)=>String errorMessageSupplier) {
	    checkUnique(false, items, keyMapper, featureMapper, errorMessageSupplier)
	}
	
	def protected <T extends EObject,K> checkUnique(boolean warning, List<T> items, (T)=>K keyMapper, (T)=>EStructuralFeature featureMapper, (T)=>String errorMessageSupplier) {
	    if (items.isEmpty) { return }
	    val seen = <K,T>newSeenMap(items.size)
	    for (item : items) {
	        val key = keyMapper.apply(item)
	        if (key !== null) {
    	        val info = seen.get(key)
    	        if (info === null) {
    	            seen.put(key, seen(item))
    	        } else {
    	            if (!info.errored) {
    	                info.errored = true
    	                if (warning) {
    	                    warning(errorMessageSupplier.apply(info.value),
                                info.value,
                                featureMapper.apply(info.value)
                            )
    	                } else {
        	                error(errorMessageSupplier.apply(info.value),
        	                    info.value,
        	                    featureMapper.apply(info.value)
        	                )
    	                }
    	            }
    	            if (warning) {
    	                warning(errorMessageSupplier.apply(item),
                            item,
                            featureMapper.apply(item)
                        )
    	            } else {
        	            error(errorMessageSupplier.apply(item),
        	                item,
        	                featureMapper.apply(item)
        	            )
        	        }
    	        }
    	    }
	    }
	}
	
	def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, String errorMessage) {
        checkUniqueValues(false, object, feature, [errorMessage])
    }
	
	def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, (T, int)=>String errorMessageSupplier) {
	    checkUniqueValues(false, object, feature, errorMessageSupplier)
	}
	
	def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, String errorMessage) {
        checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, [$0], [errorMessage])
    }
	
	def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, (T, int)=>String errorMessageSupplier) {
	    checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, [$0], errorMessageSupplier)
	}
	
	def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, String errorMessage) {
        checkUniqueValues(false, items, object, feature, [$0], [errorMessage])
    }
	
	def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, (T, int)=>String errorMessageSupplier) {
	    checkUniqueValues(false, items, object, feature, [$0], errorMessageSupplier)
	}
	
	def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, String errorMessage) {
        checkUniqueValues(false, object, feature, keyMapper, [errorMessage])
    }
    
    def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
        checkUniqueValues(false, object, feature, keyMapper, errorMessageSupplier)
    }
    
    def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, String errorMessage) {
        checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, keyMapper, [errorMessage])
    }
    
    def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
        checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, keyMapper, errorMessageSupplier)
    }
    
    def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, String errorMessage) {
        checkUniqueValues(false, items, object, feature, keyMapper, [errorMessage])
    }
    
    def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
        checkUniqueValues(false, items, object, feature, keyMapper, errorMessageSupplier)
    }
	
	def protected <T> checkUniqueValues(boolean warning, List<T> items, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
	    if (items.isEmpty) { return }
	    val seen = <Object,Integer>newSeenMap(items.size)
	    for (var i = 0; i < items.size; i++) {
	        val item = items.get(i)
	        val key = keyMapper.apply(item, i)
	        val info = seen.get(key)
	        if (info === null) {
	            seen.put(key, seen(i))
	        } else {
	            if (!info.errored) {
	                info.errored = true
	                if (warning) {
	                    warning(errorMessageSupplier.apply(items.get(info.value), info.value),
	                        object,
	                        feature, info.value
	                    )
	                } else {
	                    error(errorMessageSupplier.apply(items.get(info.value), info.value),
                            object,
                            feature, info.value
                        )
	                }
	            }
	            if (warning) {
	                warning(errorMessageSupplier.apply(item, i),
	                    object,
	                    feature, i
	                )
	            }
	        }
	    }
	}
	
}

@FinalFieldsConstructor
@ToString
class SeenInfo<T> {
    public final T value    
    public boolean errored = false
}

