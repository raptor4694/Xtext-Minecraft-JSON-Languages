/*
 * generated by Xtext 2.21.0
 */
package com.raptor.mcloottable.validation

import com.raptor.mcloottable.mcloot.*
import java.util.HashMap
import org.eclipse.xtext.validation.Check
import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor
import org.eclipse.xtend.lib.annotations.ToString
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import com.raptor.mcloottable.util.MinecraftData

import static com.raptor.mcloottable.mcloot.MclootPackage.Literals.*
import static extension com.raptor.mcloottable.util.MclootUtils.*
import static java.lang.Math.*
import java.util.List

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MclootValidator extends AbstractMclootValidator {

    @Check
    def checkLootTable(LootTable it) {
        if (poolsDefined) {
            if (typeDefined && type == EnumLootTableType.EMPTY) {
                error("Type 'empty' cannot specify any pools",
                    LOOT_TABLE__POOLS_DEFINED
                )
            } else if (pools.isEmpty) {
                error("No pools given",
                    LOOT_TABLE__POOLS_DEFINED
                )
            }
        } else if (typeDefined && type != EnumLootTableType.EMPTY) {
            error("No pools given",
                LOOT_TABLE__TYPE_DEFINED
            )
        }
        if (!pools.isEmpty) {
            checkUnique(pools, LOOT_POOL__NAME, ['''Duplicate loot pool "«name»"'''])
        }
    }
    
    @Check
    def checkLootPool(LootPool it) {
        if (entries.isEmpty) {
            error("No entries given",
                if (entriesDefined) LOOT_POOL__ENTRIES_DEFINED else LOOT_POOL__NAME
            )
        } else {
            checkUnique(/*warning:*/ true, entries, [entryName ?: name], 
                [if (entryName === null) LOOT_ENTRY__NAME else LOOT_ENTRY__ENTRY_NAME], 
                ['''Duplicate loot pool "«entryName ?: name»"''']
            )
        }
        if (rollsDefined) {
            checkULongRange(rolls)
        }
        if (functionsDefined && functions.isEmpty) {
            warning("No functions given",
                LOOT_POOL__FUNCTIONS_DEFINED
            )
        }
    }
    
    @Check
    def checkLootEntry(LootEntry it) {
        switch (type) {
            case "tag": {
                ifMinecraftKey(name) [name |
                    if (!MinecraftData.VANILLA_ITEM_TAGS.contains(name)) {
                        warning("Unknown vanilla item tag",
                            LOOT_ENTRY__NAME
                        )
                    }
                    if (name !== it.name) {
                        info("Namespace defaulting to 'minecraft'",
                            LOOT_ENTRY__NAME
                        )
                    }
                ]
            }
            case "item": {
                ifMinecraftKey(name) [name |
                    if (!MinecraftData.VANILLA_ITEMS.contains(name)) {
                        warning("Unknown vanilla item name",
                            LOOT_ENTRY__NAME
                        )
                    }
                    if (name !== it.name) {
                        info("Namespace defaulting to 'minecraft'",
                            LOOT_ENTRY__NAME
                        )
                    }
                ]
            }
            case "loot_table": {
                ifMinecraftKey(name) [name |
                    if (!MinecraftData.VANILLA_LOOT_TABLES.contains(name)) {
                        warning("Unknown vanilla loot table",
                            LOOT_ENTRY__NAME
                        )
                    }
                    if (name !== it.name) {
                        info("Namespace defaulting to 'minecraft'",
                            LOOT_ENTRY__NAME
                        )
                    }
                ]
            }
//            case "dynamic": {
//                if (name != "contents" && name != "self") {
//                    error("Type 'dynamic' requires a value of either 'contents' or 'self'",
//                        LOOT_ENTRY__NAME
//                    )
//                }
//            }
            case "group", case "alternatives", case "sequence": {
                if (children.isEmpty) {
                    error("No children given",
                        if (childrenDefined) LOOT_ENTRY__CHILDREN_DEFINED
                        else if (entryName !== null) LOOT_ENTRY__ENTRY_NAME
                        else LOOT_ENTRY__TYPE
                    )
                }
            }
        }
        if (functionsDefined && functions.isEmpty) {
            warning("No functions given",
                LOOT_ENTRY__FUNCTIONS_DEFINED
            )
        }
        if (weightDefined && weight <= 0) {
            error("Weight must be at least 1",
                LOOT_ENTRY__WEIGHT
            )
        }
    }
    
    @Check
    def checkLootFunction(ApplyBonusLootFunction it) {
        ifMinecraftKey(enchantment) [enchantment |
            if (!MinecraftData.VANILLA_ENCHANTMENTS.contains(enchantment)) {
                warning("Unknown vanilla enchantment",
                    APPLY_BONUS_LOOT_FUNCTION__ENCHANTMENT
                )
            }
        ]
        switch (formula) {
            case BINOMIAL_WITH_BONUS_COUNT: {
                if (bonusMultiplierDefined) {
                    error("'bonusMultiplier' parameter only allowed when formula is 'uniform_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__BONUS_MULTIPLIER_DEFINED
                    )
                }
                if (!extraDefined) {
                    error("Missing 'extra' parameter for formula 'binomial_with_bonus_count'",
                        LOOT_FUNCTION__ID
                    )
                }
                if (!probabilityDefined) {
                    error("Missing 'probability' parameter for formula 'binomial_with_bonus_count'",
                        LOOT_FUNCTION__ID
                    )
                } else {
                    checkPercentage(it, APPLY_BONUS_LOOT_FUNCTION__PROBABILITY)
                }
            }
            case ORE_DROPS: {
                if (bonusMultiplierDefined) {
                    error("'bonusMultiplier' parameter only allowed when formula is 'uniform_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__BONUS_MULTIPLIER_DEFINED
                    )
                }
                if (extraDefined) {
                    error("'extra' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__EXTRA_DEFINED
                    )
                }
                if (probabilityDefined) {
                    error("'probability' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__PROBABILITY_DEFINED
                    )
                }
            }
            case UNIFORM_BONUS_COUNT: {
                if (extraDefined) {
                    error("'extra' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__EXTRA_DEFINED
                    )
                }
                if (probabilityDefined) {
                    error("'probability' parameter only allowed when formula is 'binomial_with_bonus_count'",
                        APPLY_BONUS_LOOT_FUNCTION__PROBABILITY_DEFINED
                    )
                }
                if (!bonusMultiplierDefined) {
                    error("Missing 'bonusMultiplier' parameter for formula 'uniform_bonus_count'",
                        LOOT_FUNCTION__ID
                    )
                }
            }
        }
    }
    
    @Check
    def checkLootFunction(CopyStateLootFunction it) {
        ifMinecraftKey(block) [block |
            val blockStates = MinecraftData.VANILLA_BLOCK_STATES.get(block)
            if (blockStates === null) {
                warning("Unknown vanilla block name",
                    COPY_STATE_LOOT_FUNCTION__BLOCK
                )
                checkUniqueValues(it, COPY_STATE_LOOT_FUNCTION__PROPERTIES, "Duplicate property")
            } else if (!properties.isEmpty) {
               checkUniqueValues(it, COPY_STATE_LOOT_FUNCTION__PROPERTIES, [property, i |
                   if (!blockStates.containsKey(property)) {
                        error('''Block minecraft:«block» does not have a state named «property».''',
                            COPY_STATE_LOOT_FUNCTION__PROPERTIES, i
                        )
                    }
                    return property
               ], "Duplicate property")
            }
        ].otherwise [
            checkUniqueValues(it, COPY_STATE_LOOT_FUNCTION__PROPERTIES, "Duplicate property")
        ]
    }
    
    @Check
    def checkLootFunction(EnchantRandomlyLootFunction it) {
        
    }
    
    @Check
    def checkLongRange(NormalLongRange it) {
        if (minDefined && maxDefined) {
            if (min > max) {
                error("Range start cannot be greater than range end",
                    NORMAL_LONG_RANGE__MIN
                )
                error("Range start cannot be greater than range end",
                    NORMAL_LONG_RANGE__MAX
                )
            } else if (min == max) {
                warning("Range size == 1, don't need range syntax",
                    NORMAL_LONG_RANGE__MIN
                )
                warning("Range size == 1, don't need range syntax",
                    NORMAL_LONG_RANGE__MAX
                )
            }
        }
    }
    
    @Check
    def checkDoubleRange(NormalDoubleRange it) {
        if (minDefined && maxDefined) {
            if (min > max) {
                error("Range start cannot be greater than range end",
                    NORMAL_DOUBLE_RANGE__MIN
                )
                error("Range start cannot be greater than range end",
                    NORMAL_DOUBLE_RANGE__MAX
                )
            } else if (min == max) {
                warning("Range size == 1, don't need range syntax",
                    NORMAL_DOUBLE_RANGE__MIN
                )
                warning("Range size == 1, don't need range syntax",
                    NORMAL_DOUBLE_RANGE__MAX
                )
            }
        }
    }
    
    def checkLongRange(LongRange range, Long min_param, Long max_param) {
        val long min = min_param ?: Long.MIN_VALUE
        val long max = max_param ?: Long.MAX_VALUE
        switch (range) {
            ExactLongRange: {
                if (range.value < min) {
                    error("Value is too small",
                        range,
                        EXACT_LONG_RANGE__VALUE
                    )
                } else if (range.value > max) {
                    error("Value is too large",
                        range,
                        EXACT_LONG_RANGE__VALUE
                    )
                }
            }
            NormalLongRange: {
                if (range.minDefined) {
                    if (range.min < min) {
                        error("Value is too small",
                            range,
                            NORMAL_LONG_RANGE__MIN
                        )
                    } else if (range.min > max) {
                        error("Value is too large",
                            range,
                            NORMAL_LONG_RANGE__MIN
                        )
                    }
                }
                if (range.maxDefined) {
                    if (range.max < min) {
                        error("Value is too small",
                            range,
                            NORMAL_LONG_RANGE__MAX
                        )
                    } else if (range.max > max) {
                        error("Value is too large",
                            range,
                            NORMAL_LONG_RANGE__MAX
                        )
                    }
                }
            }
        }
    }
    
    def checkULongRange(LongRange range) {
        checkLongRange(range, 0L, null)
    }
    
    def checkDoubleRange(DoubleRange range, Double min_param, Double max_param) {
        val double min = min_param ?: Double.NEGATIVE_INFINITY
        val double max = max_param ?: Double.POSITIVE_INFINITY
        switch (range) {
            ExactDoubleRange: {
                if (range.value < min) {
                    error("Value is too small",
                        range,
                        EXACT_DOUBLE_RANGE__VALUE
                    )
                } else if (range.value > max) {
                    error("Value is too large",
                        range,
                        EXACT_DOUBLE_RANGE__VALUE
                    )
                }
            }
            NormalDoubleRange: {
                if (range.minDefined) {
                    if (range.min < min) {
                        error("Value is too small",
                            range,
                            NORMAL_DOUBLE_RANGE__MIN
                        )
                    } else if (range.min > max) {
                        error("Value is too large",
                            range,
                            NORMAL_DOUBLE_RANGE__MIN
                        )
                    }
                }
                if (range.maxDefined) {
                    if (range.max < min) {
                        error("Value is too small",
                            range,
                            NORMAL_DOUBLE_RANGE__MAX
                        )
                    } else if (range.max > max) {
                        error("Value is too large",
                            range,
                            NORMAL_DOUBLE_RANGE__MAX
                        )
                    }
                }
            }
        }
    }

    def checkPercentageRange(DoubleRange range) {
       switch (range) {
           ExactDoubleRange: {
               checkPercentage(range, EXACT_DOUBLE_RANGE__VALUE)
           }
           NormalDoubleRange: {
               if (range.minDefined) {
                   checkPercentage(range, NORMAL_DOUBLE_RANGE__MIN)
               }
               if (range.maxDefined) {
                   checkPercentage(range, NORMAL_DOUBLE_RANGE__MAX)
               }
           }
       }
    }

    def checkPercentage(EObject object, EStructuralFeature feature) {
        val double value = object.eGet(feature) as Double
        if (value < 0 || value > 1) {
            error("Value must be between 0 and 1",
                object,
                feature
            )
        }
    }
    
    def protected static isWithin(double value, double min, double max) { min <= value && value <= max }
    def protected static isWithin(float value, float min, float max) { min <= value && value <= max }
    def protected static isWithin(long value, long min, long max) { min <= value && value <= max }
    def protected static isWithin(int value, int min, int max) { min <= value && value <= max }

    def protected static <T> seen(T value) { new SeenInfo(value) }
    
    def protected static <K,T> newSeenMap() { new HashMap<K,SeenInfo<T>> }
    def protected static <K,T> newSeenMap(int capacity) { new HashMap<K,SeenInfo<T>>(capacity) }
	
	
	def protected <T extends EObject> checkUnique(List<T> items, EStructuralFeature feature, String errorMessage) {
        checkUnique(items, feature, [errorMessage])
    }
    
    def protected <T extends EObject> checkUnique(boolean warning, List<T> items, EStructuralFeature feature, String errorMessage) {
        checkUnique(warning, items, feature, [errorMessage])
    }
    
	def protected <T extends EObject> checkUnique(List<T> items, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
	    checkUnique(items, [eGet(feature)], feature, errorMessageSupplier)
	}
	
	def protected <T extends EObject> checkUnique(boolean warning, List<T> items, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
        checkUnique(warning, items, [eGet(feature)], feature, errorMessageSupplier)
    }
	
	def protected <T extends EObject,K> checkUnique(List<T> items, (T)=>K keyMapper, EStructuralFeature feature, String errorMessage) {
	    checkUnique(items, keyMapper, feature, [errorMessage])
	}
	
	def protected <T extends EObject,K> checkUnique(boolean warning, List<T> items, (T)=>K keyMapper, EStructuralFeature feature, String errorMessage) {
        checkUnique(warning, items, keyMapper, feature, [errorMessage])
    }
	
	def protected <T extends EObject,K> checkUnique(List<T> items, (T)=>K keyMapper, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
	    checkUnique(items, keyMapper, [feature], errorMessageSupplier)
	}
	
	def protected <T extends EObject,K> checkUnique(boolean warning, List<T> items, (T)=>K keyMapper, EStructuralFeature feature, (T)=>String errorMessageSupplier) {
        checkUnique(warning, items, keyMapper, [feature], errorMessageSupplier)
    }
	
	def protected <T extends EObject,K> checkUnique(List<T> items,  (T)=>K keyMapper, (T)=>EStructuralFeature featureMapper, (T)=>String errorMessageSupplier) {
	    checkUnique(false, items, keyMapper, featureMapper, errorMessageSupplier)
	}
	
	def protected <T extends EObject,K> checkUnique(boolean warning, List<T> items, (T)=>K keyMapper, (T)=>EStructuralFeature featureMapper, (T)=>String errorMessageSupplier) {
	    if (items.isEmpty) { return }
	    val seen = <K,T>newSeenMap(items.size)
	    for (item : items) {
	        val key = keyMapper.apply(item)
	        if (key !== null) {
    	        val info = seen.get(key)
    	        if (info === null) {
    	            seen.put(key, seen(item))
    	        } else {
    	            if (!info.errored) {
    	                info.errored = true
    	                if (warning) {
    	                    warning(errorMessageSupplier.apply(info.value),
                                info.value,
                                featureMapper.apply(info.value)
                            )
    	                } else {
        	                error(errorMessageSupplier.apply(info.value),
        	                    info.value,
        	                    featureMapper.apply(info.value)
        	                )
    	                }
    	            }
    	            if (warning) {
    	                warning(errorMessageSupplier.apply(item),
                            item,
                            featureMapper.apply(item)
                        )
    	            } else {
        	            error(errorMessageSupplier.apply(item),
        	                item,
        	                featureMapper.apply(item)
        	            )
        	        }
    	        }
    	    }
	    }
	}
	
	def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, String errorMessage) {
        checkUniqueValues(false, object, feature, [errorMessage])
    }
	
	def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, (T, int)=>String errorMessageSupplier) {
	    checkUniqueValues(false, object, feature, errorMessageSupplier)
	}
	
	def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, String errorMessage) {
        checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, [$0], [errorMessage])
    }
	
	def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, (T, int)=>String errorMessageSupplier) {
	    checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, [$0], errorMessageSupplier)
	}
	
	def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, String errorMessage) {
        checkUniqueValues(false, items, object, feature, [$0], [errorMessage])
    }
	
	def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, (T, int)=>String errorMessageSupplier) {
	    checkUniqueValues(false, items, object, feature, [$0], errorMessageSupplier)
	}
	
	def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, String errorMessage) {
        checkUniqueValues(false, object, feature, keyMapper, [errorMessage])
    }
    
    def protected <T> checkUniqueValues(EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
        checkUniqueValues(false, object, feature, keyMapper, errorMessageSupplier)
    }
    
    def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, String errorMessage) {
        checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, keyMapper, [errorMessage])
    }
    
    def protected <T> checkUniqueValues(boolean warning, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
        checkUniqueValues(warning, object.eGet(feature) as List<T>, object, feature, keyMapper, errorMessageSupplier)
    }
    
    def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, String errorMessage) {
        checkUniqueValues(false, items, object, feature, keyMapper, [errorMessage])
    }
    
    def protected <T> checkUniqueValues(List<T> items, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
        checkUniqueValues(false, items, object, feature, keyMapper, errorMessageSupplier)
    }
	
	def protected <T> checkUniqueValues(boolean warning, List<T> items, EObject object, EStructuralFeature feature, (T, int)=>Object keyMapper, (T, int)=>String errorMessageSupplier) {
	    if (items.isEmpty) { return }
	    val seen = <Object,Integer>newSeenMap(items.size)
	    for (var i = 0; i < items.size; i++) {
	        val item = items.get(i)
	        val key = keyMapper.apply(item, i)
	        val info = seen.get(key)
	        if (info === null) {
	            seen.put(key, seen(i))
	        } else {
	            if (!info.errored) {
	                info.errored = true
	                if (warning) {
	                    warning(errorMessageSupplier.apply(items.get(info.value), info.value),
	                        object,
	                        feature, info.value
	                    )
	                } else {
	                    error(errorMessageSupplier.apply(items.get(info.value), info.value),
                            object,
                            feature, info.value
                        )
	                }
	            }
	            if (warning) {
	                warning(errorMessageSupplier.apply(item, i),
	                    object,
	                    feature, i
	                )
	            }
	        }
	    }
	}
	
}

@FinalFieldsConstructor
@ToString
class SeenInfo<T> {
    public final T value    
    public boolean errored = false
}

